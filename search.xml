<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APCS題解：2021年1月</title>
    <url>/apcs2101/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/YAk4Riy.png" alt=""><br>第一次考APCS，拿到觀念4級、實作3級，希望在下一次可以更進步！（我是大廢廢</p>
<h2 id="110-01-實作題第一題-購買力"><a href="#110-01-實作題第一題-購買力" class="headerlink" title="110/01 實作題第一題 購買力"></a>110/01 實作題第一題 購買力</h2><p>APCS的第一題都是應該要秒殺的，也順利拿到100分<br><span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,d,cost = <span class="number">0</span>,total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;d;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[<span class="number">0</span>]&gt;&gt;arr[<span class="number">1</span>]&gt;&gt;arr[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">sort</span>(arr, arr+<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]-arr[<span class="number">0</span>]&gt;=d)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            cost +=((arr[<span class="number">0</span>]+arr[<span class="number">1</span>]+arr[<span class="number">2</span>])/<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cost&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-01-實作題第二題-流量"><a href="#110-01-實作題第二題-流量" class="headerlink" title="110/01 實作題第二題 流量"></a>110/01 實作題第二題 流量</h2><p>這一題的題序有點複雜，看了幾次之後才看懂。但重點是在考試的時候沒有想到要怎麼合併流量，所以只用了一維陣列計算最小值，因此只有拿到50分…<br>這是完整版的程式碼，主要是透過創建一個陣列r[i][j]，表示從城市i出發到城市j的總流量，再利用陣列r計算費用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,K,s[<span class="number">50</span>][<span class="number">50</span>],r[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1e8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(r));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;N;q++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p;<span class="comment">//第i個伺服器架設在p城市</span></span><br><span class="line">            cin&gt;&gt;p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)r[p][j]+=s[q][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第0個跟第1個伺服器都架設在1的位置，則將流量相加，得到陣列r</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;M;q++)&#123;<span class="comment">//0&lt;p&lt;M</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q==j)sum+=r[q][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(r[q][j]&lt;=<span class="number">1000</span>)sum+=<span class="number">3</span>*r[q][j];</span><br><span class="line">                <span class="keyword">else</span> sum+=(r[q][j]<span class="number">-1000</span>)*<span class="number">2</span>+<span class="number">3000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-01-實作題第三題-切割費用"><a href="#110-01-實作題第三題-切割費用" class="headerlink" title="110/01 實作題第三題 切割費用"></a>110/01 實作題第三題 切割費用</h2><p>這一題雖然在考試中有想到利用二元樹的方法，於是開了一個陣列儲存樹的節點（前段時間寫了一些線段樹，所以用了這個方法！）但我沒有注意到這不是一棵完滿二元樹，<strong>不會平衡啊</strong>！把範例測資丟上去對了，結果半分都沒有拿到:cry:，以後必須注意！<br>用<em>std::set</em>搭配 <em>next(),prev()</em> 指標，找出鄰近的切割點之差，就可以AC了！</p>
<div class="note info">
            <p><img src="https://i.imgur.com/YqPsqDY.png" alt=""><br>在 <em>set</em> 中使用<em>insert()</em> 函式會回傳<em>pair<iterator,bool></em> 在使用的時候要變成：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = s.<span class="built_in">insert</span>(arr[i]).first;</span><br></pre></td></tr></table></figure>
          </div>
<p>這是考試送出的0分程式碼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,L,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> seg[<span class="number">1000000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[cur]==<span class="number">0</span>)&#123;</span><br><span class="line">        seg[cur] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val&gt;seg[cur])<span class="built_in">build</span>(val, <span class="number">2</span>*cur+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(val, <span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//建立一個會爆掉的二元樹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> up = L,low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[cur]==val)&#123;</span><br><span class="line">        ans+=up-low;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(seg[cur]!=val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&gt;seg[cur])&#123;</span><br><span class="line">            low = seg[cur];</span><br><span class="line">            cur = <span class="number">2</span>*cur+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            up = seg[cur];</span><br><span class="line">            cur = <span class="number">2</span>*cur+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=up-low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        arr[b<span class="number">-1</span>] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">build</span>(arr[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">func</span>(arr[i], <span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這是正解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,l,arr[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">0</span>,l&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ind,pos;cin&gt;&gt;pos&gt;&gt;ind;</span><br><span class="line">        arr[ind<span class="number">-1</span>] = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = s.<span class="built_in">insert</span>(arr[i]).first;</span><br><span class="line">        ans+= *<span class="built_in">next</span>(pos)- *<span class="built_in">prev</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-01-實作題第四題-飛黃騰達"><a href="#110-01-實作題第四題-飛黃騰達" class="headerlink" title="110/01 實作題第四題 飛黃騰達"></a>110/01 實作題第四題 飛黃騰達</h2><p>這是一題我在考試中根本沒有碰的題目（能力不足），聽到別人是說這是一題經典的LIS，所以寒假就開始了解<a href="https://hackmd.io/ytV5oL34TRyotshCcJHJ2g">動態規劃的題目</a>。這一題關鍵是先把x座標排列好（可以想成是LIS中的數列順序），然後依照y座標做LIS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        P[i] = <span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(P, P+n);<span class="comment">//利用pair排序，會先依照x排序，如果x相同，則照y排序</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;ans;<span class="comment">//儲存LIS</span></span><br><span class="line">    ans.<span class="built_in">push_back</span>(P[<span class="number">0</span>].second);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> now = P[i].second;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;=ans.<span class="built_in">back</span>())ans.<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ind = <span class="built_in">upper_bound</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),now)-ans.<span class="built_in">begin</span>();</span><br><span class="line">            ans[ind] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>這裡有一點跟LIS不一樣，它不需要嚴格遞增，因此在第20使用 <strong>&gt;=</strong> ，還有第22行使用<strong>upper_bound</strong>也是因為不需要嚴格遞增（如果要插入的值在LIS裡面就已經有了，兩者都可以保留，所以用<strong>upper_bound</strong>，取第一個大於它的數值更改掉。</p>
          </div>
<hr>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>第一次參加APCS拿到4,3的成績，雖然沒有很好（這一次還是比較簡單的題目！），但還是在預期之內。希望透果補足一些不足的地方，下一次會有更好的成績！</p>
<ol>
<li><strong>IDE環境不熟悉</strong><br> 平常都是在mac上打程式，而所有的比賽都只有windows的codeblocks，有時候debug的內容不小被我關掉就叫不出來，耗費許多時間。<br> 解決方法：下載codeblocks來好好熟悉一下</li>
<li><strong>題目練習不夠多</strong><br>在考試之前大多是聽別人講怎麼做，實際練習題目的量太少，所以在實際的競賽中就寫不出東西。<br>解決方法：每週固定寫一個主題的題目，反覆練習讓自己對這個主題更熟悉+寫APCS考古題。</li>
<li><strong>懂得東西太少</strong><br> 本次第三題就是很好的例子，自己寫二元樹出一堆問題，不如用std內建的set還比較快！雖然一直都知道set的存在，但實際的競賽中就不知道怎麼用。<br> 解決方法：資訊之芽好好學！</li>
<li><strong>實戰經驗不足</strong><br> 這應該是參加過的第三場正式的競賽（或檢定），以後就慢慢累積比賽的經驗<br> 解決方法：參加線上程式競賽，練手感。</li>
<li><strong>打字速度太慢</strong><br> 打字速度慢就拖慢整體的寫扣時間，必須加強！<br> 解決方法：每天花10分鐘碰碰鍵盤，利用網路上<a href="https://typing.io/lessons">打字練習</a>加快打字速度。</li>
</ol>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS題解：2021年9月</title>
    <url>/apcs2109/</url>
    <content><![CDATA[<p>這次沒有報名APCS，因為報名手續有點麻煩，還要在學證明和教師簽名等等，所以就沒有報…。總之，利用ZeroJudge的測資來寫寫看，但在ZJ上面會過不能保證真的去考APCS的測資就一定會過！</p>
<span id="more"></span>
<h2 id="P1-七言對聯"><a href="#P1-七言對聯" class="headerlink" title="P1 七言對聯"></a>P1 七言對聯</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g275">題目連結</a></p>
<p>總共有ABC三種規則，就每一種都比對一次就可以了！</p>
<p><strong>時間複雜度：</strong> 共有 $n$ 組對聯，每一組都 $O(1)$ 檢查，時間 $O(n)$ 。（不過n最大也才50，不論什麼複雜度都可以吧）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> a[N],b[N],f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">7</span>)cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">7</span>)cin&gt;&gt;b[i];</span><br><span class="line">        f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>]==a[<span class="number">4</span>]||a[<span class="number">2</span>]!=a[<span class="number">6</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;A&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[<span class="number">2</span>]==b[<span class="number">4</span>]||b[<span class="number">2</span>]!=b[<span class="number">6</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;A&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">7</span>]!=<span class="number">1</span> || b[<span class="number">7</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;B&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>]==b[<span class="number">2</span>]||a[<span class="number">4</span>]==b[<span class="number">4</span>]||a[<span class="number">6</span>]==b[<span class="number">6</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;C&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)cout&lt;&lt;<span class="string">&quot;None&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P2-魔王迷宮"><a href="#P2-魔王迷宮" class="headerlink" title="P2 魔王迷宮"></a>P2 魔王迷宮</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g276">題目連結</a></p>
<p>這一題我好像太早寫了，題目還在整修階段，丟上去TLE，發現題目敘述又改了XD，從魔王踩到炸彈爆炸後，「炸彈不會消失」，到「炸彈會消失」，還有範測也有改變。</p>
<p>這一題是去模擬每一個魔王移動的狀況，要特別注意每一輪的國王是同時移動的，沒有先後順序，也就是說一顆炸彈可以炸掉不只一位魔王，如果有多個魔王移動到同一個格子，則他們會一起被炸掉。</p>
<p><strong>時間複雜度：</strong> 有點難估計，因為很難確定每一個魔王的移動狀況次數，不過由於數字範圍不大，且 $k$ 只有到500，因此直接做複雜度是可行的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">bool</span> maze[N][N],bomb[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,s,t;</span><br><span class="line">    <span class="keyword">bool</span> alive;</span><br><span class="line">&#125;mp[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y;</span><br><span class="line">        cin&gt;&gt;mp[i].s&gt;&gt;mp[i].t;</span><br><span class="line">        mp[i].alive = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> now_alive = k;</span><br><span class="line">    <span class="keyword">while</span>(now_alive)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(bomb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(bomb));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[p].alive == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mp[p].x,j = mp[p].y;</span><br><span class="line">            maze[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[p].alive == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mp[p].x,j = mp[p].y;</span><br><span class="line">            <span class="keyword">int</span> nx = i + mp[p].s;</span><br><span class="line">            <span class="keyword">int</span> ny = j + mp[p].t;</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= n || nx &lt; <span class="number">0</span> || ny &gt;= m ||ny &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                now_alive--;</span><br><span class="line">                mp[p].alive = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maze[nx][ny])&#123;</span><br><span class="line">                now_alive--;</span><br><span class="line">                mp[p].alive = <span class="number">0</span>;</span><br><span class="line">                bomb[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[p].x = nx;</span><br><span class="line">                mp[p].y = ny;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bomb[i][j] == <span class="number">1</span>)</span><br><span class="line">                    maze[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j])ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P3-幸運數字"><a href="#P3-幸運數字" class="headerlink" title="P3 幸運數字"></a>P3 幸運數字</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g277">題目連結</a></p>
<p>以區間最小值作為區分點將數列分成兩半，可以利用線段樹找區間最小值，利用迴圈模擬每一次範圍縮小的情況。</p>
<p>不過這一題比較特別，他的區間範圍一定會越來越小，且區間外的數字也就不需要使用到，因此可以將數列做一次排序，從頭開始找如果遇上區間外的數字則不理他，否則使用它當作區間的分隔點（這一定會是最小值，因為由小到大排序），將區間範圍縮小。</p>
<p>至於挑選左右區間的區間和，則可以透過前綴和 $O(1)$ 算出答案。</p>
<p><strong>時間複雜度：</strong> 如果是一個遞增或遞減的序列，則每一次區間大小只會縮減1，此時複雜度為 $O(n)$，加上最一開始的排序是 $O(n\log n)$，總共為 $O(n\log n)$。</p>
<h3 id="排序作法"><a href="#排序作法" class="headerlink" title="排序作法"></a>排序作法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[N],pref[N];</span><br><span class="line">pii sorted[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;sorted[i<span class="number">-1</span>].x;</span><br><span class="line">        arr[i] = sorted[i<span class="number">-1</span>].x;</span><br><span class="line">        sorted[i<span class="number">-1</span>].y = i;</span><br><span class="line">        pref[i] = pref[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sorted,sorted+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">0</span>,l = <span class="number">1</span>,r = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        <span class="keyword">while</span>(sorted[ind].y &gt; r || sorted[ind].y &lt; l)ind++;</span><br><span class="line">        <span class="keyword">int</span> left = pref[sorted[ind].y<span class="number">-1</span>]-pref[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = pref[r]-pref[sorted[ind].y];</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            r = sorted[ind].y<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = sorted[ind].y+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;arr[l]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="線段樹作法"><a href="#線段樹作法" class="headerlink" title="線段樹作法"></a>線段樹作法</h3><p>如果用線段樹實作，尋找區間最小值，可以在 $O(\log n)$ 的時間內詢問。在最差的情況下，一共會詢問 $n$ 次，因此總時間複雜度一樣是 $O(n\log n)$。實作上也不複雜，建立線段樹以及區間詢問，區間修改和懶標之類的東西。可以比較一下時間：</p>
<p><img src="https://i.imgur.com/JlsbyYf.png" alt=""></p>
<p>線段樹的表現稍微好一點，不過其實是相當接近的！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[N],pref[N];</span><br><span class="line">pii seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立線段樹[l,r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        seg[cur] = &#123;arr[l],l&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span>*cur,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r);</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*cur].x &lt; seg[<span class="number">2</span>*cur+<span class="number">1</span>].x)</span><br><span class="line">        seg[cur] = seg[<span class="number">2</span>*cur];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        seg[cur] = seg[<span class="number">2</span>*cur+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//詢問區間最小值，回傳pair</span></span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l || ql &gt;= r || qr &lt;= l)<span class="keyword">return</span> &#123;INT_MAX,INT_MAX&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)<span class="keyword">return</span> seg[cur];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    pii lft = <span class="built_in">query</span>(<span class="number">2</span>*cur,l,mid,ql,qr);</span><br><span class="line">    pii rgt = <span class="built_in">query</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(lft.x &lt; rgt.x)<span class="keyword">return</span> lft;</span><br><span class="line">    <span class="keyword">return</span> rgt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        pref[i] = pref[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = n+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,l,r).y;</span><br><span class="line">        <span class="keyword">int</span> left = pref[ind<span class="number">-1</span>] - pref[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = pref[r<span class="number">-1</span>] - pref[ind];</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)r = ind;</span><br><span class="line">        <span class="keyword">else</span> l = ind + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;arr[l]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="歐恩作法"><a href="#歐恩作法" class="headerlink" title="歐恩作法"></a>歐恩作法</h3><blockquote>
<p>BY thanksone</p>
</blockquote>
<p>有一種二元樹，我也不知道叫啥，根為全序列最小值，左節點為左邊序列最小值，右節點為右邊序列最小值。</p>
<h4 id="建法"><a href="#建法" class="headerlink" title="建法"></a>建法</h4><p>紀錄每個位置左、右邊離自己最近、比自己小的，爸爸就是兩個之中比較大的那一個。</p>
<p><strong>時間複雜度：</strong> 種樹加跑答案總共 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ff first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">array&lt;<span class="keyword">int</span>, 300004&gt; A, S, L, R;</span><br><span class="line">array&lt;pii, 300004&gt; tree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plant</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L[i]] &gt; A[R[i]]) tree[L[i]].ss = i;</span><br><span class="line">        <span class="keyword">else</span> tree[R[i]].ff = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> A[l];</span><br><span class="line">    <span class="keyword">if</span>(S[m - <span class="number">1</span>] - S[l - <span class="number">1</span>] &gt; S[r] - S[m]) <span class="keyword">return</span> <span class="built_in">solve</span>(l, m - <span class="number">1</span>, tree[m].ff);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(m + <span class="number">1</span>, r, tree[m].ss);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    stack&lt;pii&gt; s;</span><br><span class="line">    pii m = &#123;<span class="number">1e9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    s.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; m.ff) m = &#123;A[i], i&#125;;</span><br><span class="line">        S[i] = A[i] + S[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(A[i] &lt; s.<span class="built_in">top</span>().ff)&#123;</span><br><span class="line">            R[s.<span class="built_in">top</span>().ss] = i;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        L[i] = s.<span class="built_in">top</span>().ss;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;A[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">plant</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(<span class="number">1</span>, n, m.ss);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把範測的笛卡爾樹具象化，大概長這樣：</p>
<blockquote>
<p>8<br>3 9 4 5 1 6 2 8</p>
</blockquote>
<p><img src="https://i.imgur.com/lqvdW31.png" alt=""></p>
<p>大致步驟就是：</p>
<ol>
<li>用<strong>單調隊列</strong>建立函數 $L$ 以及 $R$，表示往左往右看第一個小於自己的數</li>
<li>建立笛卡爾樹（$L[i],R[i]$ 挑大的作為父節點）</li>
<li>從根節點開始走訪，左右節點就會分別是左右區間的最小值</li>
<li>利用前綴和計算區間大小，決定要走左還是右子樹</li>
<li>走訪到區間長度為 $1$ 時即答案！</li>
</ol>
<div class="note success">
            <p>總共有三個不同的作法，使用到排序、線段樹、笛卡兒樹的作法。其中，他們的間複雜度分別是 $O(n\log n)$、$O(n\log n)$、$O(n)$。</p><ol><li>排序作法：AC (0.1s, 9.5MB)</li><li>線段樹作法：AC (84ms, 20.9MB)</li><li>歐恩作法：AC (82ms, 15.6MB)</li></ol><p>在笛卡兒樹的作法中，對每一個數字尋找兩側第一個小於它的數字（這可以用單調隊列完成），之後把每一個數字的父親節點設為找到的兩端數字中較大的那一個。</p><p>此作法的概念是，假設序列中第 $i$ 個數字找到兩側數字分別是 $l_i$ 以及 $r_i$，當他如果是區間最小時，區間必須在 $[l_i+1:r_i-1]$ 之中，否則它就不會是最小值了。</p><p>至於為何是選擇 $max(A[l_i],A[r_i])$ 當做父節點？則是因為如果選擇較小的那一個，在縮小區間範圍後，無法確定另外一個是否在區間外，如果包含區間內，則 $A[i]$ 便不會是最小值，違反了定義。換言之，選擇了較大的那一個當作父節點，按照定義當走到這個父節點時，它是區間的最小值，將它排除之後，$A[i]$ 就會是下一個區間的最小值！</p>
          </div>
<h2 id="P4-美食博覽會"><a href="#P4-美食博覽會" class="headerlink" title="P4 美食博覽會"></a>P4 美食博覽會</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g278">題目連結</a></p>
<p>對於序列中k個連續的區間，每一個區間滿足區間內的元素皆不重複，區間範圍可以重疊（不過重疊部分只會算一次），找出這k個連續區間所能覆蓋到的最大長度。</p>
<p>感覺跟背包問題的概念有點像，n個物品可以對應到k個區間，重量則對應到這裡的序列中的數字。這題用DP解。</p>
<h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><p>定義 $dp[i][j]$ 為 $i$ 個試吃員，看了前 $j$ 個攤位，最多可以吃到幾個攤位。</p>
<h3 id="轉移式"><a href="#轉移式" class="headerlink" title="轉移式"></a>轉移式</h3><p>維護一個函數 $f[i]$ 表示如果試吃員吃了第 $i$ 個攤位的美食，他所能吃到<strong>最左端的攤位的索引值</strong>。也就是說，試吃員可以吃 $f[i]$ 到 $i$ 攤位的美食。</p>
<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j-1],dp[i-1][f[j]-1]+j-f[j]+1)</script><p>轉移式代表了要使用第 $i$ 的攤位作為右端點，或是不要使用（直接用前一個），取兩者的最大值。後面一串加減是計算區間大小</p>
<h3 id="邊界"><a href="#邊界" class="headerlink" title="邊界"></a>邊界</h3><script type="math/tex; mode=display">dp[i][j] = 0,\text{for all 0≤i≤k,0≤j≤n}</script><p>從轉移式可以看到他空間可以用滾動DP優化！</p>
<div class="note success">
            <p><strong>GREEDY的作法？</strong><br>如果每一次都選擇最大的區間，並將這個區間的值都改成0，做7次，得到答案，是正確的做法嗎？</p><p>最大的區間不一定會被完全選到。以下測資：</p><blockquote><p>12 2<br>5 4 3 2 1 3 4 5 6 4 3 2</p></blockquote><p>如果是Greedy會選擇 $2 \,1\, 3\, 4\, 5\, 6$ ，然後從兩邊挑一邊。答案是 $9$。<br>但是用DP做會是 $5\, 4\, 3\, 2\, 1$ 加上 $5\, 6\, 4\, 3\, 2$，答案是 $10$。</p>
          </div>
<p><strong>時間複雜度：</strong> 兩層迴圈總共是 $O(kn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,dp[<span class="number">2</span>][N],lft[N],arr[N];</span><br><span class="line"><span class="keyword">int</span> mp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(lft,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(lft));</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[arr[i]]!=<span class="number">0</span>)&#123;</span><br><span class="line">            lft[i] = mp[arr[i]]+<span class="number">1</span>;</span><br><span class="line">            mp[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lft[i] = <span class="number">1</span>;</span><br><span class="line">            mp[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        lft[i] = <span class="built_in">max</span>(maxn,lft[i]);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn,lft[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="built_in">max</span>(dp[<span class="number">1</span>][j<span class="number">-1</span>],dp[<span class="number">0</span>][lft[j]<span class="number">-1</span>]+j-lft[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 1 2 1 4 1 7 1 3 8</span></span><br><span class="line"><span class="comment">// 1 1 2 2 4 4 7 7 7 8</span></span><br></pre></td></tr></table></figure>
<h3 id="EXTRA-版本"><a href="#EXTRA-版本" class="headerlink" title="EXTRA 版本"></a>EXTRA 版本</h3><blockquote>
<p>BY thanksone</p>
</blockquote>
<p><img src="https://i.imgur.com/srLyvYy.png" alt=""></p>
<p>熟悉的題目，大的感人的k。如果依照上面$O(nk)$的做法肯定TLE。<br>俗話說得好 : “好的DP定義是AC的一半”<br>因此經過一系列通靈，我們得到了一個非常漂亮的定義</p>
<h4 id="定義-1"><a href="#定義-1" class="headerlink" title="定義"></a>定義</h4><p> $dp[i] =$ 必須選第 $i$ 家，$($能吃最多的攤販數量，需要的人數$) (dp[i]$是一個$pair)$</p>
<h4 id="轉移式-1"><a href="#轉移式-1" class="headerlink" title="轉移式"></a>轉移式</h4><p>維護一個函數 $L[i]$ ，其實就是樓上的 $f[i]$，但是我比較想要叫他 $L$</p>
<script type="math/tex; mode=display">dp[i] = max_{j<L[i]}(dp[j]) + i - L[i] + 1</script><p>$max(a, b) = a, if(a.first &gt; b.first\ or\ (a.first == b.first\  and\ a.second &gt; b.second))$</p>
<h4 id="優化"><a href="#優化" class="headerlink" title="優化"></a>優化</h4><p>Aliens優化 : 利用penalty限制人數<br>每當有一個人加入，便扣除 $p$ 個攤販的業績<br>當總人數超過 $k$，表示 $p$ 不夠大，仍然有太多人利大於弊<br>反之，當總人數小於 $k$，表示 $p$ 太大，有太多人弊大於利<br>看出來了嗎? $p$ 可以二分搜喔!</p>
<p><strong>時間複雜度：</strong> 二分搜加每次DP $O(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ff first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">array&lt;<span class="keyword">int</span>, 100004&gt; A<span class="comment">/*num of stands*/</span>, L<span class="comment">/*leftest stand can eat to*/</span>, cnt<span class="comment">/*count of each num*/</span>;</span><br><span class="line">array&lt;pii, 100004&gt; dp;</span><br><span class="line"><span class="function">pii <span class="title">add</span><span class="params">(pii p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    p.ff += v;</span><br><span class="line">    p.ss++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">max</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.ff == b.ff) <span class="keyword">return</span> a.ss &gt; b.ss? a : b;</span><br><span class="line">    <span class="keyword">return</span> a.ff &gt; b.ff ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">DP</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ff = stands visited, ss = people needed</span></span><br><span class="line">    pii ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; L[i]) ans = <span class="built_in">max</span>(ans, dp[l++]);</span><br><span class="line">        dp[i] = <span class="built_in">add</span>(ans, i - L[i] + <span class="number">1</span> + p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; n) ans = <span class="built_in">max</span>(ans, dp[l++]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = -n, r = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(l != r)&#123;</span><br><span class="line">        <span class="comment">//binary search penalty</span></span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DP</span>(mid).ss &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DP</span>(l).ff - l * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">        cnt[A[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(cnt[A[i]] &gt; <span class="number">1</span>) cnt[A[l++]]--;</span><br><span class="line">        L[i] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">BIS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS題解：2021年11月</title>
    <url>/apcs2111/</url>
    <content><![CDATA[<h2 id="P1-修補圍籬"><a href="#P1-修補圍籬" class="headerlink" title="P1 修補圍籬"></a>P1 修補圍籬</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g595">題目連結</a></p>
<h3 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h3><p>如果在兩端就直接取旁邊的高度，否則取跟左右邊高度的最小值。</p>
<span id="more"></span>
<h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>$O(n)$</p>
<h3 id="AC程式碼"><a href="#AC程式碼" class="headerlink" title="AC程式碼"></a>AC程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;A[i];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[<span class="number">0</span>] == <span class="number">0</span>)ans += A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(A[n<span class="number">-1</span>] == <span class="number">0</span>)ans += A[n<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == <span class="number">0</span>)ans += <span class="built_in">min</span>(A[i<span class="number">-1</span>],A[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY peienwu</p>
</blockquote>
<h2 id="P2-動線安排-魔王題"><a href="#P2-動線安排-魔王題" class="headerlink" title="P2 動線安排(魔王題)"></a>P2 動線安排(魔王題)</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g596">題目連結</a></p>
<h3 id="題解-1"><a href="#題解-1" class="headerlink" title="題解"></a>題解</h3><p>把線分成橫的跟直的就可以好好處理交叉了!</p>
<h3 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>$O(h(n + m))$</p>
<h3 id="AC程式碼-1"><a href="#AC程式碼-1" class="headerlink" title="AC程式碼"></a>AC程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">array&lt;array&lt;<span class="keyword">int</span>, 104&gt;, 104&gt; R, C, I;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    I[r][c] = <span class="number">1</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span>(C[r][c] || R[r][c]) cnt--;</span><br><span class="line">    C[r][c] = R[r][c] = <span class="number">0</span>;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//直下情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[i][c]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[i][c] || R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">            R[i][c]++;</span><br><span class="line">            cnt += C[i][c] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//直上情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[i][c]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[i][c] || R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">            R[i][c]++;</span><br><span class="line">            cnt += C[i][c] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//橫右情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c + <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[r][i]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c + <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[r][i] || C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">            C[r][i]++;</span><br><span class="line">            cnt += R[r][i] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//橫左情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[r][i]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[r][i] || C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">            C[r][i]++;</span><br><span class="line">            cnt += R[r][i] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    I[r][c] = <span class="number">0</span>;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)&#123;     <span class="comment">//直下情況</span></span><br><span class="line">        <span class="keyword">if</span>(!R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">        R[i][c]--;</span><br><span class="line">        cnt -= C[i][c] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//直上情況</span></span><br><span class="line">        <span class="keyword">if</span>(!R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">        R[i][c]--;</span><br><span class="line">        cnt -= C[i][c] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c + <span class="number">1</span>; i &lt; m; i++)&#123;     <span class="comment">//橫右情況</span></span><br><span class="line">        <span class="keyword">if</span>(!C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">        C[r][i]--;</span><br><span class="line">        cnt -= R[r][i] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//橫左情況</span></span><br><span class="line">        <span class="keyword">if</span>(!C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">        C[r][i]--;</span><br><span class="line">        cnt -= R[r][i] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, r, c, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">    <span class="keyword">while</span>(h--)&#123;</span><br><span class="line">        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            <span class="built_in">pull</span>(r, c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">add</span>(r, c);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY thanksone</p>
</blockquote>
<h2 id="P3-生產線"><a href="#P3-生產線" class="headerlink" title="P3 生產線"></a>P3 生產線</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g597">題目連結</a></p>
<h3 id="差分作法"><a href="#差分作法" class="headerlink" title="差分作法"></a>差分作法</h3><h4 id="題解-2"><a href="#題解-2" class="headerlink" title="題解"></a>題解</h4><p>用差分的想法加值，再用前綴還原，最後再排序。最後利用Greedy的想法，將每一項最小的工作量乘上最大的時間，總和即為答案。</p>
<div class="note success">
            <p><strong>差分</strong></p><p>差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：</p><script type="math/tex; mode=display">b_i = \begin{cases}a_i-a_{i-1}, &\text{if }i\gt 1 \\a_1, & \text{if } i = 1\end{cases}</script><p>差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：</p><ol><li>定義一個新的陣列 $b_i$ 表示每一項差分</li><li>設 $b[l] =  b[l] + v,b[r+1] = b[r+1] - v$</li><li>將差分的每一項加上前一項（做前綴和 $b[i] = b[i]+b[i-1]$），即為原數列</li></ol><p>第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了$O(1)$了！</p>
          </div>
<h4 id="時間複雜度-2"><a href="#時間複雜度-2" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>差分：$O(m)$ 、排序 $O(n\log n)$</p>
<p>總時間複雜度：$O(n\log n + m)$</p>
<h4 id="AC程式碼-2"><a href="#AC程式碼-2" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,A[N],B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(A));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        A[x] += w;</span><br><span class="line">        A[y+<span class="number">1</span>] -= w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;B[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)A[i] = A[i] + A[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">sort</span>(A+<span class="number">1</span>,A+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(B+<span class="number">1</span>,B+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans += A[i] * B[n-i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY peienwu</p>
</blockquote>
<h3 id="線段樹作法"><a href="#線段樹作法" class="headerlink" title="線段樹作法"></a>線段樹作法</h3><p><img src="https://i.imgur.com/hePctby.png" alt=""></p>
<p>很奇怪，最近兩次的APCS第三題都有人想要砸資結，特別是線段樹，可能有些人特別偏愛線段樹吧！</p>
<h4 id="題解-3"><a href="#題解-3" class="headerlink" title="題解"></a>題解</h4><p>線段樹最原本的應該是區間詢問、單點修改，如果要區間修改的話就會用到<a href="https://peienwu.com/2021/08/05/Segment%20Tree/">懶標</a>，所以實作上相對上比較複雜一點。這一題用線段樹的目的是區間加值，加值完過後的排序以及Greedy跟差分的作法是一樣的，用線段樹真的是多此兩舉（實作較複雜、較耗時）！</p>
<p>當然，這一題比較特別只有最後一起做單點查詢，因此不用懶標，最侯直接計算一路去經過的答案也行！下面的程式碼就是把完全包含區間的節點加值，不用使用到懶標，最後一次查詢。</p>
<h4 id="時間複雜度-3"><a href="#時間複雜度-3" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>區間加值 $O(m\log n)$，n個點的詢問 $O(n\log n)$，排序 $O(n\log n)$</p>
<p>總時間複雜度：$O((n+m)\log n)$</p>
<h4 id="AC程式碼-3"><a href="#AC程式碼-3" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,t,A[N],B[N],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>,sz;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[id].sz = r - l;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(id*<span class="number">2</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l || r &lt;= ql || l &gt;= qr)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        seg[id].val += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(id*<span class="number">2</span>,l,mid,ql,qr,val);</span><br><span class="line">    <span class="built_in">modify</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l)<span class="keyword">return</span>;</span><br><span class="line">    ans += seg[id].val;</span><br><span class="line">    <span class="keyword">if</span>(r - l == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; mid)<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>,l,mid,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid,r,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,i);</span><br><span class="line">        A[i] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;B[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(A+<span class="number">1</span>,A + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(B+<span class="number">1</span>,B + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans += A[i] * B[n-i+<span class="number">1</span>];</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P4-真假子圖"><a href="#P4-真假子圖" class="headerlink" title="P4 真假子圖"></a>P4 真假子圖</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g598">題目連結</a></p>
<h3 id="二分搜尋-DFS作法"><a href="#二分搜尋-DFS作法" class="headerlink" title="二分搜尋+DFS作法"></a>二分搜尋+DFS作法</h3><h4 id="題解-4"><a href="#題解-4" class="headerlink" title="題解"></a>題解</h4><p>一開始看到這題，應該很難通靈出二分搜這個作法（我覺得光把題目看懂就有點難度了）。這題有一個條件要特別注意：</p>
<blockquote>
<p>保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合</p>
<p>這一題每一個觀察員並可看成不是獨立的（假如一個觀察員不產生矛盾，則他回傳的那一些邊都會被沿用），所以題目 $p$ 筆詢問可以聯集一起處理。</p>
</blockquote>
<p>將情報員當成點，合作關係當成邊，那麼合法的圖就會有兩個點集，點集中的點互不相鄰，也就是二分圖。</p>
<p>二分搜第一個使得圖變得不二分的人，把它消失，<strong>最多重複3次</strong>就做完了。</p>
<div class="note info">
            <p><strong>為什麼可以二分搜？</strong><br>二分搜是用來找一串01字串的分界點，並且必須具有單調性才能二分搜。這一題之所以會有單調性是因為，當我查詢觀察員$P_i$的回傳資料是否正確時，會將前面 $1$ 到 $i-1$ 的觀察員回傳的所有邊納入考慮。</p><p>假設有一個觀察員 $P_j(1\le j &lt; i)$ 回傳的資料是錯誤的，這些邊會導致整張圖變成非二分圖，對於 $j$ 後面的所有點來說，都是非二分圖。這樣就有了以 $j$ 為分界點的單調性，即可二分搜。</p>
          </div>
<p>二分圖判斷可以用 DFS 做，DFS 的時候把每個點塗上顏色，如果相鄰的點跟自己顏色一樣就表示這不是一張二分圖。</p>
<h4 id="時間複雜度-4"><a href="#時間複雜度-4" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>$O((n + m + pk)\log p)$</p>
<h4 id="AC程式碼-4"><a href="#AC程式碼-4" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">array&lt;<span class="keyword">bool</span>, 10004&gt; WA;          <span class="comment">//不可行的觀察員編號</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, 20004&gt; vis;          <span class="comment">//DFS是否走訪、二分圖顏色</span></span><br><span class="line">array&lt;vector&lt;e&gt;, 10004&gt; E;      <span class="comment">//每一個觀察員的回傳邊</span></span><br><span class="line">array&lt;vector&lt;<span class="keyword">int</span>&gt;, 20004&gt; G;    <span class="comment">//存進行DFS的圖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;         <span class="comment">//用DFS塗色、判斷二分圖</span></span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="number">1</span>;</span><br><span class="line">    vis[u] = t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] == t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans &amp;= <span class="built_in">dfs</span>(v, <span class="number">3</span> - t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;               <span class="comment">//檢查第p個觀察員回傳是否正確</span></span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [u, v] : E[i])&#123; <span class="comment">//將觀察員的邊推入G</span></span><br><span class="line">            G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">            G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans &amp;= <span class="built_in">dfs</span>(i, <span class="number">1</span>);        <span class="comment">//將每一個連通塊</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;           <span class="comment">//二分搜觀察員</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(r)) <span class="keyword">return</span>;         <span class="comment">//當邊的連集不會讓圖有問題，則回傳</span></span><br><span class="line">    <span class="keyword">while</span>(l != r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    WA[l] = <span class="number">1</span>;</span><br><span class="line">    E[l].<span class="built_in">clear</span>();                <span class="comment">//剔除一錯誤觀察員</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, p, k, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        E[<span class="number">0</span>].<span class="built_in">pb</span>(&#123;a, b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            E[i].<span class="built_in">pb</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;     <span class="comment">//至多三個觀察員</span></span><br><span class="line">        <span class="built_in">BS</span>(<span class="number">0</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(WA[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY thanksone</p>
</blockquote>
<h3 id="DSU作法"><a href="#DSU作法" class="headerlink" title="DSU作法"></a>DSU作法</h3><blockquote>
<p>Idea From Kennyfs</p>
</blockquote>
<h4 id="題解-5"><a href="#題解-5" class="headerlink" title="題解"></a>題解</h4><p>這一題的題目限制有說最多3個錯誤的情報員，因此我們可以用上面二分搜的方式做三次找到答案。如果題目<strong>不限制錯誤調查員的數量</strong>，也就是用二分搜時間會超時，但是用DSU可以在線性時間內完成！</p>
<p>DSU的目的在處理集合問題，根據下面這個關鍵條件：</p>
<blockquote>
<p>保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合</p>
</blockquote>
<p>我們只要對每一筆詢問看會不會與組長手中的pair矛盾即可。如果每一次都做DFS，會發現時間複雜度是 $O(pn)$，必然超時。</p>
<p>DSU的想法是，我們將組長手中的圖中上每一個連通塊都分別塗上兩種顏色（必為二分圖，因此將兩邊各塗上不同顏色）。接著，把每個顏色當作初始的並查集中的集合，將每一筆觀察員回傳的邊的兩端指向的集合合併起來，過程中如果發生邊的兩端同屬一個集合，表示這是一個錯誤的觀察員。做完每一個觀察員之後，把所有變更過的還原成初始狀態（組長手中的圖）即可。</p>
<div class="note success">
            <p><strong>舉例</strong></p><blockquote><p>8 5<br>0 2 1 3 1 2 4 6 5 6<br>1 2<br>1 4 0 6</p></blockquote><p>整個過程就是下面這張GIF：<br><img src="https://i.imgur.com/gLpSD6p.gif" alt=""></p><p>步驟：</p><ol><li>利用DFS為組長手中的圖上色，每一個連通塊兩色（以編號1,2,3…）</li><li>將每一個顏色當作並查集元素</li><li>觀察員輸入的邊兩端 $(u,v)$非同色，表示不發生矛盾，則將u所在集合與v所在集合的對方（連通塊兩色的另一色）合併</li><li>重複 步驟3 共k次，如果發生$(u,v)$為同一色，則觀察員錯誤。</li></ol>
          </div>
<h4 id="時間複雜度-5"><a href="#時間複雜度-5" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>$O(n + pk\alpha)$</p>
<h4 id="AC程式碼-5"><a href="#AC程式碼-5" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,p,k;</span><br><span class="line"><span class="keyword">int</span> color[N],boss[N],num[N];</span><br><span class="line"><span class="keyword">bool</span> WA[M],f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="keyword">return</span> (s%<span class="number">2</span>)?s+<span class="number">1</span>:s<span class="number">-1</span>;&#125; <span class="comment">//other為同一連通塊另外一種顏色</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N],change;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;                            <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(color));</span><br><span class="line">    <span class="built_in">memset</span>(WA,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(WA));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> col)</span></span>&#123;           <span class="comment">//對所有點上色</span></span><br><span class="line">    color[id] = col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[id])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])<span class="built_in">dfs</span>(i,<span class="built_in">other</span>(col));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_boss</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;              <span class="comment">//尋找祖先、及路徑壓縮</span></span><br><span class="line">    <span class="keyword">if</span>(boss[id] == id)<span class="keyword">return</span> id;</span><br><span class="line">    change.<span class="built_in">push_back</span>(id);</span><br><span class="line">    <span class="keyword">return</span> boss[id] = <span class="built_in">find_boss</span>(boss[id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        edge[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        edge[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;           <span class="comment">//對所有點上色</span></span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i,now);now += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=now;i++)&#123;boss[i] = i;num[i] = <span class="number">1</span>;&#125;</span><br><span class="line">    cin&gt;&gt;p&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        change.<span class="built_in">clear</span>();                                  <span class="comment">//儲存待更改的點集f = 0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(f)<span class="keyword">continue</span>;</span><br><span class="line">            x = color[x],y = color[y];                   <span class="comment">//尋找邊兩端點的顏色所處的集合</span></span><br><span class="line">            <span class="keyword">int</span> bx =  <span class="built_in">find_boss</span>(x),by = <span class="built_in">find_boss</span>(y);</span><br><span class="line">            <span class="keyword">int</span> ox = <span class="built_in">find_boss</span>(<span class="built_in">other</span>(y)),oy = <span class="built_in">find_boss</span>(<span class="built_in">other</span>(x));</span><br><span class="line">            <span class="keyword">if</span>(bx == by)&#123;WA[i] = <span class="number">1</span>;f = <span class="number">1</span>;<span class="keyword">continue</span>;&#125;     <span class="comment">//位於同一集合，此觀察員是錯的</span></span><br><span class="line">            <span class="comment">//以下是啟發式合併（小的集合並到大的集合）</span></span><br><span class="line">            <span class="keyword">if</span>(num[bx] &lt; num[ox])&#123;</span><br><span class="line">                boss[bx] = ox;num[ox] += num[bx];</span><br><span class="line">                change.<span class="built_in">push_back</span>(bx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                boss[ox] = bx;num[bx] += num[ox];</span><br><span class="line">                change.<span class="built_in">push_back</span>(ox);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num[by] &lt; num[oy])&#123;</span><br><span class="line">                boss[by] = oy;num[oy] += num[by];</span><br><span class="line">                change.<span class="built_in">push_back</span>(by);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                boss[oy] = by;num[by] += num[oy];</span><br><span class="line">                change.<span class="built_in">push_back</span>(oy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : change)&#123;boss[i] = i;num[i] = <span class="number">1</span>;&#125;   <span class="comment">//觀察員的邊結束，看完後復原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)<span class="keyword">if</span>(WA[i])cout&lt;&lt;i&lt;&lt;endl;        <span class="comment">//輸出最後錯誤觀察員答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY peienwu</p>
</blockquote>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>伯特蘭悖論（Bertrand Paradox）</title>
    <url>/bertrand/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>Bertrand Paradox是Bertrand他在他的一本書中提到關於機率論的悖論，他以「在圓上產生隨機的弦」來說明當沒有嚴謹的定義好產生隨機的「方法」，就有可能產生許多合理但結果卻完全不同的答案。</p>
<p>悖論如下：給定一個平面上的圓，內接一個邊長為 $T$ 的正三角形。接著隨機產生園內的一條弦，想問這條弦的長度大於 $T$ 的機率有多大？<br><span id="more"></span><br>以下三個方法會分別產生出三個不同的結果，影片、圖片部分是用<em>manim</em>以及<em>matplotlib</em>繪製而成的。</p>
<h2 id="產生弦的不同方法"><a href="#產生弦的不同方法" class="headerlink" title="產生弦的不同方法"></a>產生弦的不同方法</h2><h3 id="方法1：隨機端點"><a href="#方法1：隨機端點" class="headerlink" title="方法1：隨機端點"></a>方法1：隨機端點</h3><p>這是最直覺產生弦的方法，隨機選擇圓上的兩個點連成一條弦。如下圖，不失一般性假設其中一個點是$A$，則另外一個點可能落在$A1,A2,A3$的弦上。若要產生大於三角形邊長的弦，則必須落在$A3$上，其機率為$\frac{1}{3}$。</p>
<p><img src="https://i.imgur.com/VY5lu3v.png" alt=""></p>
<p>以下影片為模擬隨機產生弦的狀況，弦長度大於 $T$ 機率約為$0.33$左右。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/dJB3xVKWavI" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<p>將產生的弦描繪出來如下圖：<br><img src="https://i.imgur.com/gbpWKKe.png" alt="drawing" width="300"/></p>
<h3 id="方法2：隨機半徑"><a href="#方法2：隨機半徑" class="headerlink" title="方法2：隨機半徑"></a>方法2：隨機半徑</h3><p>此作法是隨機產生一條半徑，假設其與圓周交於$A$，接著隨機在半徑上找一點，做出過此點且與半徑垂直的弦。我們可以發現，當點的位置下圖綠色線段上時，弦的長度大於 $T$，在黃色線段時則小於 $T$。<br><img src="https://i.imgur.com/RZ97qY7.png" alt=""></p>
<p>黃色與綠色線段長度相等，因此產生大於 $T$ 的弦長機率為$\frac{1}{2}$，約莫$0.5$左右。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/sH-0lX4h1lw" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<p>將產生的弦描繪出來如下圖：</p>
<p><img src="https://i.imgur.com/UGawzWw.png" alt="drawing" width="300"/></p>
<h3 id="方法3：隨機中點"><a href="#方法3：隨機中點" class="headerlink" title="方法3：隨機中點"></a>方法3：隨機中點</h3><p>此作法是在園中隨機產生一個點，以此點為中點產生一條弦。以下圖來說，假設此點在小圓內，則弦長會大於 $T$，在小圓外則小於 $T$，若恰好落在小圓圓週上，則弦長等於 $T$。</p>
<p>由於小圓的半徑是大圓半徑的一半（可以假設大圓半徑$R$，$T = \sqrt3R$，小圓圓心落在三角形重心上證明），小圓大圓面積比為$1:4$，因此長度大於 $T$ 的弦機率為$\frac{1}{4}$。</p>
<p><img src="https://i.imgur.com/fLgOuOC.png" alt=""></p>
<p>透過模擬得到機率約為$0.25$左右，當樣本數越高，機率會越精準。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/oF2DIPIAFcU" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<p>將產生的弦描繪出來如下圖，跟前面兩個比起來，通過圓中心附近的弦數量較少：</p>
<p><img src="https://i.imgur.com/kOaKQCL.png" alt="drawing" width="300"/></p>
<h2 id="三者比較"><a href="#三者比較" class="headerlink" title="三者比較"></a>三者比較</h2><p>利用<em>matplotlib</em>畫出每條弦的中點並留下軌跡，可以得到下面的圖形，隨機端點與隨機半徑產生的圖形比較相近，集中在圓的中心，而隨機中點的分佈則十分平均。</p>
<h3 id="方法1：隨機端點-1"><a href="#方法1：隨機端點-1" class="headerlink" title="方法1：隨機端點"></a>方法1：隨機端點</h3><p><img src="https://i.imgur.com/C1zPHS4.png" alt=""></p>
<h3 id="方法2：隨機半徑-1"><a href="#方法2：隨機半徑-1" class="headerlink" title="方法2：隨機半徑"></a>方法2：隨機半徑</h3><p><img src="https://i.imgur.com/riz3ZQn.png" alt=""></p>
<h3 id="方法3：隨機中點-1"><a href="#方法3：隨機中點-1" class="headerlink" title="方法3：隨機中點"></a>方法3：隨機中點</h3><p><img src="https://i.imgur.com/5M2cLna.png" alt=""></p>
<p>在沒有給定額外資訊的情況下，並沒有哪一種方法才是所謂正確解答，不存在唯一的選擇方法，那麼也就不存在一個唯一的解答。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>此篇文章的目的在熟悉<em>manim</em>製作動畫以及<em>matplotlib</em>的操作，內容皆為已知喔。</p>
<p><a href="https://github.com/peienwu/cp_code/tree/main/Bertrand%20Paradox">Github: Code and Photos</a></p>
<p><a href="https://youtu.be/mZBwsm6B280">Bertrand’s Paradox (with 3blue1brown) - Numberphile</a></p>
<p><a href="https://en.wikipedia.org/wiki/Bertrand_paradox_(probability">Wiki: Bertrand paradox</a>)</p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>機率</tag>
      </tags>
  </entry>
  <entry>
    <title>生日問題（Birthday Paradox）</title>
    <url>/birthday/</url>
    <content><![CDATA[<p>有同學問我生日問題的機率感覺蠻好玩的，決定好好研究一番。生日悖論其實不是一個悖論，只是有點違背直覺而已，並非數學中定義的悖論！這一篇會用蒙地卡羅模擬來進行與理論的比較</p>
<h2 id="問題敘述"><a href="#問題敘述" class="headerlink" title="問題敘述"></a>問題敘述</h2><p>題目：一個房間要多少人，則兩個人的生日相同的機率要大於50%？</p>
<p>答案是<font color="#f00">23</font>人。<br><span id="more"></span><br>如果想要看1到100人有同一天的機率可以<a href="https://gist.github.com/peienwu/bd6edf34416f352ba97b94c67d5acb52">點這裡！</a></p>
<h2 id="機率與人數的關係"><a href="#機率與人數的關係" class="headerlink" title="機率與人數的關係"></a>機率與人數的關係</h2><h3 id="兩種理解方式"><a href="#兩種理解方式" class="headerlink" title="兩種理解方式"></a>兩種理解方式</h3><p>對於生日問題可能會有兩種理解方式：</p>
<ol>
<li>題意：<font color="#f00">「23人之中兩兩之間存在生日相同」</font><br> 對於原本題目要闡述的意義可以列出以下數學式：<script type="math/tex; mode=display">\begin{split}p(n)&=1-p'(n) \\&= 1-(1\times\frac{364}{365}\times\frac{363}{365}\times\cdots\frac{365-(n-1)}{365})\end{split}</script></li>
<li>錯誤理解：<font color="#f00">「其他22人與你的生日相同的機率」</font><br> 這樣的理解會造成算出來的機率大為減少（用全部扣掉皆不相同）：<script type="math/tex; mode=display">q(n) = 1-(\frac{364}{365})^n</script></li>
</ol>
<p>有了以上兩個關係式，就可以進行圖表的繪製。x軸表示人數，y軸表示機率，可以看出來兩種理解方式會造成機率有很大的差別！<br><img src="https://i.imgur.com/NcIRKE7.png" alt=""></p>
<p>上圖繪製程式碼：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Possibility to Number of people&quot;</span>, fontsize=<span class="number">20</span>) <span class="comment">#圖表標題</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of people&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#x軸標題</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Possibility&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#y軸標題</span></span><br><span class="line"></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line">p = <span class="number">1</span></span><br><span class="line">x = []</span><br><span class="line">y1 = []</span><br><span class="line">y2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">365</span>):</span><br><span class="line">    y1.append(<span class="number">1</span>-p)</span><br><span class="line">    p = p*d</span><br><span class="line">    d = d-(<span class="number">1</span>/<span class="number">365</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">365</span>,<span class="number">400</span>):</span><br><span class="line">    y1.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">d2 = <span class="number">364</span>/<span class="number">365</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">400</span>):</span><br><span class="line">    x.append(i)</span><br><span class="line">    y2.append(<span class="number">1</span>-d2)</span><br><span class="line">    d2 = d2*(<span class="number">364</span>/<span class="number">365</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x,y1,<span class="string">&#x27;red&#x27;</span>,label=<span class="string">&#x27;p(n)&#x27;</span>)</span><br><span class="line">plt.plot(x,y2,<span class="string">&#x27;blue&#x27;</span>,label=<span class="string">&#x27;q(n)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show() <span class="comment">#顯示繪製的圖形</span></span><br></pre></td></tr></table></figure>
<p>這張圖表還可以告訴我們，任兩個人生日相同的機率很高，但相對的，即使有400個人，要有人跟你的生日相同的機率比6成高一點而已，告訴我們「全部的日期至少有一人生日」的機率其實不高！</p>
<h3 id="其他人與你的生日相同的機率"><a href="#其他人與你的生日相同的機率" class="headerlink" title="其他人與你的生日相同的機率"></a>其他人與你的生日相同的機率</h3><p>如果在看更仔細一點，對於「其他人與你的生日相同的機率」作圖會呈現下方的圖形<br><img src="https://i.imgur.com/DHu0F0g.png" alt=""></p>
<p>因為生日是隨機的，因此在很大量數據測試下，我們可以期望共有365人的時候會出現第一個與自己生日相同日期的人！實際以亂數模擬，所得到的期望值次數與理論是相符的！<br><img src="https://i.imgur.com/UdjoCdI.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> birthday[<span class="number">400</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,t = <span class="number">5000000</span>,times = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(birthday,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(birthday));</span><br><span class="line">        <span class="keyword">int</span> target = <span class="built_in">rand</span>()%<span class="number">365</span>,ind=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            ind = <span class="built_in">rand</span>()%<span class="number">365</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==ind)&#123;</span><br><span class="line">                sum+=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> birthday[ind] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;平均於第：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)sum/t&lt;&lt;<span class="string">&quot;次&quot;</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot;會出現第一個與自己生日相同的人&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="至少k個人生日相同機率"><a href="#至少k個人生日相同機率" class="headerlink" title="至少k個人生日相同機率"></a>至少k個人生日相同機率</h2><p>對於至少k人生日相同的機率要大於50%，需要的人數如下表：<br><img src="https://i.imgur.com/Nwpe6aH.jpg" alt=""><br>用程式驗證看看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">k</th>
<th style="text-align:left">共N人</th>
<th style="text-align:left">機率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">23</td>
<td style="text-align:left">0.506949</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">88</td>
<td style="text-align:left">0.511169</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">187</td>
<td style="text-align:left">0.502883</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">313</td>
<td style="text-align:left">0.501057</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">460</td>
<td style="text-align:left">0.502686</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">623</td>
<td style="text-align:left">0.503298</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">798</td>
<td style="text-align:left">0.500304</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">985</td>
<td style="text-align:left">0.501191</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">1181</td>
<td style="text-align:left">0.500178</td>
</tr>
</tbody>
</table>
</div>
<p>根據<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.8298&amp;rep=rep1&amp;type=pdf">這一篇</a>提供的公式，在$k≤20$的情況下$n\cong47(k-1.5)^{\frac{3}{2}}$，這是這篇作者把k還是很小的時候進行近似，但實際的公式我還不是很了解:cry:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> birthday[<span class="number">400</span>],power[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,t = <span class="number">10000000</span>,times = t;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">23</span>,<span class="number">88</span>,<span class="number">187</span>,<span class="number">313</span>,<span class="number">460</span>,<span class="number">623</span>,<span class="number">798</span>,<span class="number">985</span>,<span class="number">1181</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">        times = t;sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(birthday,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(birthday));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[j];i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> ind = <span class="built_in">rand</span>()%<span class="number">365</span>;</span><br><span class="line">                birthday[ind]+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(birthday[ind]&gt;=j+<span class="number">2</span>)&#123;</span><br><span class="line">                    sum+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">7</span>);</span><br><span class="line">        cout&lt;&lt;(<span class="keyword">double</span>)sum/t&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="機率證明"><a href="#機率證明" class="headerlink" title="機率證明"></a>機率證明</h2><h3 id="公式推討"><a href="#公式推討" class="headerlink" title="公式推討"></a>公式推討</h3><p>生日問題可以理解成：<font color="#f00">至少兩人生日相同的機率</font> 這個問題，而否定這個問題即為：「沒有人生日相同的機率」。因為這兩個事件的聯集即為樣本空間，可以用扣的方式得到答案！</p>
<p>對於房間裡有n人的情況，定義 $p(n)$ 為「至少兩人生日相同的機率」、$p’(n)$ 為「沒有人生日相同的機率」，在不考慮特殊強況（閏年等），並假設生日會平均分佈的狀況下：</p>
<script type="math/tex; mode=display">\begin{split}p(n)&=1-p'(n) \\&= 1-(1\times\frac{364}{365}\times\frac{363}{365}\times\cdots\frac{365-(n-1)}{365})\\\\&=1-\frac{365!}{365^n\cdot(365-n)!}\end{split}</script><p>簡單解釋一下，對於每一個加入房間的人都有$365$種可能，因此分母皆為$365$；對於第 $i$ 個加入的人要避開前 $i-1$ 個人的生日，因此分子為$365-(i-1)$。經過整理可以得到這個有階乘又有次方的很難看的一個公式！</p>
<p>這時候我們可以引入泰勒公式：</p>
<script type="math/tex; mode=display">\begin{split}e^x&=\sum_{k=0}^\infty\frac{x^k}{k!}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}\cdots\end{split}</script><p>為什麼要引入這個公式？是因為我們想要構造出上面機率計算中的每一項 $1-\frac{x}{365}$ ，因為泰勒公式是一個無窮級數，我們可以適度的做一些取捨，例如只取第一項與第二項（在下去都是小數點4,5位以上了)，得到以下：</p>
<script type="math/tex; mode=display">e^x\cong1+x\to e^{-\frac{x}{365}}\cong1-\frac{x}{365}</script><p>接著就可以把每一項替換成多項式的型態：</p>
<script type="math/tex; mode=display">\begin{split}p'(n)&=1\times\frac{364}{365}\times\frac{363}{365}\times\cdots\frac{365-n+1}{365}\\&\cong1\times e^{-\frac{1}{365}}\times e^{-\frac{2}{365}}\times\cdots\times e^{-\frac{n-1}{365}}\\&=e^{-\frac{1+2+\cdots+(n-1)}{365}}\\&=e^{-\frac{n(n-1)/2}{365}}\\&=e^{-\frac{n^2-n}{730}}\end{split}</script><p>接著就可以算出正確的機率了！</p>
<script type="math/tex; mode=display">\begin{split}p(n) &= 1-p'(n)\\&\cong1-e^{-\frac{n^2-n}{730}}\end{split}</script><h3 id="實際機率"><a href="#實際機率" class="headerlink" title="實際機率"></a>實際機率</h3><p>我利用程式實際運算求出機率，並跟公式解做比較如下：<br><img src="https://i.imgur.com/NEJMnOa.png" alt=""><br>發現到誤差會隨著人數增加而有變大的趨勢，不過都是在小數點後三位的事情，誤差不到1%，所以公式解其實是可以用的！其實可以觀察到一個現象，對於$p’(n)$的理論解都會比實際值高，因為多加了幾項被我們省略掉的數字，因此計算出來的公式解會比實際機率低一些！</p>
<h2 id="生日攻擊"><a href="#生日攻擊" class="headerlink" title="生日攻擊"></a>生日攻擊</h2><p>生日攻擊就是利用生日問題的特性在 $\sqrt{H}$ 的時間暴力破解找出碰撞。<a href="https://www.thenewslens.com/article/62378">Google破解SHA1實現碰撞攻擊</a>，如果有人可以讓兩個不同的檔案得出相同雜湊值，讓攻擊者可能偷偷把惡意的程式碼放進檔案，但得出來的雜湊值跟原本的檔案一樣，使人在沒有防備的情況下誤以為危險檔案安全，這可以達到生日攻擊（也就是找到碰撞）</p>
<h3 id="雜湊演算法"><a href="#雜湊演算法" class="headerlink" title="雜湊演算法"></a>雜湊演算法</h3><p>最近有學雜湊相關東西，那剛好生日問題其實跟雜湊很有關係，因為生日可以被當作雜雜湊空間大小，空間越大雖然消耗記憶體較大但發生碰撞的機會會越小。換作是雜湊演算法中，我們想要討論的就是開的空間大小與發生碰撞的嘗試次數的關係。</p>
<p>首先計算生日問題人數的期望值，也就是在加入第幾個人之後，會發生有兩人生日同一天的情況，以下為模擬的情形：<br><img src="https://i.imgur.com/m6Wiwdh.png" alt=""><br>透過公式的計算，可以得到不同人數對應到的機率，假設共i人的情況下機率為f(i)，則f(i)-f(i-1)為加入第i人時恰好有人生日相同的機率，就可以根據期望值的公式算出期望在共有幾人時發生碰撞。以下是計算結果：<br><img src="https://i.imgur.com/mnyAbWk.png" alt=""><br>兩者的誤差極小，可以推論出在平均約在加入第24.617個人的時候會發生碰撞！</p>
<p>我們已經計算出對於n人的情況下任兩人生日相同的機率，這時候可以推廣到不只是365天，也就代表在雜湊空間大小為d的時候發生碰撞的機率如下：</p>
<script type="math/tex; mode=display">\begin{split}p(n) &= 1-p'(n)\\p(n,d)&\cong1-e^{-\frac{n^2-n}{2d}}\end{split}</script><p>因此我寫了一個實際模擬的程式跟這個公式模擬的結果做比較，根據空間大小分別為365與1000做討論，結果如下：<br><img src="https://i.imgur.com/3nuhPHI.png" alt=""><br><img src="https://i.imgur.com/fKVI4QB.png" alt=""></p>
<p>由模擬的結果可以看出，若一年有1000天（假設而已！）則在38個人的團體中任兩人生日同天的機率已經超過50%，跟直覺相差挺大的！</p>
<h3 id="給定機率預測最多數量"><a href="#給定機率預測最多數量" class="headerlink" title="給定機率預測最多數量"></a>給定機率預測最多數量</h3><p>在上面的做法是人數計算機率，可以換一個方式，給定碰撞機率求最多的人數為多少。可以從上面的公式來推，以下n,H分別代表數量與空間大小：</p>
<script type="math/tex; mode=display">\begin{split}p(n,H)&\cong1-e^{-\frac{n^2-n}{2H}}\cong1-e^{-\frac{n^2}{2H}}\\&\to e^{-\frac{n^2}{2H}}=1-p\\&\to e^{\frac{n^2}{2H}}\frac{1}{1-p}\\&\to\frac{n^2}{2H}=\ln\frac{1}{1-p}\\&\to n(p,H)\cong \sqrt{2H\ln\frac{1}{1-p}}\end{split}</script><p>因為我們把$n^2-n$當成$n^2$，所以在小範圍估計的時候會有比較大的誤差，不過當n很大的時候，量級就會是$n^2$，因此可以忽略一次方的$n$</p>
<h3 id="首次碰撞的期望值次數"><a href="#首次碰撞的期望值次數" class="headerlink" title="首次碰撞的期望值次數"></a>首次碰撞的期望值次數</h3><p>在上面有做一次期望值的估計，不過過程蠻麻煩的，要先算出每一個數量機率的差，再乘上數量並加總。這邊有一個公式是提供在範圍很大時的一個估計公式：</p>
<script type="math/tex; mode=display">Q(H)\cong\sqrt{\frac{\pi}{2}H}</script><p>這導出一個重要的結論：對於n位密碼共有$2^n$種可能組合，確僅僅需要期望$2^{\frac{n}{2}}$次嘗試就可以遇到碰撞！以下嘗試H=800000筆與H=1500000筆數據，會有一點誤差，可能的原因是測試的樣本數不夠(100萬次)</p>
<p><img src="https://i.imgur.com/z5Z0cvr.png" alt=""><br><img src="https://i.imgur.com/Xh0yowN.png" alt=""></p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><p>實作的概念就是開一個$O(n)$的陣列紀錄，如果遇到之前出現過的就記錄下來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> hash_map[<span class="number">2000006</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> N,M;cin&gt;&gt;N&gt;&gt;M; <span class="comment">//N筆輸入,空間大小M</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> times = t,sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(hash_map,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(hash_map));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">rand</span>()%M;</span><br><span class="line">            <span class="keyword">if</span>(hash_map[temp]==<span class="number">0</span>)hash_map[temp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;對於輸入筆數共有：&quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot;、空間大小為：&quot;</span>&lt;&lt;M&lt;&lt;endl&lt;&lt;<span class="string">&quot;第一次發生碰撞次數平均值為：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)sum/t&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;理論預測次數：&quot;</span>&lt;&lt;<span class="built_in">sqrt</span>(M_PI_2*M)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;理論預測：&quot;&lt;&lt;1-exp(-(N*(N-1)/(double)(2*M)))&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cheryl’s-birthday"><a href="#Cheryl’s-birthday" class="headerlink" title="Cheryl’s birthday"></a>Cheryl’s birthday</h2><p>這一題跟生日問題沒啥關係，但既然都提到「生日」，就來看一題有趣的</p>
<blockquote>
<p>艾伯特和柏納剛認識雪莉兒，想要知道雪莉兒的生日，雪莉兒列出了十個可能的日期：<br>5月15日、5月16日、5月19日、6月17日<br>6月18日、7月14日、7月16日、8月14日<br>8月15日、8月17日<br>接著雪莉兒分別告訴艾伯特及柏納她生日的月及日，以下是艾伯特和柏納的回應</p>
<p>艾伯特：我不知道雪莉兒的生日是哪一天，但我知道柏納也不知道<br>柏納：一開始我不知道雪莉兒的生日，但現在我知道了<br>艾伯特：那我也知道雪莉兒的生日了<br>請問雪莉兒的生日是那一天？</p>
<p>[註：艾伯特的第一句話他確定柏納100%不知道生日是哪一天]</p>
</blockquote>
<p>解答點此：<br><img src="https://i.imgur.com/FxwNYkb.png&gt; =400x" alt=""></p>
<ol>
<li><p>第一句話中，柏納若要知道明確的生日日期，唯一的可能是生日日期的日在十個可能日期中只出現過一次，也就是18日和19日。但艾伯特說<font color="#f00">他知道柏納也不知道生日是哪一天</font>，因此可以可以排除5月和6月的所有日期（如果是5月或6月有一定的機會艾伯特無法確定柏納不知道是哪一天）</p>
</li>
<li><p>根據第一句話柏納可以推測月份是7月或8月，而他已經知道生日是哪一天，表示他知道的日是在7月或8月中只出現過一次的日，因此可以排除7月及8月可能生日中都有出現的14日，柏納知道的日可能是15日、16日或17日。</p>
</li>
<li><p>目前還有可能的生日是7月16日、8月15日及8月17日，而艾伯特在聽完第二句話就可以知道生日是哪一天，表示他知道的月份在7月16日、8月15日及8月17日中只出現一次。因此他知道的月份是7月，生日是7月16日。</p>
</li>
</ol>
<font color="#f00">答案是7月16日。</font>

<p>這一題跟生日問題其實沒什麼關係，就當作是一個「生日」有關的有趣邏輯推理的題目吧！</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>整理以上提到的公式吧</p>
<h3 id="已知人數推算機率"><a href="#已知人數推算機率" class="headerlink" title="已知人數推算機率"></a>已知人數推算機率</h3><script type="math/tex; mode=display">\begin{split}p(n)&=1-\frac{365!}{365^n\cdot(365-n)!}\end{split}</script><script type="math/tex; mode=display">\begin{split}p(n) \cong1-e^{-\frac{n^2-n}{730}}\end{split}</script><h3 id="已知機率預測數量（也就是人數）"><a href="#已知機率預測數量（也就是人數）" class="headerlink" title="已知機率預測數量（也就是人數）"></a>已知機率預測數量（也就是人數）</h3><script type="math/tex; mode=display">\begin{split}n(p,H)\cong \sqrt{2H\ln\frac{1}{1-p}}\end{split}</script><h3 id="首次碰撞的期望值"><a href="#首次碰撞的期望值" class="headerlink" title="首次碰撞的期望值"></a>首次碰撞的期望值</h3><script type="math/tex; mode=display">Q(H)\cong\sqrt{\frac{\pi}{2}H}</script><p>沒想到生日問題可以衍伸出如此多、如此繁雜的數學公式，不僅僅是數學領域，在資安上面也扮演了一個非常重要的角色，也就是雜湊空間為H的時，根據公式我們可以期望在$\sqrt{H}$的嘗試內找到碰撞，也就是所謂的Birthday Attack！</p>
<h2 id="附錄"><a href="#附錄" class="headerlink" title="附錄"></a>附錄</h2><p>一些數學證明：</p>
<p><img src="https://i.imgur.com/eKXfAI7.jpg&gt; =400x" alt=""></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://iter01.com/603052.html">密碼學系列之：生日攻擊</a><br><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C">維基百科：生日問題</a><br><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.8298&amp;rep=rep1&amp;type=pdf">Diaconis and Mosteller 1989 - methods for studying coincidences</a></p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>機率</tag>
        <tag>2021暑期筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭配GitHub架設個人部落格</title>
    <url>/blog/</url>
    <content><![CDATA[<p>本網頁就是利用github page架設的部落格，使用Hexo搭配Next主題。<br>暑假常常寫題，都幾乎紀錄在Hackmd上，如果能有屬於自己的部落格、用自己的網址，感覺超酷！來自己架設一個試試看！</p>
<h2 id="網域種類"><a href="#網域種類" class="headerlink" title="網域種類"></a>網域種類</h2><p>架設網站有好多種方法，有時候是看題解看到了很多的網站XD，上網查了資料以及很多人的部落格，發現寫coding部落格的人的網站大多分成以下四類：</p>
<ol>
<li><a href="https://www.blogger.com/">Blogger</a></li>
<li><a href="https://hexo.io/">Hexo</a></li>
<li><a href="https://pages.github.com/">GitHub Pages</a></li>
<li><a href="https://wordpress.org/">WordPress.org</a></li>
</ol>
<span id="more"></span>
<p>每一種部落格都有優勢與劣勢，就看使用者覺得哪一個平台使用起來比較方便！在經過多方嘗試之下，最後我是選擇了使用 Hexo 搭配 Github 來架設我的網站，以下來分析一下我個人在架設的過程中，以一個新手的角度看各個平台使用上的優缺點！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>網站比較</th>
<th>優點</th>
<th>缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Blogger</strong></td>
<td>1. 介面清楚，操作方便<br>2. 一鍵預覽及發布，快速查看文章成果<br>3. 免費！</td>
<td>1. 不支援MarkDown語法<br>2. 對數學式、程式碼支援不便利</td>
</tr>
<tr>
<td><strong>Hexo</strong></td>
<td>1. 支援MarkDown語法<br>2. Mac終端機操作方便<br>3. 免費！</td>
<td>1. 純程式碼呈現，較不直覺<br>2. 修改過程中如果程式碼出錯，造成整個網站掛掉</td>
</tr>
<tr>
<td><strong>GitHub Pages</strong></td>
<td>1. 支援MarkDown語法<br>2. 進行版本控制<br>3. 免費！</td>
<td>1. 單純使用的話操作、修改不方便<br>2. Git操作有一定難度</td>
</tr>
<tr>
<td><strong>WordPress com</strong></td>
<td>1. 跟Blogger相近，操作簡單易上手<br>2. 快速查看文章長相</td>
<td>1. 不支援Markdown<br>2. 免費版限制多、模板不漂亮</td>
</tr>
<tr>
<td><strong>WordPress org</strong></td>
<td>太貴不考慮</td>
<td>上網查必須要先付費才能開始架設<br>費用好像一年3000以上</td>
</tr>
</tbody>
</table>
</div>
<p>經過多方嘗試（花了我好多天），出產了一堆失敗品，最後還是用 Hexo 搭配 GitHub 來架設一個算滿意的網站（至少看起來不錯XD）。以下是我的失敗品網站：</p>
<ol>
<li><a href="https://peienwu1216.blogspot.com/?zx=60407725c2514b18">Blogger</a></li>
<li><a href="https://peienwu.wordpress.com/">WorldPress</a></li>
<li>Github的我已經刪掉了</li>
</ol>
<h2 id="Hexo-安裝"><a href="#Hexo-安裝" class="headerlink" title="Hexo 安裝"></a>Hexo 安裝</h2><p>之前遇上很多軟體對Mac都不友善，不過Hexo卻是對Mac的用戶比較友善的工具。只要在終端機輸入以下命令就可以安裝Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>詳細的安裝步驟可以參考<a href="https://hexo.io/docs/">官方網站</a>，或是網路上的<a href="https://youtu.be/jOJI9ekTzK8">教學影片</a>就可以一步一步的把網站建立起來！</p>
<p>在這過程中，我發現影片上有使用到VS Code，於是我就把它也載下來了。用起來感覺VS Code 對專案製作很有幫助，可以同步的在各個檔案之間進行修改，蠻實用的一個IDE！<br><img src="https://i.imgur.com/eIiT0Pb.png" alt=""></p>
<h2 id="GitHub同步"><a href="#GitHub同步" class="headerlink" title="GitHub同步"></a>GitHub同步</h2><p>將 Hexo 裡面的檔案推送到 Git Hub 裡面的一個Repository中，利用它來將網頁的內容進行發布。在每一次本地修改完成之後，如果本地測試可行，就可以將檔案推送到Github中，在Github將網站進行發布。我使用來架設部落格的<a href="https://github.com/peienwu/peienwu.github.io">Repository在此</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .                //加入</span><br><span class="line">git commit -m &quot;xxx&quot;      //提交</span><br><span class="line">git push                 //推入</span><br><span class="line">git push -f              //強制推入（聽說很危險）</span><br></pre></td></tr></table></figure>
<p>在提交的後面的字串表示當前版本的一個提示，例如我做了什麼修改就可以顯示在上面，讓別人知道這份檔案被更改的情況。下圖就是在每一次推入時附加的修改資訊，讓我自己可以看到檔案被更改以及提交的狀況!</p>
<p><img src="https://i.imgur.com/kBpX3gp.png" alt=""></p>
<p>Git真是博大精深，版本控制真的有難度，我只會簡單的修改以及推入（之後找時間可以學一下）。</p>
<h2 id="外掛安裝"><a href="#外掛安裝" class="headerlink" title="外掛安裝"></a>外掛安裝</h2><p>做到這一個步驟已經花了我快三小時，出現的是類似以下的畫面：</p>
<p><img src="https://i.imgur.com/a1zD8Qz.png" alt=""></p>
<p>這是 Hexo 預設的樣板，感覺還不錯，不過我的目標是使用另外外掛的模板，看起來比較漂亮XD。於是我就找了<a href="https://github.com/theme-next/hexo-theme-next">Next主題</a>的外掛來安裝，這個模板就感覺舒服很多。這個模板使用的大陸部落格很多，也有一些其他的競程部落格使用了這個主題！</p>
<p><img src="https://i.imgur.com/aP8mwrQ.png" alt=""></p>
<h3 id="Hexo-NexT-美化"><a href="#Hexo-NexT-美化" class="headerlink" title="Hexo NexT 美化"></a>Hexo NexT 美化</h3><p>上網查關鍵字其實有很多美化的資訊可以參考，不論是字體或版面配置都有很多種選項可以選擇。最一開始是設計版面的部分，將網站總共分五個子類別，分別是首頁、檔案、類別、標籤以及關於，這五個經典的配置。接下來就是個人資訊的設定，加入自己的圖片以及說明：<br><img src="https://i.imgur.com/TXykwfE.png" alt=""></p>
<p>以及在網頁瀏覽標籤上方設定icon：<br><img src="https://i.imgur.com/Y2lE6Qp.png" alt=""></p>
<p>當然最重要的就是文章內容，因為是使用Markdown語法，剛好有幾篇筆記就丟上去看看。當然還有很多的優化以及美化，如果有什麼需要改進的地方要跟我說喔！</p>
<h3 id="Disqus-留言板功能"><a href="#Disqus-留言板功能" class="headerlink" title="Disqus 留言板功能"></a>Disqus 留言板功能</h3><p>在每一篇文章下方加入留言板功能，感覺還蠻酷的！</p>
<p><img src="https://i.imgur.com/DAUAz3R.png" alt=""></p>
<h3 id="Google-Analytics-追蹤分析"><a href="#Google-Analytics-追蹤分析" class="headerlink" title="Google Analytics 追蹤分析"></a>Google Analytics 追蹤分析</h3><p>這是酷東西，使用google 帳號生成一組代碼之後，把一些它提供的程式碼埋到網站中，它可以即時的統計網站的瀏覽狀況，以及觸及、感興趣的主題等等。<strong>假設</strong>未來瀏覽的人次比較多的時候（可能根本沒人會看XDD），還可以用它來分析哪一種文章最受人歡迎、哪一種文章最冷門之類的！</p>
<p><img src="https://i.imgur.com/3lPv0uW.png" alt=""></p>
<h3 id="購買個人網址"><a href="#購買個人網址" class="headerlink" title="購買個人網址"></a>購買個人網址</h3><p>昨天終於買到了自己名字的網址了！新的網址名稱是：peienwu.com！在<strong>Godaddy</strong> 上用NT570元買了一年這個網址的使用權限，買完之後到<strong>CloudFlare</strong>設定好Dns之類的，讓這個網址可以指向一個IP位址（這其中的原理有點複雜）。</p>
<p>設定完之後，發現他一直出現錯誤訊息，點開網址也是不可使用的，差點昏倒ww。晚上處理不了了，隔天一早起床就開始著手處理中這個問題，把檔案刪刪改改，終於成功讓GitHub跳出以下訊息：</p>
<p><img src="https://i.imgur.com/Zoe8Aes.png" alt=""></p>
<p>很討厭的，他沒有https，也就是鎖頭，在這種情況下，瀏覽器就會自動設置為<font color="#f00">不安全</font>的網站，接下來早上的時間都拿去處理這個問題。在設定一些SSH以及https的安全性設定之後，終於，在訪問網站時拿到了鎖頭的認證！</p>
<p><img src="https://i.imgur.com/jguOHwH.png" alt=""></p>
<h3 id="留言板更新"><a href="#留言板更新" class="headerlink" title="留言板更新"></a>留言板更新</h3><p>最近重新登入後發現文章底部都是一堆Disqus的廣告，真的有夠討厭，如果要消除廣告的方法只剩下付費，好討厭！於是我決定換一個評論系統，叫做<a href="https://valine.js.org/">Valine</a> 的系統，他的優點是支援Emoji 😉、MarkDown 全语法支持，而且<strong>沒有廣告</strong>！大概的留言就像以下這樣：<br><img src="https://i.imgur.com/xgmM0EX.png" alt=""></p>
<p>支援Markdown的留言真的很酷！</p>
<p>至於留言管理的部分，則是用<a href="https://leancloud.app/">LeanCloud</a> 來實現，可以刪留言之類的XD<br><img src="https://i.imgur.com/Zmtl0u8.png" alt=""></p>
<h3 id="抱怨一下"><a href="#抱怨一下" class="headerlink" title="抱怨一下"></a>抱怨一下</h3><p>今天在用Icloud 的時候，不小心把電腦上所有的檔案全部刪掉了，哭啊，這真是嚴重的事情ＱＱＱ，用到快掛了！當然，我電腦上的所有東西都不見了，也包括這一個部落格的本地程式碼，我用了 google drive 的備份，可惜那很難下載，所以我就用了github原本的備份的東西。</p>
<p>這真是不幸中的大幸，還好github的備份直接下載就可以直接用，不用特別再設定一些奇怪的東西，但所有的 hexo 指令都不見了，git的指令也都不見了，必須要重新設定。</p>
<p>這邊有一個小東西，就是下面這一行警告，就是要你把push設定成你要push的地方，不然只打一個push他並不會知道要push去哪裏，所以設定一下repo的位置就好了。</p>
<blockquote>
<p>git push —set-upstream origin master</p>
</blockquote>
<p>當然還有一堆bug ，只好慢慢爬文嘍，當你看到這一段文字，也就代表我成功找到解決辦法了！</p>
<h3 id="我又來更新了"><a href="#我又來更新了" class="headerlink" title="我又來更新了"></a>我又來更新了</h3><p>這幾天網站一直404 not found 超煩，於是我叫出之前的教學影片，重新看了之後，發現我的分支名稱弄錯了，不是用master而是用gh-pages，搞了好多天QQ</p>
<h2 id="架設心得"><a href="#架設心得" class="headerlink" title="架設心得"></a>架設心得</h2><p>部落格以後會常常更新，最近也會陸續把之前的文章放到部落格上面。整個網站從誕生到現在的結果已經花了15個小時，其中在Debug的時間應該佔了大多數！</p>
<p>遇到了幾個麻煩的問題，首先碰到的是本地的資料無法上傳到Github，終端機冒出來的是：<font color="#f00">Please make sure you have the correct access rights and the repository exists.</font>。這個錯誤超級煩，爬了一堆文結果他要在GitHub上面設定ssh金鑰之類的東西，才能獲取從本地更新的權限。結果網路上的文章說我要開啟一個名叫”.ssh”的資料夾，可是我翻遍了我的電腦也找不到這一個資料夾！後來我是利用終端機，輸入路徑位置硬是把那一個資料夾打開，它是一個透明的資料夾，還是第一次遇到！</p>
<p>接著是終端機跑出一堆error，那時候真的差點崩潰，花了超久架設的東西，竟然跑出這麼多的錯誤！難道全部的東西都付之一炬了嗎？翻了每一個被變更過的資料夾，才發現到在user_name的地方踩了雷，把他變回原本的設定就好了，真是不幸中的大幸，幸好我還能把東西救回來！</p>
<p>最後，終於能用https的前綴連到我的網站：<a href="https://peienwu.com">https://peienwu.com</a> 。如果要打www開頭也是可以連得上，直接打 peienwu.com 也可以順利連上！</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>個人部落格</tag>
        <tag>網站架設</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 103 (Rated for Div. 2)</title>
    <url>/cf1/</url>
    <content><![CDATA[<ul>
<li>Rating change:1137-&gt;1197<font color="#f00">(+60)</font></li>
<li>Problem solved: 1</li>
</ul>
<span id="more"></span>
<h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h2><h3 id="題序：點此"><a href="#題序：點此" class="headerlink" title="題序：點此"></a>題序：<a href="https://codeforces.com/contest/1476/problem/A">點此</a></h3><div class="note default">
            <blockquote><p>You are given two integers 𝑛 and 𝑘.</p><p>You should create an array of 𝑛 positive integers 𝑎1,𝑎2,…,𝑎𝑛 such that the sum (𝑎1+𝑎2+⋯+𝑎𝑛) is divisible by 𝑘 and maximum element in 𝑎 is minimum possible.</p><p>What is the minimum possible maximum element in 𝑎?</p><p><strong>Input</strong><br>The first line contains a single integer 𝑡 (1≤𝑡≤1000) — the number of test cases.</p><p>The first and only line of each test case contains two integers 𝑛 and 𝑘 (1≤𝑛≤10^9^; 1≤𝑘≤10^9^).</p><p><strong>Output</strong><br>For each test case, print one integer — the minimum possible maximum element in array 𝑎 such that the sum (𝑎1+⋯+𝑎𝑛) is divisible by 𝑘.</p></blockquote>
          </div>
<h3 id="解題想法"><a href="#解題想法" class="headerlink" title="解題想法"></a>解題想法</h3><p>一開始看到測資範圍：10^9^，就想到<em>O(n)</em>的時間複雜度是不可行的（有好多人在賽後因為這樣被<strong>hack</strong>）。一開始的想法是分段討論：n = k, n &gt; k, n &lt; k</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(n==k)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%k==<span class="number">0</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = k/n;</span><br><span class="line">            <span class="keyword">if</span>(k%n==<span class="number">0</span>)cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;temp+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看過別人程式碼後，發現其實也可以這樣改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        k = k*(<span class="keyword">int</span>)((n+k<span class="number">-1</span>)/k);<span class="comment">//大於等於n的k的最小倍數</span></span><br><span class="line">        <span class="keyword">if</span>(k%n==<span class="number">0</span>) cout&lt;&lt;k/n&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;k/n+<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而官方解法則是完全的數學，把式子寫出來之後，直接O(1)的複雜度算出答案<br><div class="note info">
            <p>Let’s denote 𝑠 as the sum of array 𝑎. From one side, since 𝑠 should be divisible by 𝑘 then we can say $𝑠=𝑐𝑓⋅𝑘$ From other side, since all 𝑎𝑖 are positive, then $𝑠≥𝑛$.</p><p>It’s quite obvious that the smaller $𝑠$ — the smaller maximum $𝑎𝑖$ so we need to find the smallest $𝑐𝑓$ that $𝑐𝑓⋅𝑘≥𝑛$. Then</p><script type="math/tex; mode=display">𝑐𝑓=⌈\frac{𝑛}{𝑘}⌉=⌊\frac{𝑛+𝑘−1}{𝑘}⌋</script><p>Now we now that $𝑠=𝑐𝑓⋅𝑘$ and we need to represent it as 𝑎1+⋯+𝑎𝑛 with maximum 𝑎𝑖 minimized. It’s easy to prove by contradiction that maximum</p><script type="math/tex; mode=display">𝑎𝑖≥⌈\frac{𝑠}{𝑛}⌉.</script><p>Moreover we can always construct such array 𝑎 that its sum is equal to 𝑠 and the maximum element is equal to $⌈\frac{𝑠}{𝑛}⌉$</p><p>As a result, the answer is</p><script type="math/tex; mode=display">⌈\frac{𝑠}{𝑛}⌉=⌊\frac{𝑐𝑓⋅𝑘+𝑛−1}{𝑛}⌋, 𝑐𝑓=⌊\frac{𝑛+𝑘−1}{𝑘}⌋.</script>
          </div><br>以下為官解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cf = (n + k - <span class="number">1</span>) / k;</span><br><span class="line">    k *= cf;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; (k + n - <span class="number">1</span>) / n &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解題紀錄"><a href="#解題紀錄" class="headerlink" title="解題紀錄"></a>解題紀錄</h3><div class="note success">
            <p>這一題共花了17分鐘才寫出來<br>可能是對題目的反應不夠快，沒有第一時間就想出解法<br>但第一題就應該是要很簡單的呀！<br>第一題是拚速度，速度快就可以排名比較前面(我看有許多人不到5分鐘就寫完了！)</p>
          </div>
<h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h2><h3 id="題序：點此-1"><a href="#題序：點此-1" class="headerlink" title="題序：點此"></a>題序：<a href="https://codeforces.com/contest/1476/problem/B">點此</a></h3><div class="note default">
            <blockquote><p>題目敘述</p><blockquote><p>給定兩個整數<em>n</em>,<em>k</em>，與<em>n</em>個整數<em>p~0~,p~1~,…𝑝~𝑛−1~  (1≤𝑝~𝑖~≤10^9^)</em>,其中p~0~代表物品的原始價格，𝑝~𝑖~則代表在第 𝑖-個月的價格變化。<br><em>k</em>代表每個月的通脹係數不得超過 𝑘％，因此必須對𝑝~𝑖~<strong>增加</strong>一些值，使所有𝑝~𝑖~為整數且每個月的通脹係數不超過 𝑘％。<br>試求最小的𝑝~𝑖~增加值為何？</p></blockquote><p>範例測資<br><img src="https://i.imgur.com/StpNbiI.png" alt=""></p><p>&gt;</p><blockquote><p>輸入：<br>2<br>4 1<br>20100 1 202 202<br>3 100<br>1 1 1<br>輸出：<br>99<br>0</p></blockquote></blockquote>
          </div>
<h3 id="解題想法-1"><a href="#解題想法-1" class="headerlink" title="解題想法"></a>解題想法</h3><p>依照題意，開一個長度為n的陣列，由第一天的上升價格開始，依序計算看會不會超過k%的膨脹係數。<br><div class="note success">
            <p>Let sum = p$<em>0$+p$_1$+$\cdots$+p$</em>{i-1}$<br>x 為 p$_{i}$要加的整數<br>則：</p><script type="math/tex; mode=display">\frac{p_i}{sum+x} \le \frac{k}{100}</script><p>經過通分後：</p><script type="math/tex; mode=display">x = \lceil\frac{100\times p_i-sum\times k}{k}\rceil\ge0</script>
          </div></p>
<p>因此可以寫出以下程式碼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,arr[<span class="number">105</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k,base,sum =<span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k&gt;&gt;base;</span><br><span class="line">        sum=base;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">100</span>*arr[i]&gt;k*sum)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">ceil</span>((arr[i]*<span class="number">100</span>-sum*k)/(<span class="keyword">double</span>)k);</span><br><span class="line">                ans+=temp;</span><br><span class="line">                sum+=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="built_in">ceil</span>((arr[i]*<span class="number">100</span>-sum*k)/(<span class="keyword">double</span>)k);</span><br></pre></td></tr></table></figure><p>這一段程式碼可以改成：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = (arr[i]*<span class="number">100</span>-sum*k+k<span class="number">-1</span>)/k;</span><br></pre></td></tr></table></figure><p>也可以達到<strong>取上高斯</strong>的效果<br>後者時間快上許多</p>
          </div>
<h3 id="解題紀錄-1"><a href="#解題紀錄-1" class="headerlink" title="解題紀錄"></a>解題紀錄</h3><p>當初在寫的時候忘記要在減完後除以k，因此吃了三次WA<br>所以以後知道，在寫題目之前，最好都先把數學式寫得清楚<br>在解題的時候才不會犯下這種錯！<br>另外，我現在才知道，取下高斯就是除法的<em>double</em>轉<em>int</em>就可以了<br>上高斯的話，除了用 <em>ceil()</em> 函式，還可以用上面那個方式來達到同樣的效果。<br>這一次rating change 剛好差了3就到1200，真是可惜，還要再打一場才可以升去</p>
<div class="note danger">
            <p>這一場主要學到的重點應該是怎麼樣把取上高斯轉換為下高斯（不用ceil()取）!</p>
          </div>
]]></content>
      <categories>
        <category>C++基礎主題</category>
        <category>CF</category>
      </categories>
      <tags>
        <tag>CF</tag>
        <tag>競賽</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.2.5 Codeforces Round</title>
    <url>/cf2/</url>
    <content><![CDATA[<ul>
<li>Rating change:1197-&gt;<font color="#0f0">1201<font color="#f00">(+4)<font color="#000"></li>
<li>Problem solved: 2</li>
</ul>
<p>終於上綠了！！這次只有加四（加的分數越來越少，表示要更強才能加更多分），統計一下總共打了六場才升到 rating 1200。</p>
<span id="more"></span>
<h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h2><h3 id="題序：點此"><a href="#題序：點此" class="headerlink" title="題序：點此"></a>題序：<a href="https://codeforces.com/contest/1481/problem/A">點此</a></h3><p><img src="https://i.imgur.com/TwBSik8.png" alt=""></p>
<h3 id="解題想法"><a href="#解題想法" class="headerlink" title="解題想法"></a>解題想法</h3><p>看完題目花了我大概五分鐘（太慢！），理解題意後發現蠻簡單的，只要分別統計 <em>U,D,R,L</em> 的數量即可，判斷  <em>U,D,R,L</em>的數量足不足夠到指定的目標。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>)arr[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>)arr[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)arr[<span class="number">2</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)arr[<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;=arr[<span class="number">2</span>] &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;=arr[<span class="number">0</span>])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;=arr[<span class="number">2</span>] &amp;&amp; y&lt;=<span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(y)&lt;=arr[<span class="number">1</span>])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=<span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(x)&lt;=arr[<span class="number">3</span>]&amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;=arr[<span class="number">0</span>])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=<span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(x)&lt;=arr[<span class="number">3</span>]&amp;&amp; y&lt;=<span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(y)&lt;=arr[<span class="number">1</span>])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>結果我還是吃了wa，因為沒有 <strong>&lt;=</strong> 寫成 <strong>&lt;</strong>，改完之後（改太快沒有注意到）結果CE，每一次上傳都要自己先編譯過啊，才不會犯這種低級錯誤！</p>
<h3 id="解題紀錄"><a href="#解題紀錄" class="headerlink" title="解題紀錄"></a>解題紀錄</h3><p>這一題用了30分鐘才寫出來，同學用了大概17分鐘就解出來了。這大概是我第一次體會到 coding 的速度跟不上腦袋想的速度（力不從心），明明已經想到要怎麼解，卻寫得很慢。所以看題目的時間＋手速很慢＝得分很少。<br>寫程式的速度需要時間慢慢培養，首先要做的就是加快打字的速度！<br>除此之外，還要避免犯下低級錯誤，務必要在上傳之前先檢查一下!</p>
<h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h2><h3 id="題序：點此-1"><a href="#題序：點此-1" class="headerlink" title="題序：點此"></a>題序：<a href="https://codeforces.com/contest/1481/problem/B">點此</a></h3><p><img src="https://i.imgur.com/VtQIJx3.png" alt=""></p>
<h3 id="解題想法-1"><a href="#解題想法-1" class="headerlink" title="解題想法"></a>解題想法</h3><p>直覺想到就是模擬第<strong>1</strong>顆球到<strong>k-1</strong>顆球，就可以推得第k顆球的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> arr[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(--k)&#123;</span><br><span class="line">            <span class="keyword">int</span> ind = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(arr[ind]&gt;=arr[ind+<span class="number">1</span>] &amp;&amp; ind&lt;n<span class="number">-1</span>)ind++;</span><br><span class="line">            <span class="keyword">if</span>(ind!=n<span class="number">-1</span>)arr[ind]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]&gt;=arr[i+<span class="number">1</span>] &amp;&amp; i&lt;n<span class="number">-1</span>)i++;</span><br><span class="line">        <span class="keyword">if</span>(i!=n<span class="number">-1</span>)cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解題紀錄-1"><a href="#解題紀錄-1" class="headerlink" title="解題紀錄"></a>解題紀錄</h3><p>寫到一半看到k的的大小 <strong>10^9^</strong>，還以為<strong>O(n)</strong>的複雜度會tle，不過我寫完丟上去測，過了！（我還跟同學說這個問題，結果他就去想有沒有其他O(n)以下的解法，後來他就沒有寫出來）不過花了28分鐘寫出來之後，看了範圍限制想了想，有一個關鍵的條件：</p>
<script type="math/tex; mode=display">1≤𝑛≤100, 1≤ℎ𝑖≤100</script><p><strong>the sum of 𝑛 over all test cases does not exceed 100.</strong><br>也就代表卡在中間的球數不會超過$(𝑛−1)⋅(100−1)$個，也就是說，最多從第$(𝑛−1)⋅(100−1)+1$ 個開始，接下來每一顆球都會一路望下滑，不會卡在中間，這時候迴圈就可以break了。看來 <strong>10^9^</strong>只是拿來嚇人的，正常模擬是不會tle的（某同學丟了3次還是wa）。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p><img src="https://i.imgur.com/xaEBkHZ.png" alt=""><br>這是目前的rating，昨天+4 之後終於變成綠色了！<br><img src="https://i.imgur.com/cgOkxrJ.png" alt=""><br><img src="https://i.imgur.com/5BtUq4I.png" alt=""><br>這個是目標<br><div class="note default">
            <p>希望接下來可以順利參加資訊之芽，好好讓自已變強，學一些dp還有其他的演算法，把學長的講義看完然後學起來，在高二的時候可以打比賽！</p>
          </div></p>
]]></content>
      <categories>
        <category>C++基礎主題</category>
        <category>CF</category>
      </categories>
      <tags>
        <tag>CF</tag>
        <tag>競賽</tag>
      </tags>
  </entry>
  <entry>
    <title>牛牛牧場問題</title>
    <url>/convex-hull/</url>
    <content><![CDATA[<h2 id="題序"><a href="#題序" class="headerlink" title="題序"></a>題序</h2><p>從前從前有一個人名叫thanksone，他與他的兩個哥哥thankstwo以及thanksthree以及他的弟弟thankszero一起開了一家「牛牛牧場」，用來養牛以及一些奇怪的東西。</p>
<p>有一天，他發現他的牛牛少了很多隻，不知道是跑去了哪裡，他很難過，因此他想要建造一個圍籬，讓所有牛牛都跑不出去。於是他拜託他的兩個哥哥thankstwo以及thanksthree去市集買了$n$個用來架設圍籬的木樁，並要求他們把這些木樁架設在他指定的位置。<br><span id="more"></span></p>
<p>接著，他拜託他的弟弟thankszero也去買了條超長的圍籬，並要求thankszero利用這條超長圍籬將$n$個木樁都圍起來，才能讓牛牛有盡量大的活動空間。thankszero的數學比起他的哥哥thanksone還要糟，因此他需要拜託你幫忙計算一下當他圍好圍籬之後，<strong>有多少個木樁會剛好落在這條圍籬上</strong>。除此之外，他還希望你能給他所有在圍籬上的木樁的位置，讓他知道固定圍籬的木樁的位置。</p>
<p>最後，thanksone看到了你驚人的計算能力，於是他要求你計算出<strong>圍籬所圍出來的面積</strong>有多大，讓他能知道他的牛牛有多少的活動空間。</p>
<p><img src="https://i.imgur.com/empMiPg.jpg=400x" alt=""></p>
<h2 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h2><p>第一行有一個正整數$n(3≤n≤2⋅10^5)$，表示有$n$個木樁在莊園上<br>接下來有$n$行，每行有兩個整數 $x$ 及 $y$（$−10^9≤x,y≤10^9$），以一個空白隔開，用以代表一個木樁在座標軸上的位置。</p>
<p>保證輸入的每一點都不會重複。</p>
<h2 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h2><p>第一行請輸出一個整數$k$：圍欄上木樁的個數（包含圍欄邊上的木樁）<br>接下來輸出$k$行，每一行為圍欄上木樁的座標，由$x$座標由小到大輸出，如果$x$座標相同則按照$y$座標大小輸出。<br>注意每一個木樁最多只能被輸出一次。<br>最後一行輸出圍欄所圍出的面積大小，資料四捨五入取到整數位。</p>
<h2 id="SUBTASK"><a href="#SUBTASK" class="headerlink" title="SUBTASK"></a>SUBTASK</h2><p>40分：$n ≤100$</p>
<p>60分：沒有特別限制</p>
<h2 id="範例測資1"><a href="#範例測資1" class="headerlink" title="範例測資1"></a>範例測資1</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 2</span><br><span class="line">2 0</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">4 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">2 0</span><br><span class="line">2 4</span><br><span class="line">4 2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="範例測資2"><a href="#範例測資2" class="headerlink" title="範例測資2"></a>範例測資2</h2><h3 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">2 2</span><br><span class="line">5 2</span><br></pre></td></tr></table></figure>
<h3 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br><span class="line">5 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>從範例測資1可以發現，thanksone可以將下圖木樁$B,F,D,G,C$圍起來，能獲得最大的牛牛牧場面積：<br><img src="https://i.imgur.com/2nD6cBt.png" alt=""></p>
<p>範例測資2可以看到，thanksone圍出來的牛牛牧場面積為 $0$：<br><img src="https://i.imgur.com/GSQnKXN.png" alt=""></p>
<h2 id="題目連結"><a href="#題目連結" class="headerlink" title="題目連結"></a>題目連結</h2><p><a href="http://ojdl.ck.tp.edu.tw/problem/7142">OJDL</a></p>
<h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>這一題就是凸包裸題，輸出所有包含在凸包上的點（頂點跟邊都要）。</p>
<h3 id="subtask-1"><a href="#subtask-1" class="headerlink" title="subtask 1"></a>subtask 1</h3><p>保證所形成的凸包面積不為0，所以做完凸包之後將邊上的點都輸出出來，之後再計算凸包面積就好。</p>
<h3 id="subtask-2"><a href="#subtask-2" class="headerlink" title="subtask 2"></a>subtask 2</h3><p>做完凸包可能會有點重複的問題，所以將所有點排序之後，記得去重，好好處理就可以AC了。</p>
<h3 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt <span class="keyword">const</span> &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt <span class="keyword">const</span> &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt <span class="keyword">const</span> &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt <span class="keyword">const</span> &amp;b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt <span class="keyword">const</span> &amp;b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt <span class="keyword">const</span> &amp;b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt <span class="keyword">const</span> &amp;b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pt <span class="keyword">const</span> &amp;a,pt <span class="keyword">const</span> &amp;b)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line">set&lt;pt,comp&gt; s;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa^bb) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    vector&lt;pt&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = h.<span class="built_in">size</span>();</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;sz &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-2</span>)area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : hull)s.<span class="built_in">insert</span>(i);</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)cout&lt;&lt;i.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i.y&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;((area%<span class="number">2</span>)?(area/<span class="number">2</span>)+<span class="number">1</span>:(area/<span class="number">2</span>))&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>計算幾何</category>
      </categories>
      <tags>
        <tag>演算法</tag>
        <tag>動態規劃</tag>
      </tags>
  </entry>
  <entry>
    <title>CSES:Introductory Problems</title>
    <url>/cses1/</url>
    <content><![CDATA[<p><a href="https://cses.fi/">CSES</a> 解題紀錄。</p>
<p><a href="https://cses.fi/user/84243">My Account</a><br><a href="https://cses.fi/user/84265">Thanksone帳號</a><br><a href="https://hackmd.io/@thanksone/HyzF2w_Ht">CSES Plan</a></p>
<h2 id="Introductory-Problems"><a href="#Introductory-Problems" class="headerlink" title="Introductory Problems"></a>Introductory Problems</h2><h3 id="Weird-Algorithm"><a href="#Weird-Algorithm" class="headerlink" title="Weird Algorithm"></a>Weird Algorithm</h3><p><a href="https://cses.fi/problemset/task/1068">題目連結</a></p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)n = <span class="number">3</span> * n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> n = n/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a>Missing Number</h3><p><a href="https://cses.fi/problemset/task/1083">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> sum = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        sum -= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Repetitions"><a href="#Repetitions" class="headerlink" title="Repetitions"></a>Repetitions</h3><p><a href="https://cses.fi/problemset/task/1069">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>,cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>])cur++;</span><br><span class="line">        <span class="keyword">else</span> cur = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,cur);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Increasing-Array"><a href="#Increasing-Array" class="headerlink" title="Increasing Array"></a>Increasing Array</h3><p><a href="https://cses.fi/problemset/task/1094">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans += arr[i<span class="number">-1</span>] - arr[i];</span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p><a href="https://cses.fi/problemset/task/1070">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span> || n == <span class="number">3</span>)cout&lt;&lt;<span class="string">&quot;NO SOLUTION&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span>)cout&lt;&lt;<span class="string">&quot;2 4 1 3 &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Number-Spiral"><a href="#Number-Spiral" class="headerlink" title="Number Spiral"></a>Number Spiral</h3><p><a href="https://cses.fi/problemset/task/1071">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">int</span> ly = <span class="built_in">max</span>(x,y)<span class="number">-1</span>,st = ly*ly;</span><br><span class="line">        <span class="keyword">if</span>(!(ly % <span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(y &lt; ly+<span class="number">1</span>)cout&lt;&lt;st+y&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;(st+ly+<span class="number">1</span>)+(ly+<span class="number">1</span>-x)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; ly+<span class="number">1</span>)cout&lt;&lt;st+x&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;(st+ly+<span class="number">1</span>)+(ly+<span class="number">1</span>-y)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Two-Knights"><a href="#Two-Knights" class="headerlink" title="Two Knights"></a>Two Knights</h3><p><a href="https://cses.fi/problemset/task/1072">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (i*i)*(i*i<span class="number">-1</span>)/<span class="number">2</span> - <span class="number">4</span>*(i<span class="number">-1</span>)*(i<span class="number">-2</span>);</span><br><span class="line">        dp[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Two-Sets"><a href="#Two-Sets" class="headerlink" title="Two Sets"></a>Two Sets</h3><p><a href="https://cses.fi/problemset/task/1092">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = n*(n+<span class="number">1</span>)/<span class="number">2</span>,sum = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(total &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = sum + i;</span><br><span class="line">        <span class="keyword">if</span>(next &lt;= total/<span class="number">2</span>)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            cnt++;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;n - cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bit-Strings"><a href="#Bit-Strings" class="headerlink" title="Bit Strings"></a>Bit Strings</h3><p><a href="https://cses.fi/problemset/task/1617">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans *= <span class="number">2</span>;</span><br><span class="line">        ans = ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trailing-Zeros"><a href="#Trailing-Zeros" class="headerlink" title="Trailing Zeros"></a>Trailing Zeros</h3><p><a href="https://cses.fi/problemset/task/1618">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">5</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        ans += n / f;</span><br><span class="line">        f *= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Coin-Piles"><a href="#Coin-Piles" class="headerlink" title="Coin Piles"></a>Coin Piles</h3><p><a href="https://cses.fi/problemset/task/1754">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(b - a &gt; a)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a % <span class="number">3</span>;b = b % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b == <span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Palindrome-Reorder"><a href="#Palindrome-Reorder" class="headerlink" title="Palindrome Reorder"></a>Palindrome Reorder</h3><p><a href="https://cses.fi/problemset/task/1755">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str,ans;cin&gt;&gt;str;</span><br><span class="line">    n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> num[N],cnt = <span class="number">0</span>,cha = <span class="number">-1</span>;<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        num[str[i] - <span class="string">&#x27;A&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            cnt++;cha = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span> &amp;&amp; !(n&amp;<span class="number">1</span>))cout&lt;&lt;<span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; <span class="number">1</span> &amp;&amp; n&amp;<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;NO SOLUTION\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans[n/<span class="number">2</span>] = <span class="string">&#x27;A&#x27;</span>+cha;</span><br><span class="line">            num[cha]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num[i])&#123;</span><br><span class="line">                ans[l++] = i + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                ans[r--] = i + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                num[i] -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gray-Code"><a href="#Gray-Code" class="headerlink" title="Gray Code"></a>Gray Code</h3><p><a href="https://cses.fi/problemset/task/2205">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;string&gt; str;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    str.<span class="built_in">pb</span>(<span class="string">&quot;0&quot;</span>);str.<span class="built_in">pb</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        vector&lt;string&gt; temp1 = str,temp2 = str;</span><br><span class="line">        <span class="built_in">reverse</span>(temp2.<span class="built_in">begin</span>(),temp2.<span class="built_in">end</span>());</span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> len = temp1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)temp1[i] = <span class="string">&quot;0&quot;</span> + temp1[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)temp2[i] = <span class="string">&quot;1&quot;</span> + temp2[i];</span><br><span class="line">        str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>(),temp1.<span class="built_in">begin</span>(),temp1.<span class="built_in">end</span>());</span><br><span class="line">        str.<span class="built_in">insert</span>(str.<span class="built_in">end</span>(),temp2.<span class="built_in">begin</span>(),temp2.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : str)cout&lt;&lt;i&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h3><p><a href="https://cses.fi/problemset/task/2165">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> by,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">solve</span>(from,by,to,n<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;from&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">solve</span>(by,to,from,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt; (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span> &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Creating-Strings"><a href="#Creating-Strings" class="headerlink" title="Creating Strings"></a>Creating Strings</h3><p><a href="https://cses.fi/problemset/task/1622">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>(),num[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        num[s[i] - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(num[i])&#123;</span><br><span class="line">            str += (<span class="keyword">char</span>)(i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            num[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()));</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : ans)cout&lt;&lt;i&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Apple-Division"><a href="#Apple-Division" class="headerlink" title="Apple Division"></a>Apple Division</h3><p><a href="https://cses.fi/problemset/task/1623">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m = <span class="number">0</span>,arr[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;j &amp; i)sum += arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,<span class="built_in">abs</span>(m - sum - sum));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        m += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Chessboard-and-Queens"><a href="#Chessboard-and-Queens" class="headerlink" title="Chessboard and Queens"></a>Chessboard and Queens</h3><p><a href="https://cses.fi/problemset/task/1624">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> maze[<span class="number">10</span>][<span class="number">10</span>],vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(i - x) == <span class="built_in">abs</span>(j - y))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == x || j == y)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur &gt; <span class="number">8</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(cur,i) &amp;&amp; maze[cur][i])&#123;</span><br><span class="line">            vis[cur][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(cur+<span class="number">1</span>);</span><br><span class="line">            vis[cur][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>)maze[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Digit-Queries"><a href="#Digit-Queries" class="headerlink" title="Digit Queries"></a>Digit Queries</h3><p><a href="https://cses.fi/problemset/task/2431">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,pref[N],p[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">19</span>;i++)&#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pref[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">18</span>;i++)&#123;</span><br><span class="line">        pref[i] = p[i<span class="number">-1</span>] * <span class="number">9</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; pref[ind])n -= pref[ind++];</span><br><span class="line">    n--;                    <span class="comment">//0-BASE</span></span><br><span class="line">    <span class="keyword">int</span> x = n / ind;        <span class="comment">//0-BASE</span></span><br><span class="line">    <span class="keyword">int</span> y = n % ind;        <span class="comment">//0-BASE</span></span><br><span class="line">    <span class="keyword">int</span> ans = p[ind<span class="number">-1</span>] + x;</span><br><span class="line">    string temp = <span class="built_in">to_string</span>(ans);</span><br><span class="line">    cout&lt;&lt;temp[y]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Grid-Paths"><a href="#Grid-Paths" class="headerlink" title="Grid Paths"></a>Grid Paths</h3><p><a href="https://cses.fi/problemset/task/1625">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF LONG_LONG_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">1</span> || x &gt; <span class="number">7</span> || y &lt; <span class="number">1</span> || y &gt; <span class="number">7</span> || vis[x][y])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == <span class="number">7</span> &amp;&amp; s &lt; <span class="number">48</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[x<span class="number">-1</span>][y] &amp;&amp; vis[x+<span class="number">1</span>][y] &amp;&amp; !vis[x][y+<span class="number">1</span>] &amp;&amp; !vis[x][y<span class="number">-1</span>])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[x<span class="number">-1</span>][y] &amp;&amp; !vis[x+<span class="number">1</span>][y] &amp;&amp; vis[x][y+<span class="number">1</span>] &amp;&amp; vis[x][y<span class="number">-1</span>])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">48</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(str[s] == <span class="string">&#x27;L&#x27;</span>)<span class="built_in">solve</span>(x - <span class="number">1</span>, y, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str[s] == <span class="string">&#x27;R&#x27;</span>)<span class="built_in">solve</span>(x + <span class="number">1</span>, y, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str[s] == <span class="string">&#x27;U&#x27;</span>)<span class="built_in">solve</span>(x, y - <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str[s] == <span class="string">&#x27;D&#x27;</span>)<span class="built_in">solve</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str[s] == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i],ny = y + dy[i];</span><br><span class="line">            <span class="built_in">solve</span>(nx,ny,s+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line">        vis[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">8</span>][i] = <span class="number">1</span>;</span><br><span class="line">        vis[i][<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSES</category>
      </categories>
      <tags>
        <tag>CSES</tag>
      </tags>
  </entry>
  <entry>
    <title>CSES:Geometry</title>
    <url>/cses7/</url>
    <content><![CDATA[<h2 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h2><h3 id="Point-Location-Test"><a href="#Point-Location-Test" class="headerlink" title="Point Location Test"></a>Point Location Test</h3><p><a href="https://cses.fi/problemset/task/2189/">題目連結</a><br><span id="more"></span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x &amp;&amp; y == b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span> - (pt b)&#123;<span class="keyword">return</span> &#123;x - b.x , y - b.y&#125;;&#125;</span><br><span class="line">    pt <span class="keyword">operator</span> + (pt b)&#123;<span class="keyword">return</span> &#123;x + b.x , y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (pt b)&#123;<span class="keyword">return</span> (x * b.y - y * b.x);&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> * (pt b)&#123;<span class="keyword">return</span> (x * b.x + y * b.y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2,x3,y3;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;</span><br><span class="line">        pt l = &#123;x2 - x1,y2 - y1&#125;, o = &#123;x3 - x1,y3 - y1&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((l ^ o) == <span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;TOUCH&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((l ^ o) &gt; <span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;LEFT&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;RIGHT&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Line-Segment-Intersection"><a href="#Line-Segment-Intersection" class="headerlink" title="Line Segment Intersection"></a>Line Segment Intersection</h3><p><a href="https://cses.fi/problemset/task/2190/">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x &amp;&amp; y == b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span> - (pt b)&#123;<span class="keyword">return</span> &#123;x - b.x , y - b.y&#125;;&#125;</span><br><span class="line">    pt <span class="keyword">operator</span> + (pt b)&#123;<span class="keyword">return</span> &#123;x + b.x , y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (pt b)&#123;<span class="keyword">return</span> (x * b.y - y * b.x);&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> * (pt b)&#123;<span class="keyword">return</span> (x * b.x + y * b.y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);</span><br><span class="line">    <span class="keyword">return</span> cross == <span class="number">0</span> &amp;&amp; dot &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dot == 0 when o is a or b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(cross == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inter</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c) || <span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a) || <span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">dir</span>(a,b,c) * <span class="built_in">dir</span>(a,b,d)) == <span class="number">-1</span></span><br><span class="line">       &amp;&amp; (<span class="built_in">dir</span>(c,d,a) * <span class="built_in">dir</span>(c,d,b)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        pt pot[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">inter</span>(pot[<span class="number">0</span>],pot[<span class="number">1</span>],pot[<span class="number">2</span>],pot[<span class="number">3</span>]))cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Polygon-Area"><a href="#Polygon-Area" class="headerlink" title="Polygon Area"></a>Polygon Area</h3><p><a href="https://cses.fi/problemset/task/2191/">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x &amp;&amp; y == b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span> - (pt b)&#123;<span class="keyword">return</span> &#123;x - b.x , y - b.y&#125;;&#125;</span><br><span class="line">    pt <span class="keyword">operator</span> + (pt b)&#123;<span class="keyword">return</span> &#123;x + b.x , y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (pt b)&#123;<span class="keyword">return</span> (x * b.y - y * b.x);&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> * (pt b)&#123;<span class="keyword">return</span> (x * b.x + y * b.y);&#125;</span><br><span class="line">&#125;pot[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)ans += (pot[i] ^ pot[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;</span><br><span class="line">    pot[n] = pot[<span class="number">0</span>];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">abs</span>(<span class="built_in">solve</span>())&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Point-in-Polygon"><a href="#Point-in-Polygon" class="headerlink" title="Point in Polygon"></a>Point in Polygon</h3><p><a href="https://cses.fi/problemset/task/2192/">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (point b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x &amp;&amp; y == b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    point <span class="keyword">operator</span> - (point b)&#123;<span class="keyword">return</span> &#123;x - b.x , y - b.y&#125;;&#125;</span><br><span class="line">    point <span class="keyword">operator</span> + (point b)&#123;<span class="keyword">return</span> &#123;x + b.x , y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (point b)&#123;<span class="keyword">return</span> (x * b.y - y * b.x);&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> * (point b)&#123;<span class="keyword">return</span> (x * b.x + y * b.y);&#125;</span><br><span class="line">&#125;pt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(point a,point b,point o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);</span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>) &amp;&amp; (dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(point a,point b,point o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(cross == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inter</span><span class="params">(point a,point b,point c,point d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c) || <span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a) || <span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c) * <span class="built_in">dir</span>(a,b,d) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a) * <span class="built_in">dir</span>(c,d,b) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(point cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">onseg</span>(pt[i],pt[i+<span class="number">1</span>],cur) == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">inter</span>(pt[i],pt[i+<span class="number">1</span>],cur,point&#123;INF,cur.y&#125;))sum++;</span><br><span class="line">        point temp = pt[i].y &gt; pt[i+<span class="number">1</span>].y ? pt[i] : pt[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp.y == cur.y &amp;&amp; temp.x &gt; cur.x)sum--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;</span><br><span class="line">    pt[n] = pt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        point temp;cin&gt;&gt;temp.x&gt;&gt;temp.y;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">solve</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;BOUNDARY&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;INSIDE&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;OUTSIDE&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Polygon-Lattice-Points"><a href="#Polygon-Lattice-Points" class="headerlink" title="Polygon Lattice Points"></a>Polygon Lattice Points</h3><p><a href="https://cses.fi/problemset/task/2193/">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (point b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x &amp;&amp; y == b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    point <span class="keyword">operator</span> - (point b)&#123;<span class="keyword">return</span> &#123;x - b.x , y - b.y&#125;;&#125;</span><br><span class="line">    point <span class="keyword">operator</span> + (point b)&#123;<span class="keyword">return</span> &#123;x + b.x , y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (point b)&#123;<span class="keyword">return</span> (x * b.y - y * b.x);&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> * (point b)&#123;<span class="keyword">return</span> (x * b.x + y * b.y);&#125;</span><br><span class="line">&#125;pt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)sum += pt[i] ^ pt[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;</span><br><span class="line">    pt[n] = pt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cnt += <span class="built_in">gcd</span>(<span class="built_in">abs</span>(pt[i].x-pt[i+<span class="number">1</span>].x),<span class="built_in">abs</span>(pt[i].y-pt[i+<span class="number">1</span>].y));</span><br><span class="line">    ans = (<span class="built_in">solve</span>() + <span class="number">2</span> - cnt)/<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Minimum-Euclidean-Distance"><a href="#Minimum-Euclidean-Distance" class="headerlink" title="Minimum Euclidean Distance"></a>Minimum Euclidean Distance</h3><p><a href="https://cses.fi/problemset/task/2194/">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF LONG_LONG_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector &lt;pii&gt; pt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a.x - b.x,y = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">vector &lt;pii&gt; temp;</span><br><span class="line"><span class="comment">//區間[l,r]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>,mid_x = pt[mid].x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">min</span>(<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r));</span><br><span class="line">    </span><br><span class="line">    temp.<span class="built_in">assign</span>(r - l + <span class="number">1</span>,&#123;<span class="number">0</span> , <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">merge</span>(</span><br><span class="line">          pt.<span class="built_in">begin</span>() + l,pt.<span class="built_in">begin</span>() + mid + <span class="number">1</span>,</span><br><span class="line">          pt.<span class="built_in">begin</span>() + mid + <span class="number">1</span>,pt.<span class="built_in">begin</span>() + r + <span class="number">1</span>,</span><br><span class="line">          temp.<span class="built_in">begin</span>(), cmp</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)pt[i] = temp[i-l];</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(pt[i].x - mid_x)*<span class="built_in">abs</span>(pt[i].x - mid_x) &lt;= ans)temp.<span class="built_in">push_back</span>(pt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = temp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,<span class="built_in">dis</span>(temp[i],temp[j]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(temp[i].y - temp[j].y)*<span class="built_in">abs</span>(temp[i].y - temp[j].y) &gt; ans)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    pt.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;</span><br><span class="line">    <span class="built_in">sort</span>(pt.<span class="built_in">begin</span>(),pt.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;<span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h3><p><a href="https://cses.fi/problemset/task/2195/">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF LONG_LONG_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (point b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x &amp;&amp; y == b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    point <span class="keyword">operator</span> - (point b)&#123;<span class="keyword">return</span> &#123;x - b.x , y - b.y&#125;;&#125;</span><br><span class="line">    point <span class="keyword">operator</span> + (point b)&#123;<span class="keyword">return</span> &#123;x + b.x , y + b.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (point b)&#123;<span class="keyword">return</span> (x * b.y - y * b.x);&#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> * (point b)&#123;<span class="keyword">return</span> (x * b.x + y * b.y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;point&gt; pt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dir</span><span class="params">(point a,point b,point c)</span></span>&#123;</span><br><span class="line">    point A = a - c,B = b - c;</span><br><span class="line">    <span class="keyword">return</span> (A ^ B) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;point&gt; <span class="title">convex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;point&gt; h;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(pt),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : pt)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">dir</span>(h[h.<span class="built_in">size</span>()<span class="number">-1</span>],i,h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down = h.<span class="built_in">size</span>();</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(pt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : pt)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>() &gt; down &amp;&amp; !<span class="built_in">dir</span>(h[h.<span class="built_in">size</span>()<span class="number">-1</span>],i,h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    pt.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;</span><br><span class="line">    vector&lt;point&gt; ans = <span class="built_in">convex</span>();</span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : ans)cout&lt;&lt;i.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i.y&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSES</category>
      </categories>
      <tags>
        <tag>CSES</tag>
      </tags>
  </entry>
  <entry>
    <title>錯排問題（Derangements）</title>
    <url>/derangement/</url>
    <content><![CDATA[<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>錯排是組合數學中的問題之一。考慮一個有n個元素的排列，若一個排列中<strong>所有的元素都不在自己原來的位置上</strong>，那麼這樣的排列就稱為原排列的一個錯排。本文將從<strong>錯排公式</strong>的推導開始，近一步探究其性質及應用。</p>
<p>$n$個元素的錯排數記為 $D_n$ 或 $!n$。 研究一個排列錯排個數的問題，叫做錯排問題或稱為更列問題。<br><span id="more"></span></p>
<h2 id="規律與公式"><a href="#規律與公式" class="headerlink" title="規律與公式"></a>規律與公式</h2><h3 id="反面枚舉"><a href="#反面枚舉" class="headerlink" title="反面枚舉"></a>反面枚舉</h3><p>前幾項可以用取捨原理（或窮舉所有可能）求得：</p>
<script type="math/tex; mode=display">\begin{align}D_1 &= 0 \\ D_2 &= 1\\D_3 &= 2 \\ D_4 &= 9\end{align}</script><div class="note default">
            <p><strong>三個元素的錯排，以下共兩種：</strong><br><img src="https://i.imgur.com/24cJS8t.png&gt; =500x" alt=""></p><p><strong>四個元素的錯排，以下共9種：</strong></p><blockquote><p>4123<br>3421<br>3142<br>4312<br>2413<br>2341<br>4321<br>3412<br>2143</p></blockquote>
          </div>
<p>如下面的文氏圖可以看到，以三個元素的錯排為例，我們要求的就是綠色區域的數量，透過排容原理（取捨原理）來算。<br><img src="https://i.imgur.com/4cSFDiw.png&gt; =400x" alt=""></p>
<script type="math/tex; mode=display">\begin{split}D_3 = 3!-C^3_1\cdot2!+C^3_2\cdot1!-C^3_3\cdot0! =2\end{split}</script><p>如果要求 $!4$ 也是一樣的作法：</p>
<script type="math/tex; mode=display">D_4 = 4!-C^4_1\cdot3!+C^4_2\cdot2!-C^4_3\cdot1!+C^4_4\cdot0! = 9</script><p>這邊可以觀察到一個重要的規律，階乘的遞減、C取的數字遞增以及正負交替，這些性質會被用在等一下的一般化推導！</p>
<h3 id="遞迴解"><a href="#遞迴解" class="headerlink" title="遞迴解"></a>遞迴解</h3><p>第一個公式是高中數學利用遞迴的概念得到的：</p>
<script type="math/tex; mode=display">D_n=(n-1)(D_{n-1}+D_{n-2})</script><div class="note success">
            <p><strong>證明：</strong><br>在原本 $n-1$ 個元素當中取一個元素跟新加入的元素（第n個元素）做交換，共有$C^{n-1}_1$ 種取法，假設取到的元素是K，則K有以下兩種情況：</p><ol><li>K本身即不在原本的位置上，跟新加入的元素調換亦是錯排</li><li>K在原本的位置上，跟新加入的元素調換後形成錯排<br><img src="https://i.imgur.com/k7l4Srr.png" alt=""></li></ol><p>綜合以上兩種狀況，可以推得上面的公式</p>
          </div>
<p>第二個是維基百科上面的公式：</p>
<script type="math/tex; mode=display">D_n = nD_{n-1}+(-1)^n</script><p>這一個公式可以由等一下的一般式的公式（下面的公式解）推討過來：</p>
<script type="math/tex; mode=display">\begin{split}D_n&=n!\sum_{k=0}^{n}\frac{(-1)^k}{k!}\\&=n(n-1)!\sum_{k=0}^{n-1}\frac{(-1)^k}{k!}+n!\cdot\frac{(-1)^n}{n!}\\&=nD_{n-1}+(-1)^n\end{split}</script><p>用這兩個遞迴式可以推得第n項的數值，不過時間複雜度依然是$O(n)$，想要求得的是$O(1)$的公式解</p>
<h3 id="公式解"><a href="#公式解" class="headerlink" title="公式解"></a>公式解</h3><p>公式解可以利用取捨原理求得，寫成一般化的形式。對於第n項的錯排數可以利用之前觀察到排容原理的規律整理出以下式子：</p>
<script type="math/tex; mode=display">\begin{split}D_n&=n!-C^n_1(n-1)!+C^n_2(n-2)!-\cdots+C^n_n0!\\&=\sum^n_{k=0}C^n_k(n-k)!\cdot(-1)^k\\&=\sum_{k=0}^{n}\frac{n!}{k!(n-k)!}\cdot(n-k)!\cdot(-1)^k\\&=n!\sum^{n}_{k=0}\frac{(-1)^k}{k!}\end{split}</script><p>這個就是錯排數的一般化公式，如果想要把sigma消掉，還可以用以下處理：</p>
<script type="math/tex; mode=display">\begin{split}D_n&=n!\sum^{n}_{k=0}\frac{(-1)^k}{k!}\\&=n![1-\frac{1}{1!}+\frac{1}{2!}-\cdots+(-1)^n\frac{1}{n!}]\end{split}</script><p>根據泰勒公式（$R_n$為修正項）</p>
<script type="math/tex; mode=display">\begin{split}e^{-1}&=1+\frac{(-1)^1}{1!}+\frac{(-1)^2}{2!}+\cdots+(-1)^n\frac{1}{n!}+R(n)\\&=[1-\frac{1}{1!}+\frac{1}{2!}-\cdots+(-1)^n\frac{1}{n!}]+R(n)\end{split}</script><p>因為泰勒公式，中括號內的數值在n越大時會越接近$e^{-1}$，因此可以改寫成以下式子：</p>
<script type="math/tex; mode=display">\begin{split}D_n \cong n!\cdot e^{-1}\to\frac{D_n}{n!}\cong e^{-1}\end{split}</script><p>這就是n樣物品錯排的機率，那因為這只是近似值，由於正負交替，數值會在$e^{-1}$ 的地方震盪。為了要求出確切的$D_n$的解，我們要在後面加上一個修正項（泰勒展開餘項$R_n$），經過整理發現這個餘項 $\frac{1}{n+1}$ 會嚴格小於 $0.5$，因此得到以下的一般項公式：</p>
<script type="math/tex; mode=display">D_n=\lfloor\frac{n!}{e}+0.5\rfloor</script><p>以上就是對於一般項$D_n$ 的一般項公式！</p>
<h2 id="實際模擬"><a href="#實際模擬" class="headerlink" title="實際模擬"></a>實際模擬</h2><p>利用ggb的模擬做出震盪的效果，我是直接輸入一般化的公式，但討論n不是正整數的情況其實沒有意義，不過程式還是可以跑出一個數值如下：<br><img src="https://i.imgur.com/0mTp7jo.png" alt=""></p>
<p>最後會趨近於$e^{-1}\cong0.36787944$<br>因為我們討論的都是整數解的狀況，利用python 模擬出正整數解的情況：<br><img src="https://i.imgur.com/VE4q8gh.png" alt=""></p>
<p>印出n從一到20的跟$e^{-1}$的差距，可以看到有正負交替的情況，且每一次的差距都越來越小：<br><img src="https://i.imgur.com/dloPsbD.png" alt=""></p>
<p>以上都是近似的情況，因為公式是一個無窮級數，只會越來越接近理論的機率 $e^{-1}$ ，但永遠都會有一個微小的差距，也就是無限逼近的概念！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">const = np.exp(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">l[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    l[i] = l[i-<span class="number">1</span>]*i</span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">21</span>):</span><br><span class="line">    a[i]= (a[i-<span class="number">1</span>]+a[i-<span class="number">2</span>])*(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    x.append(i)</span><br><span class="line">    y.append((a[i]/l[i]))</span><br><span class="line">    <span class="built_in">print</span>((a[i]/l[i])-const)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Possibility to N&quot;</span>, fontsize=<span class="number">20</span>) <span class="comment">#圖表標題</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;N&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#x軸標題</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Possibility&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#y軸標題</span></span><br><span class="line"></span><br><span class="line">plt.xticks([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>])</span><br><span class="line">plt.yticks([<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show() <span class="comment">#顯示繪製的圖形</span></span><br></pre></td></tr></table></figure>
<h2 id="題目—P3182-HAOI2016-放棋子"><a href="#題目—P3182-HAOI2016-放棋子" class="headerlink" title="題目—P3182 [HAOI2016]放棋子"></a>題目—P3182 [HAOI2016]放棋子</h2><p><a href="https://www.luogu.com.cn/problem/P3182">題目連結</a><br>題目敘述是這樣：</p>
<blockquote>
<p>給你一個 N×N 的矩陣，每行有一個障礙，數據保證任意兩個障礙不在同一行，任意兩個障礙不在同一列，要求你在這個矩陣上放 N 枚棋子（障礙的位置不能放棋子），要求你放 N 個棋子也滿足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少種方案。<br>第一行一個N，接下來一個N*N的矩陣。n≤200，0 表示沒有障礙，1 表示有障礙，輸出一個整數，即合法的方案數。</p>
</blockquote>
<p>這一題是在整理錯排相關公式的時候發現這一題，很明顯的，障礙物代表原來的位置，所以其實要求的就是n個元素的錯排種類。因為這一題的$n≤200$，第200項的值會接近$200!$的量級，<a href="https://www.wolframalpha.com/input/?i=floor%28%28200%21%2Fe%29%2B0.5%29">大約是$10^{374}$ 這麼多</a>，對大數加法乘法來說卻是輕而易舉！<br>可以用<script type="math/tex">D_n = nD_{n-1}+(-1)^n</script>的遞迴公式，時間複雜度$O(n)$的時間（把大數運算當作$O(1)$但其實它的常數算大）求出答案！</p>
<p>如果想看從3個元素到200個元素的錯排總數，<a href="https://gist.github.com/peienwu/7a7b5e72e8fd5cb0bc02977938eedc69">可以點這裡！</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,c[<span class="number">1000</span>],lenc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> s,string x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenn = x.<span class="built_in">size</span>(),product[lenc+lenn+<span class="number">10</span>],brr[lenn+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(product,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(product));</span><br><span class="line">    <span class="built_in">memset</span>(brr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(brr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenn;i++)brr[i] = x[lenn-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenn;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenc;j++)&#123;</span><br><span class="line">            product[i+j] += brr[i]*c[j];</span><br><span class="line">            <span class="keyword">if</span>(product[i+j] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                product[i+j+<span class="number">1</span>] += product[i+j]/<span class="number">10</span>;</span><br><span class="line">                product[i+j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lenc+lenn+<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(product[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            lenc = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenc;i++)c[i] = product[i];</span><br><span class="line"></span><br><span class="line">    c[<span class="number">0</span>] += <span class="built_in">power</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="number">10</span>)&#123;</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        c[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[ind]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            c[ind+<span class="number">1</span>]+=<span class="number">1</span>;c[ind] = <span class="number">0</span>;</span><br><span class="line">            ind++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">        c[<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[ind]&lt;=<span class="number">-1</span>)&#123;</span><br><span class="line">            c[ind+<span class="number">1</span>]-=<span class="number">1</span>;c[ind]=<span class="number">9</span>;</span><br><span class="line">            ind++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;lenc=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            string temp = <span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="built_in">calculate</span>(i,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lenc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;c[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>整理一下上面提到錯排數的公式：</p>
<h3 id="遞迴"><a href="#遞迴" class="headerlink" title="遞迴"></a>遞迴</h3><script type="math/tex; mode=display">D_n = (n-1)(D_{n-1}+D_{n-2})\quad,n\ge3\\D_n = nD_{n-1}+(-1)^n\quad,n\ge2</script><h3 id="一般項公式解"><a href="#一般項公式解" class="headerlink" title="一般項公式解"></a>一般項公式解</h3><script type="math/tex; mode=display">D_n=\lfloor\frac{n!}{e}+0.5\rfloor\quad,n\ge1\\D_n=n!\sum^{n}_{k=0}\frac{(-1)^k}{k!}\quad,n\ge1</script><p>分析錯排問題所用到的指數函數與泰勒展開會在以後學到的時候把相關東西補起來，在這之前就先接受結論吧！<br><strong>歐拉：「錯排問題組合數學中的一個奇妙問題」</strong>，實際查找資料發現到高中教錯排也只是淺淺的帶過公式，並沒有很深刻的對這個問題做討論（也算超出範圍啦），就想說對這個主題做更深入的一些探討！</p>
<h2 id="附錄"><a href="#附錄" class="headerlink" title="附錄"></a>附錄</h2><p>一些的數學證明：<br><img src="https://i.imgur.com/oMHPwZR.jpg" alt=""></p>
<p>要用python 繪圖之前要先在mac終端安裝一些東西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip install numpy</span><br><span class="line">python3 -mpip install matplotlib</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>2021暑假筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>二維都卜勒效應模擬實驗計畫</title>
    <url>/doppler/</url>
    <content><![CDATA[<h2 id="實驗器材"><a href="#實驗器材" class="headerlink" title="實驗器材"></a>實驗器材</h2><ul>
<li>麥克風一支</li>
<li>蜂鳴器一枚</li>
<li>圓形轉盤(建中實驗室)</li>
<li>筆電一台(裝好聲音處理軟體，並確保可以連上麥克風)</li>
</ul>
<span id="more"></span>
<h2 id="理論部分"><a href="#理論部分" class="headerlink" title="理論部分"></a>理論部分</h2><p>整理一些會用到的物理公式、名詞等。在小論文中，我們總共做了角度對頻率的關係圖，以及頻率對時間的關係圖，我們在實驗中主要會用到的是<strong>頻率對時間的關係圖</strong>，其實最重要的還是頻率的最大值與最小值。</p>
<p>實驗做完以後，會結合我們小論文最後一部分:<strong>理論與模擬的比較</strong>這一個部分，結合實驗，做出更詳盡，有說服力的論述。</p>
<h3 id="都卜勒效應公式"><a href="#都卜勒效應公式" class="headerlink" title="都卜勒效應公式"></a>都卜勒效應公式</h3><p>因為是做時間對上頻率的關係圖，因此我們要用的就是一般一維的都卜勒效應公式。先定義 $f’$ 為觀察者(靜止)所觀測到的頻率，$f$ 為蜂鳴器發射出來的頻率，$v$ 為聲音的波速，$v_s$ 為蜂鳴器相對於介質的移動速度。以下公式：</p>
<script type="math/tex; mode=display">f' = \frac{v}{v+v_s}\cdot f</script><p>注意到 $v_s$ 要代入的是切線速度(到時候會用角速度換算而來)  </p>
<h3 id="角速度與切線速度"><a href="#角速度與切線速度" class="headerlink" title="角速度與切線速度"></a>角速度與切線速度</h3><p><img src="https://i.imgur.com/S9Io87a.png" alt=""></p>
<p>角速度 $\omega$ 代表的是一秒內能夠轉動的弧度多少，其單位為 $\frac{rad}{s}$ ，要注意的是弧度沒有單位!從定義可以推導出以下公式：</p>
<script type="math/tex; mode=display">\omega = \frac{\Delta \theta}{\Delta t}</script><p>而根據弧度的定義，我們知道 $\theta = \frac{S}{r}$ ，如果要求出切線速度 $v$ ，我們可以列出以下式子：</p>
<script type="math/tex; mode=display">v = \frac{d \, S}{d \,t}</script><p>換句話說就是對距離作微分得到時間。其中 $S = r\cdot\theta$，代入之後得到：</p>
<script type="math/tex; mode=display">v = \frac{r\times \Delta\theta}{\Delta t} = r\cdot \omega</script><p>有了切線速度之後，就可以直接代入都卜勒效應公式中蜂鳴器 $v_s$ 算出頻率了!</p>
<h3 id="不確定度"><a href="#不確定度" class="headerlink" title="不確定度"></a>不確定度</h3><p>不確定度可以分成 A 類不確定度以及 B 類不確定度，以 $u_A,u_B$ 表示。其中 A 類不確定度的公式：</p>
<p><img src="https://i.imgur.com/Eu4LAs4.png" alt=""></p>
<p>B 類則是用儀器的最小刻度乘上$\frac{1}{2\sqrt{3}}$，到時候看看麥克風的規格再來算一下。而有了這兩個不確定度之後，就要算組合不確定度：</p>
<script type="math/tex; mode=display">u = \sqrt{u_A^2+u_B^2}</script><p>算不確定度都是取有效位數兩位，最佳估計值對齊不確定度的位數。寫成結果 X = 最佳估計值 ± 不確定度的形式。</p>
<h2 id="實驗流程"><a href="#實驗流程" class="headerlink" title="實驗流程"></a>實驗流程</h2><ol>
<li>設定轉盤轉速、蜂鳴器旋轉半徑(可以固定與觀察者的距離，因為這個距離對頻率不會有影響)</li>
<li>轉動旋轉圓盤，用麥克風接收頻率，並輸入軟體之後畫出f-t圖(先找出蜂鳴器在哪一個頻率區間的聲音是最大聲的)</li>
<li>找出每一組數據中頻率的最大值以及最小值，並與理論作比較</li>
</ol>
<h2 id="預期呈現方式-實驗表格"><a href="#預期呈現方式-實驗表格" class="headerlink" title="預期呈現方式(實驗表格)"></a>預期呈現方式(實驗表格)</h2><p>這個表格是角速度對上蜂鳴器的旋轉半徑(公分)的圖，表格裡面的數字則是切線速度(公分/秒，可能還要做一些單位的換算之後代入公式)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">w-r</th>
<th>2.5</th>
<th style="text-align:left">5</th>
<th>7.5</th>
<th style="text-align:left">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1π</td>
<td>2.5π</td>
<td style="text-align:left">5π</td>
<td>7.5π</td>
<td style="text-align:left">10π</td>
</tr>
<tr>
<td style="text-align:left">2π</td>
<td>5π</td>
<td style="text-align:left">10π</td>
<td>15π</td>
<td style="text-align:left">20π</td>
</tr>
<tr>
<td style="text-align:left">3π</td>
<td>7.5π</td>
<td style="text-align:left">15π</td>
<td>22.5π</td>
<td style="text-align:left">30π</td>
</tr>
<tr>
<td style="text-align:left">4π</td>
<td>4π</td>
<td style="text-align:left">20π</td>
<td>30π</td>
<td style="text-align:left">40π</td>
</tr>
</tbody>
</table>
</div>
<p>這是理論算出來的結果：<br><img src="https://i.imgur.com/6NCum1O.png" alt=""></p>
<p>會有兩個表格分別是理論的頻率最大、最小值，以及實驗表格要填入觀察的結果(用Audacity分析)，形式大概就是長成上表這樣。</p>
<p><img src="https://i.imgur.com/iOmuS6R.png" alt=""></p>
<p>最後，我們打算固定轉動的速度(角速度)，畫出頻率對上半徑的圖形(x座標為半徑、y座標為頻率)，用兩條直線表示理論和實際測量的結果。</p>
<h2 id="程式部分"><a href="#程式部分" class="headerlink" title="程式部分"></a>程式部分</h2><p><a href="https://glowscript.org/#/user/ck1090758/folder/%E4%BA%8C%E5%B9%B4%E7%B4%9ATEST/program/Experiment">程式碼連結</a></p>
<p>將之前的程式碼的數字改成符合真實狀況之後，圖畫出來的效果很糟，因為之前都是以公尺為單位，當處理到以公分為單位的細微變化時，就會跑出很糟糕的圖形。因此，我們將之前的程式碼的時間變化dt改成 $10^{-8}$，使每一次的波的位移量盡量小，才能讓結果更精準。</p>
<p>這是有bug一開始的醜陋圖形：</p>
<p><img src="https://i.imgur.com/7XD686j.png" alt=""></p>
<p>加上了一點<strong>時間延遲</strong>的處理之後，若帶入上面的數據，與公式推出來的結果誤差會在正負 $0.005$ 之間，算時蠻精準的，例如下圖：</p>
<p><img src="https://i.imgur.com/L1ouBCB.png" alt=""></p>
<p>這個是用 $10^{-7}$ 為間隔的圖形，在最大最小值跟理論有些小的差距。因此，在求最大最小值的時候，會以 $10^{-8}$ 為間隔，缺點是跑得很慢就是了，因此採用直接把初始位置設在發生頻率極值附近，比較能快速觀察。</p>
<p><img src="https://i.imgur.com/v5Cz70r.png" alt=""></p>
<p>誤差約為 $3.5\times 10^{-4}\%$ 左右。</p>
<h2 id="Praat使用"><a href="#Praat使用" class="headerlink" title="Praat使用"></a>Praat使用</h2><div class="note default">
            <p><strong>使用其他音頻分析軟體</strong><br>剛剛下載了Sonic Visualizer 測試看看，果然可以分析每一個時間點中，各個頻率的強度為何。我先用手機播放400HZ以及4000HZ的聲音。下圖就是400HZ的波段，可以看到在對應的頻率強度最強，其他應該就是背景雜音的部分。<br><img src="https://i.imgur.com/ejeKPYk.png" alt=""></p><p>這是4000HZ的圖形，但他好像沒辦法完全做到時頻圖。<br><img src="https://i.imgur.com/eNdrKmM.png" alt=""></p><p>不知道這個功能可不可以使用，下面的圖形中，縱軸表示的是頻率，橫軸是時間，也就是時頻圖，用不同顏色來區分聲音的大小。可以看到前半部分黃色線是明顯的400HZ，而後面有一段由好多個點構成的線段（不太明顯，可能是聲音不夠大的結果）則是4000HZ。如果要分析這些的話，那除了聲音要夠大之外，頻率變化要明顯才能看得出差別。</p><p><img src="https://i.imgur.com/HJ5fy7g.png" alt=""></p>
          </div>
<p>上網查了一下發現 Audacity 好像無法畫出時頻圖(研究很久都沒有結果)，所以找到了 Praat 這個應用程式，而經過一翻研究後的確可以畫出頻譜圖。</p>
<p>我們自己錄了一小段用手機播放出來的音頻，分析後的結果大概如下圖：</p>
<p>音檔分析結果：<br><img src="https://i.imgur.com/PNAe1p9.png" alt=""></p>
<p>經過實驗測試，未來將以麥克風收音後傳入 Audacity，匯出成音檔後傳進 Praat 後進行分析。</p>
<h2 id="目前困境"><a href="#目前困境" class="headerlink" title="目前困境"></a>目前困境</h2><ul>
<li><p>[ ] 嘗試使用 Arduino 的蜂鳴器，太小聲，必須買大聲一點的蜂鳴器(出貨中)。<br><img src="https://i.imgur.com/4jR8QTT.jpg" alt=""></p>
</li>
<li><p>[ ] 跟據理論預測，頻率變化的量不太明顯，必須使用頻率較高的蜂鳴器才能讓頻率最大值最小值的差距放大，或變得更顯著。不過還是會擔心說<strong>頻率的變化會不明顯</strong>，只能等實際做做看實驗才知道。<br>目前打算用一個4000HZ的蜂鳴器進行實驗，希望在頻率表現上可以更加明顯(看到有大學實驗室是利用 40kHz 進行實驗，所產生的頻率變化應該會明顯許多)</p>
</li>
</ul>
<h2 id="實驗結果"><a href="#實驗結果" class="headerlink" title="實驗結果"></a>實驗結果</h2><h3 id="V-30-R-5"><a href="#V-30-R-5" class="headerlink" title="V = 30,R = 5"></a>V = 30,R = 5</h3><p><img src="https://i.imgur.com/Rdd3sQj.png" alt=""></p>
<h3 id="V-60-R-5"><a href="#V-60-R-5" class="headerlink" title="V = 60,R = 5"></a>V = 60,R = 5</h3><p><img src="https://i.imgur.com/8ZS4ad6.png" alt=""></p>
<h3 id="V-90-R-5"><a href="#V-90-R-5" class="headerlink" title="V = 90,R = 5"></a>V = 90,R = 5</h3><p><img src="https://i.imgur.com/ahm7WDP.png" alt=""></p>
<h3 id="V-30-R-10"><a href="#V-30-R-10" class="headerlink" title="V = 30,R = 10"></a>V = 30,R = 10</h3><p><img src="https://i.imgur.com/msoiTEt.png" alt=""></p>
<h3 id="V-60-R-10"><a href="#V-60-R-10" class="headerlink" title="V = 60,R = 10"></a>V = 60,R = 10</h3><p><img src="https://i.imgur.com/GMwN3ne.png" alt=""></p>
<h3 id="V-90-R-10"><a href="#V-90-R-10" class="headerlink" title="V = 90,R = 10"></a>V = 90,R = 10</h3><p><img src="https://i.imgur.com/COqmz9g.png" alt=""></p>
<p>—&gt;</p>
<h3 id="5cm-靜止"><a href="#5cm-靜止" class="headerlink" title="5cm 靜止"></a>5cm 靜止</h3><p><img src="https://i.imgur.com/8vaA9aK.png" alt=""></p>
<h3 id="5cm-v-30"><a href="#5cm-v-30" class="headerlink" title="5cm v = 30"></a>5cm v = 30</h3><p><img src="https://i.imgur.com/J4V75C8.png" alt=""></p>
<h3 id="5cm-v-60"><a href="#5cm-v-60" class="headerlink" title="5cm v = 60"></a>5cm v = 60</h3><p><img src="https://i.imgur.com/tiYCIHI.png" alt=""></p>
<h3 id="5cm-v-90"><a href="#5cm-v-90" class="headerlink" title="5cm v = 90"></a>5cm v = 90</h3><p><img src="https://i.imgur.com/VicJL2Z.png" alt=""></p>
<h3 id="10cm-靜止"><a href="#10cm-靜止" class="headerlink" title="10cm 靜止"></a>10cm 靜止</h3><p><img src="https://i.imgur.com/J2CWmNY.png" alt=""></p>
<h3 id="10cm-v-30"><a href="#10cm-v-30" class="headerlink" title="10cm v = 30"></a>10cm v = 30</h3><p><img src="https://i.imgur.com/7kKEYQK.png" alt=""></p>
<h3 id="10cm-v-60"><a href="#10cm-v-60" class="headerlink" title="10cm v = 60"></a>10cm v = 60</h3><p><img src="https://i.imgur.com/DZzBP2p.png" alt=""></p>
<h3 id="10cm-v-90"><a href="#10cm-v-90" class="headerlink" title="10cm v = 90"></a>10cm v = 90</h3><p><img src="https://i.imgur.com/wQKB2kq.png" alt=""></p>
]]></content>
      <categories>
        <category>程式模擬</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>專題</tag>
      </tags>
  </entry>
  <entry>
    <title>DP例題</title>
    <url>/dp2/</url>
    <content><![CDATA[<h2 id="tioj-1354-池塘裡的青蛙"><a href="#tioj-1354-池塘裡的青蛙" class="headerlink" title="tioj-1354 池塘裡的青蛙"></a>tioj-1354 池塘裡的青蛙</h2><p><a href="https://tioj.ck.tp.edu.tw/problems/1354">題序</a><br>這是一個排列組合的數學題目，透過動態規劃紀錄小問題的答案<br><span id="more"></span></p>
<h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><p>定義$dp[i][0]$為跳i次不回到A的方法數，$dp[i][1]$為跳i次回到A的方法數</p>
<h3 id="轉移方式"><a href="#轉移方式" class="headerlink" title="轉移方式"></a>轉移方式</h3><ul>
<li>$dp[i][1]$ = $dp[i-1][0]$<br>應該不難理解，回到A的方法數為上一次不回到A的方法數 * 1</li>
<li>$dp[i][0] = 3\times dp[i-1][1]+2\times dp[i-1][0]$<br>不回到A可以分為2種情況，上一次回到A之後，可以往B,C,D，共三種情況。上一次不回到A的情況中，每一個都有兩個可以去的地方。<h3 id="邊界條件"><a href="#邊界條件" class="headerlink" title="邊界條件"></a>邊界條件</h3>$dp[0][1] = 0, dp[0][0] = 1$<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> dp[k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">3</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[k][<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h3><div class="note success">
            <p>這一題很討厭的，沒有給定測資的範圍，不然應該是可以直接建表然後用O(1)的複雜度求答案</p>
          </div>
</li>
</ul>
<h2 id="tioj-1019-Jumping-Up"><a href="#tioj-1019-Jumping-Up" class="headerlink" title="tioj-1019 Jumping Up"></a>tioj-1019 Jumping Up</h2><p><a href="https://tioj.ck.tp.edu.tw/problems/1019">題序</a></p>
<h3 id="定義-1"><a href="#定義-1" class="headerlink" title="定義"></a>定義</h3><p>定義 dp[i] 為第 0 個到第 i 個鈴鐺的最小移動水平距離總和</p>
<h3 id="轉移方式-1"><a href="#轉移方式-1" class="headerlink" title="轉移方式"></a>轉移方式</h3><p>令$a<em>0,a_1…a</em>{n-1}$為相對於螢幕正中央的水平位移，選擇跳一格或跳兩格。</p>
<p>$dp[i] = min(dp[i-1]+abs(a<em>i-a</em>{i-1}),dp[i-2]+abs(a<em>i-a</em>{i-2}))$</p>
<h3 id="邊界條件-1"><a href="#邊界條件-1" class="headerlink" title="邊界條件"></a>邊界條件</h3><p>$dp[0] = 0,$ $dp[1] = abs(a_1-a_0)$</p>
<h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T,N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;N;</span><br><span class="line">        <span class="keyword">int</span> arr[N+<span class="number">1</span>],dp[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;dp[<span class="number">1</span>] = <span class="built_in">abs</span>(arr[<span class="number">1</span>]-arr[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>]+<span class="built_in">abs</span>(arr[i]-arr[i<span class="number">-1</span>]),</span><br><span class="line">                        dp[i<span class="number">-2</span>]+<span class="built_in">abs</span>(arr[i]-arr[i<span class="number">-2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[N<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="複雜度-1"><a href="#複雜度-1" class="headerlink" title="複雜度"></a>複雜度</h3><div class="note info">
            <p>這一題$dp_i$只會跟前兩項有關係，好像可以用<strong>滾動DP</strong>來優化空間，可以以後嘗試看看！</p>
          </div>
<h2 id="tioj-1097-F-營地"><a href="#tioj-1097-F-營地" class="headerlink" title="tioj-1097 . F.營地"></a>tioj-1097 . F.營地</h2><p><a href="https://tioj.ck.tp.edu.tw/problems/1097">tioj1097題序</a><br><a href="https://leetcode.com/problems/maximal-square/">leetcode題序</a><br><img src="https://i.imgur.com/MTPZOnU.png" alt=""></p>
<h3 id="定義-2"><a href="#定義-2" class="headerlink" title="定義"></a>定義</h3><p>定義 <strong>dp[i][j]</strong> 為以索引(i,j)方格為正方形右下角所形成的最大正方形邊長</p>
<h3 id="轉移方式-2"><a href="#轉移方式-2" class="headerlink" title="轉移方式"></a>轉移方式</h3><p>$dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1$<br>看一個格字是否可以構成更大的正方形，要以它上方、左方、左上方的格子來決定（左、左上、上跟它自己剛好可以構成一個正方形）</p>
<h3 id="邊界條件-2"><a href="#邊界條件-2" class="headerlink" title="邊界條件"></a>邊界條件</h3><p>初始化為題目給定的0與1（0代表不能放、1表示可以放）</p>
<h3 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a>程式碼</h3><p>leetcode 221<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>(),col = matrix[<span class="number">0</span>].<span class="built_in">size</span>(),ans = <span class="number">0</span>;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                matrix[i][j]-=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>&amp;&amp; ans ==<span class="number">0</span>)ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    matrix[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(matrix[i<span class="number">-1</span>][j],matrix[i][j<span class="number">-1</span>]),</span><br><span class="line">                                       matrix[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                    ans = <span class="built_in">max</span>((<span class="keyword">int</span>)matrix[i][j],ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>tioj 1097<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> L,W,dp[<span class="number">2</span>][<span class="number">5005</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;W;k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">2</span>)dp[ind][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[ind][k] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[ind][k]==<span class="number">1</span>&amp;&amp;ans == <span class="number">0</span>)ans = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;L&gt;&gt;W)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L==<span class="number">0</span> &amp;&amp; W==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">input</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">input</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;W;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[<span class="number">1</span>][j] = <span class="built_in">min</span>(dp[<span class="number">0</span>][j],<span class="built_in">min</span>(dp[<span class="number">0</span>][j<span class="number">-1</span>],dp[<span class="number">1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,dp[<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;W;i++)dp[<span class="number">0</span>][i] = dp[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans*ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="複雜度-2"><a href="#複雜度-2" class="headerlink" title="複雜度"></a>複雜度</h3><div class="note info">
            <p>實作遇到的一些問題：</p><ol><li>陣列直接開空間複雜度會爆掉，所以要用到<strong>滾動DP</strong> （不然會MLE）</li><li>當i=0 與j=0 時會被忽略掉，如果只有在i=0 或j=0 出現1而其他都是0（不能放）的時候，就會出現答案為0的情況，在輸入時就要做修正</li><li>因為使用了滾動DP，所以在一開始會先輸入第一排，這時總共剩下L-1排，所以在第24行要是L-1次，才不會需要多輸入一行。</li></ol>
          </div>
<h2 id="1029-A遊戲"><a href="#1029-A遊戲" class="headerlink" title="1029  A遊戲"></a>1029  A遊戲</h2><p><a href="https://tioj.ck.tp.edu.tw/problems/1029">tioj1029</a><br><a href="https://">leetcode877</a></p>
<blockquote>
<p>有一串由N個正整數所組成的數列，兩個玩者輪流拿走一個最左邊或最右邊的數，直到最後所有的數都取完之後，兩個玩者分別把自己所取到數加總，分數較高的人獲勝。<br>範例輸入<br>6<br>4 7 2 9 5 2<br>輸出 18 11</p>
</blockquote>
<h3 id="定義-3"><a href="#定義-3" class="headerlink" title="定義"></a>定義</h3><p>這一題用到的是<a href="https://https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/dynamic_programming_2_inclass.pdf">區間DP</a><br>定義dp[i][j]為區間$[i,j]$中<strong>先手可以拿到的最大值</strong>，因為先後手拿的總和不變，所以<strong>後手</strong>在區間$[i,j]$ 可以拿到的最大值為 $sum[i,j]-dp[i][j]$。<br>同時，$dp[i][i] = arr[i]$    (先手取)</p>
<h3 id="轉移方式-3"><a href="#轉移方式-3" class="headerlink" title="轉移方式"></a>轉移方式</h3><p>由題目可知，先後手都是以最佳策略來玩這個遊戲，而區間$[l,r]$中先手在區間$[l+1,r]$ 中就變成後手（對手先拿），因此可以推得轉移式：</p>
<script type="math/tex; mode=display">dp[i][j] = max(sum[i+1,j]-dp[i+1][j]+arr[i],
                sum[i,j-1]-dp[i][j-1]+arr[j])</script><p>（第一項取最左邊，第二項代表取最右邊）<br><img src="https://i.imgur.com/3YlunPi.png" alt=""><br>以此圖為例，以i為橫軸代表出發點，j為縱軸代表終點，由上而下、由右而左依序把左下角的表格填滿。所求即為(i,j) = (1,6)。</p>
<h3 id="邊界條件-3"><a href="#邊界條件-3" class="headerlink" title="邊界條件"></a>邊界條件</h3><p>$dp[i][i] = arr[i]$</p>
<h3 id="程式碼-3"><a href="#程式碼-3" class="headerlink" title="程式碼"></a>程式碼</h3><p>上方的sum，可以透過表格儲存<strong>前綴和</strong>，快速求得<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>],pref[n+<span class="number">1</span>],arr[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    pref[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        dp[i][i] = arr[i];</span><br><span class="line">        pref[i] = pref[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(pref[j]-pref[i]-dp[i+<span class="number">1</span>][j]+arr[i],<span class="comment">//右格</span></span><br><span class="line">                           pref[j<span class="number">-1</span>]-pref[i<span class="number">-1</span>]-dp[i][j<span class="number">-1</span>]+arr[j]);<span class="comment">//上格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pref[n]-dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    for(int j=1;j&lt;n+1;j++)&#123;</span></span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;=n;i++)cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;//印出dp</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note success">
            <p><a href="https://leetcode.com/problemset/all/?search=stone%20game">Leetcode 877</a>這裡有一系列的stone game 變化題<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        piles.<span class="built_in">insert</span>(piles.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>],pref[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(pref,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pref));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][i] = piles[i];</span><br><span class="line">            pref[i] = pref[i<span class="number">-1</span>]+piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(pref[j]-pref[i]-dp[i+<span class="number">1</span>][j]+piles[i],</span><br><span class="line">                              pref[j<span class="number">-1</span>]-pref[i<span class="number">-1</span>]-dp[i][j<span class="number">-1</span>]+piles[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">1</span>][n]&gt;pref[n]/<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>這一題有一個數學解，可以保證答案一定是true。</p><blockquote><p>We can extend this idea to N piles. Say the first, third, fifth, seventh, etc. piles are white, and the second, fourth, sixth, eighth, etc. piles are black. Alex can always take either all white piles or all black piles, and one of the colors must have a sum number of stones larger than the other color.</p></blockquote><p>簡單來說，alex可以控制對方拿到的一定是白色堆或是黑色堆，因此只要在一開始選擇數量較大的顏色就保證可以贏得遊戲</p>
          </div></p>
<h3 id="複雜度-3"><a href="#複雜度-3" class="headerlink" title="複雜度"></a>複雜度</h3><p>$O(N^2)$<br><div class="note success">
            <p>這一題除了轉移式比較難想之外，要怎麼樣轉移也是一個問題。轉移方式可以透過小範圍測資試著找轉移的規律，如何轉移則可以透過畫表格的方式理解。</p>
          </div></p>
]]></content>
      <categories>
        <category>C++基礎主題</category>
        <category>動態規劃</category>
      </categories>
      <tags>
        <tag>C++基礎主題</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>計算幾何（Computational Geometry）</title>
    <url>/geo1/</url>
    <content><![CDATA[<p>暑假剩沒多少天了，趕緊追進度啊！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="座標與向量"><a href="#座標與向量" class="headerlink" title="座標與向量"></a>座標與向量</h3><ul>
<li>長度、角度、座標、向量</li>
<li>最常以座標、向量表示<span id="more"></span></li>
<li>Define x first, y second</li>
<li>內積Dot：$A \cdot B = A_xB_x+A_yB_y$</li>
<li>外積Cross：$A \times B = A_xB_y-A_yB_x$</li>
<li>運算子重載：加減乘除、取純量（$abs()$）</li>
</ul>
<h3 id="有向面積"><a href="#有向面積" class="headerlink" title="有向面積"></a>有向面積</h3><ul>
<li>用外積算面積（有正負：有向面積）</li>
<li>逆時針為正、順時針為負</li>
<li>多邊形面積：任選平面上一點A，將所有點與A連線</li>
<li>透過順、逆加總有向面積（p0,p1…pn,其中p0=pn）</li>
<li>AREA = $\frac{1}{2}\sum<em>{i=0}^{N-1}\vec{P_i}\times\vec{P</em>{i+1}}$</li>
</ul>
<h3 id="線段相交"><a href="#線段相交" class="headerlink" title="線段相交"></a>線段相交</h3><ul>
<li>線段不平行：$P_1$ 與$P_2$ 會在線段$P_3$、$P_4$異側（方向函數）</li>
<li>線段平行：檢驗是否共線、並確認某一個點是否在線段上</li>
</ul>
<h3 id="誤差分析：EPS"><a href="#誤差分析：EPS" class="headerlink" title="誤差分析：EPS"></a>誤差分析：EPS</h3><ul>
<li>使用二進位儲存：必產生誤差</li>
<li>精度：float $10^{-7}$, double $10^{-16}$, long double $10^{-19}$</li>
<li>誤差容忍值$eps$，將 $x\pm eps$視為 $x$</li>
<li>重載運算子：==（視為相等）,&gt;,&lt;，加上誤差範圍</li>
<li>Eps大小：多落在 $10^{-6}$到 $10^{-12}$ 之間</li>
<li>誤差：加減法，絕對誤差相加；乘除法，相對誤差相加</li>
<li>下界：數字範圍為V內時，$eps$ 至少要VK 乘上資料型態本身誤差</li>
<li>上界：題目一般會給</li>
<li>避免誤差大法：非到最後關頭，否則都用整數運算！</li>
</ul>
<h3 id="三角函數"><a href="#三角函數" class="headerlink" title="三角函數"></a>三角函數</h3><ul>
<li>泰勒展開式逼近，時間並非O(1)</li>
<li>$atan2(y,x) = \theta$，回傳值域$(-pi,pi]$</li>
<li>回傳long double ：使用$atan2l(y,x)$</li>
<li>常數大，不建議使用</li>
</ul>
<h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><ul>
<li>Sign, Exponent, Mantissa</li>
<li>正負號、指數部分、小數部分</li>
</ul>
<h3 id="極角排序"><a href="#極角排序" class="headerlink" title="極角排序"></a>極角排序</h3><ul>
<li>給定很多點，依照與某特定點（原點）的角度進行排序</li>
<li>Sort by cross，依照內積排序</li>
<li>題目：平面上n個點，問一條直線最多通過幾個點</li>
</ul>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><ul>
<li>多邊形：簡單多邊形（邊不相交）、凸多邊形（內角都≤180）、凹多邊形（有內角&gt;180）</li>
<li>能包住所有點的凸多邊形</li>
<li>凸包求法：Monotone Chain（二維平面）、DC（三維）</li>
<li><strong>Monotone Chain</strong><ul>
<li>將所有點按照(x,y)排序</li>
<li>把下凸包、上凸包「圍」出來</li>
<li>合併下凸包、上凸包</li>
<li>開一個vector（功能為stack）紀錄當前下半凸包</li>
<li>檢查新加入的點會讓哪些點不再是凸包上的點</li>
</ul>
</li>
</ul>
<h3 id="模擬退火-SA"><a href="#模擬退火-SA" class="headerlink" title="模擬退火(SA)"></a>模擬退火(SA)</h3><ul>
<li>尋找空間中近似最優解</li>
<li>一個隨機算法</li>
<li>例題：給你平面上 N 個點，請你找出一個點，使得這個點連到這 N 個點的距離總和最短</li>
</ul>
<h2 id="計算幾何函式模板"><a href="#計算幾何函式模板" class="headerlink" title="計算幾何函式模板"></a>計算幾何函式模板</h2><p>計算幾何最重要的莫過於座標上的點，實作方式可以用 $std::pair$ 或是自己定義一個類別，將點的資訊以及相關的運算式定義出來。我們總共需要重載點的大於、等於、小於的運算子，以及加法減法、向量外積內積等，同時還有很多功能是可以繼續定義下去，例如向量乘上一個定值，可以繼續加入類別中。</p>
<h3 id="點的模板及運算子重載"><a href="#點的模板及運算子重載" class="headerlink" title="點的模板及運算子重載"></a>點的模板及運算子重載</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-b.x)&lt;=eps &amp;&amp; <span class="built_in">abs</span>(y-b.y)&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上是預設點的x座標y座標都是整數的情況，如果要改成使用自定義型別，可以改用樣板(Template)自定義資料型別，根據題目的要求，使用整數或是浮點數進行運算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    T x,y;</span><br><span class="line">    <span class="comment">//下方運算子重載與上方相同</span></span><br><span class="line">&#125;</span><br><span class="line">pt&lt;<span class="keyword">int</span>&gt; p[N];        <span class="comment">//點座標宣告為整數</span></span><br><span class="line">pt&lt;<span class="keyword">double</span>&gt; pp[N];    <span class="comment">//點的不同資料型別宣告</span></span><br></pre></td></tr></table></figure>
<h3 id="方向函數"><a href="#方向函數" class="headerlink" title="方向函數"></a>方向函數</h3><p>針對 $\vec a$ 以及 $\vec b$ 外積的結果，可以知道兩者之間相對的方向。如果 $\vec a$ 和 $\vec b$ 共線，則回傳0，$\vec a$ 轉向 $\vec b$ 如果是順時針則回傳1，其餘回傳-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;                         <span class="comment">//方向函數</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="點與線段關係"><a href="#點與線段關係" class="headerlink" title="點與線段關係"></a>點與線段關係</h3><p>以下函式可以判斷點o是否在 $\overline{AB}$ 上，首先利用外積是否為0判斷是 $\overline{OA}$ 與 $\overline{OB}$ 是否平行；接著以內積判斷是否在線段中，而非線段的兩側（平行的條件下內積只可能是1或是-1）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;         <span class="comment">//o是否在ab線段上</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);    <span class="comment">//是否平行</span></span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);      <span class="comment">//是否在線段中</span></span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>)&amp;&amp;(dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="線段相交-1"><a href="#線段相交-1" class="headerlink" title="線段相交"></a>線段相交</h3><p>以下函式為給定四個點$A,B,C,D$，判斷 $\overline{AB}$ 是否相交於 $\overline{CD}$。首先是特例的判斷，線段的其中一端點在另一線段上，利用上方點與線段關係的函式完成這個判斷。</p>
<p>特例判斷完成之後，我們需要用到上方方向函式判斷線段兩端點是否在另一條線段的異側，即以下的關係式：</p>
<script type="math/tex; mode=display">dir(A,B,C)\times dir(A,B,D) < 0</script><p>我們要檢查兩條線段，其相乘結果必須皆為負數，表示處於線段的異側！最後是平行線的判斷，如果兩線平行且相交，表示兩線共線，這可以在特例時就被判斷出來。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(pt a, pt b, pt c, pt d)</span></span>&#123;      <span class="comment">//線段ab是否與cd相交</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c)||<span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點c、d是否洽在線段ab上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a)||<span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點a、b是否洽在線段cd上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c)*<span class="built_in">dir</span>(a,b,d)==<span class="number">-1</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a)*<span class="built_in">dir</span>(c,d,b)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">//對於線段兩端點看另外兩端點必須方向相反</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="極角排序-1"><a href="#極角排序-1" class="headerlink" title="極角排序"></a>極角排序</h3><p>在進行全點對線段共線問題的判斷時，使用極角排序通常會比單純暴力枚舉更快速。極角也就是極座標中每一個跟原點的夾角。如果兩個點位在左半平與右半平面，則先將其判斷出來，如此才能確定起始的角度為何。</p>
<p>如果位在同一個左右半平面，則透過外積的方式比較兩個向量的先後順序。以下程式碼是從座標平面270度的地方開始逆時針掃一圈依序經過的點。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f1 = a &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> f2 = b &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)<span class="keyword">return</span> f1 &lt; f2;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆時針將點進行極角排序，從270度開始逆時針</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);     <span class="comment">//以id為原點進行極角排序</span></span><br></pre></td></tr></table></figure>
<h3 id="凸包函數（使用Monotone-Chain）"><a href="#凸包函數（使用Monotone-Chain）" class="headerlink" title="凸包函數（使用Monotone Chain）"></a>凸包函數（使用Monotone Chain）</h3><p>首先先將所有點依照x座標進行排序，之後用掃描線由左而右的將符合要求的點推入維護的單調容器中，維護下凸包，接著利用reverse()函數將所有點逆序，也就是x座標由大到小讓掃描線由右而左掃過一遍，將上凸包也圍起來。時間複雜度為$O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa ^ bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; hull;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;                       <span class="comment">//起點會經過兩次，剛好來算有向面積</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋轉卡尺"><a href="#旋轉卡尺" class="headerlink" title="旋轉卡尺"></a>旋轉卡尺</h3><p>旋轉卡尺可以被應用在尋找最遠點對、面積最大三角形等問題。利用兩條平行的線中間夾著凸包，繞一圈的過程中更新需要求的數值。實作上來說就是使用兩個指針，分別指向旋轉卡尺的平行線所在的兩個點，依照旋轉的方向進行增減的動作！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa = <span class="built_in">abs</span>((a - c)^(b - c));</span><br><span class="line">    <span class="keyword">int</span> bb = <span class="built_in">abs</span>((a - d)^(b - d));</span><br><span class="line">    <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,d = h,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">check2</span>(hull[i],hull[(i+<span class="number">1</span>)%sz],hull[d],hull[(d+<span class="number">1</span>)%sz]))</span><br><span class="line">            d = (d+<span class="number">1</span>)%sz;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,(hull[i]-hull[d]).<span class="built_in">dis</span>());</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,(hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本數學知識"><a href="#基本數學知識" class="headerlink" title="基本數學知識"></a>基本數學知識</h2><p>計算幾何圍繞著幾個主軸，向量運算、內積、外積，利用它們進行角度、共線與否、距離等等的判斷。之前有稍微接觸過向量，不過內積與外積是第一次碰到的主題。</p>
<p>因為目前絕大部分的討論都是在二維平面上進行，因此以下都是以二維平面為前提所進行的討論！</p>
<h3 id="內積（點積）"><a href="#內積（點積）" class="headerlink" title="內積（點積）"></a>內積（點積）</h3><p>內積跟 $\cos\theta$ 有關，因此主要可以幫助我們判斷線段是否垂直（等於零）、以及共線時點位於正向或是反向的判斷（等於正負一）。兩個向量 $\vec u$ 以及 $\vec v$ 的內積可以寫成以下關係式：</p>
<script type="math/tex; mode=display">\vec u\cdot \vec v = |\vec u||\vec v|\cos\theta = u_1v_1 + u_2v_2</script><p>兩個向量做內積的正負號會跟餘弦函數的正負變化相同（如下圖），值域為 $[-|\vec u||\vec v|,|\vec u||\vec v|]$，並且在 $\theta = 0,\pi$ 有最大最小值，$\theta = \frac{\pi}{2},\frac{3\pi}{2}$ 的值為零。</p>
<p><img src="https://i.imgur.com/Si0hlNr.png" alt=""></p>
<h3 id="外積（叉積）"><a href="#外積（叉積）" class="headerlink" title="外積（叉積）"></a>外積（叉積）</h3><p>外積跟 $\sin\theta$ 有關，主要可以判斷兩向量方向關係（順逆時針旋轉）、是否平行、比較角度大小等。外積的應用十分廣泛，找凸包以及旋轉卡尺都會用到外積判斷兩個向量角度關係。兩個向量 $\vec u$ 以及 $\vec v$ 的外積可以寫成以下關係式：</p>
<script type="math/tex; mode=display">\vec u\times \vec v = |\vec u||\vec v|\sin\theta = \begin{bmatrix}u_1&u_2\\v_1&v_2\end{bmatrix}=u_1v_2 - u_2v_1</script><p>用更簡單的方式理解外積 $\vec u\times \vec v$ ，其正負值可以想像成 $\vec u$ 轉向 $\vec v$ 所經的劣弧順逆時鐘方向。順時針為正、逆時針為負。</p>
<p>關於外積的數值變化，與正弦函數的變化是一樣的（下圖），其值域跟內積一樣，不過最大最小值發生在 $\theta = \frac{\pi}{2},\frac{3\pi}{2}$，並在 $\theta = 0,\pi$ 時兩向量叉積為零。</p>
<p><img src="https://i.imgur.com/ozKfaKL.png" alt=""></p>
<h3 id="面積"><a href="#面積" class="headerlink" title="面積"></a>面積</h3><h4 id="測量師公式（行列式）"><a href="#測量師公式（行列式）" class="headerlink" title="測量師公式（行列式）"></a>測量師公式（行列式）</h4><p>這是一個從給定多邊形的座標推得面積的公式，寫成很多個三角形有向面積的總和。以下圖來說，$\triangle FBC$、$\triangle FCD$ 、$\triangle FDE$ 的有向面積皆大於零，而 $\triangle FAB$、$\triangle FEA$ 都會因為有向面積是負的（逆時針旋轉）而被扣除掉，運算的總和即是多邊形 $ABCDE$ 的面積！</p>
<p><img src="https://i.imgur.com/did2OzY.png" alt=""></p>
<p>一般化的公式，多邊形上總共有 $N$ 個點，令第 $N+1$ 個點為第1個點（為了要繞一圈計算面積），多邊形面積為：</p>
<script type="math/tex; mode=display">AREA = \frac{1}{2}\sum_{i=1}^{N}\vec{P_i}\times\vec{P_{i+1}}</script><h4 id="三角形外積面積公式"><a href="#三角形外積面積公式" class="headerlink" title="三角形外積面積公式"></a>三角形外積面積公式</h4><p>三角形面積有非常多算法，不過利用外積的公式還是第一次聽到。以下是公式推導過程：</p>
<p>先從高中三角函數的三角形公式開始：</p>
<script type="math/tex; mode=display">\begin{split}\triangle ABC &= \frac{1}{2}\overline{AB}\,\overline{AC}\cdot\sin A
\\&=\frac{1}{2}\sqrt{\overline{AB}^2\,\overline{AC}^2\,(1-\cos^2A)}
\\&=\frac{1}{2}\sqrt{\overline{AB}^2\,\overline{AC}^2-(\overline{AB}\cdot\overline{AC})^2}
\\&=\frac{1}{2}\sqrt{(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1\,x_2+y_1\,y_2)^2}
\\&=\frac{1}{2}\sqrt{(x_1^2\,y_2^2)+(x_2^2\,y_1^2)-2x_1\,y_2\,x_2\,y_1}
\\&=\frac{1}{2}\sqrt{[(x_1\,y_2)-(x_2\,y_1)]^2}
\\&=\frac{1}{2}|\overrightarrow{AB}\times \overrightarrow{AC}|\end{split}</script><p>將三角形其中一點對另外兩點的向量做外積，除以2即為三角形面積。這個公式會在旋轉卡尺的地方使用到！</p>
<h4 id="平行四邊形面積"><a href="#平行四邊形面積" class="headerlink" title="平行四邊形面積"></a>平行四邊形面積</h4><p>根據上面三角形面積公式的推導，可以相對應得知道兩向量所夾平行四邊形面積公式：</p>
<script type="math/tex; mode=display">AREA = |\overrightarrow{AB}\times \overrightarrow{AC}|</script><p><img src="https://i.imgur.com/9mUdyV6.png" alt=""></p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>計算幾何</category>
      </categories>
      <tags>
        <tag>計算幾何</tag>
        <tag>暑期筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>橢圓軌道上行星到太陽平均距離</title>
    <url>/gravity2/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>克卜勒第三運動定律說明公轉週期的平方與行星到太陽的平均距離三次方成正比。若是行星以橢圓軌道繞行太陽，則行星到太陽的平均距離 $\overline d$ 會是近日點距 $r_1$ 加上遠日點距 $r_2$ 的平均，也就是橢圓的半長軸，讓我十分好奇該如何證明這件事！</p>
<script type="math/tex; mode=display">\overline d = \frac{r_1+r_2}{2} = a</script><p>所要做的是就是將橢圓圓周上的每一點，到太陽的距離進行積分後取平均。</p>
<span id="more"></span>
<p><img src="https://i.imgur.com/vJtmR1W.png" alt=""></p>
<h2 id="數學證明"><a href="#數學證明" class="headerlink" title="數學證明"></a>數學證明</h2><p>定義連續函數$f(x)$在$[a,b]$區間上的平均值為：</p>
<script type="math/tex; mode=display">f_{ave} = \frac{1}{b-a}\int_{a}^{b} f(x) dx</script><p>在一個以原點為中心的橢圓周上有一點$P$，其參數式可以表示成$P(a\cos\theta,b\sin\theta)$，其中 $a,b$ 為半長軸、半短軸。令太陽的座標為橢圓的其中一個焦點$S(-c,0)$，如下圖：</p>
<p><img src="https://i.imgur.com/b4PWR3b.png" alt=""></p>
<p>則橢圓周上每一點$P$到太陽$S$的距離可以表示為：</p>
<script type="math/tex; mode=display">f(x) = \overline{PS} = \sqrt{(a\cos(x)+c)^2+(b\sin( x))^2}</script><p>如此一來就可以對$f(\theta)$在$[0,2\pi]$區間內取平均值：</p>
<script type="math/tex; mode=display">\begin{align}f_{ave} &= \frac{1}{2\pi}\int_0^{2\pi} f(x)dx\\
&=\frac{1}{2\pi}\int_0^{2\pi}{\sqrt{(a\cos(x)+c)^2+(b\sin(x))^2}}\ dx\\
&=\frac{1}{2\pi}\int_0^{2\pi}{\sqrt{a^2\cos^2(x)+2ac\cdot\cos(x)+(a^2-c^2)\cdot\sin^2(x)+c^2}\ }dx\\
&=\frac{1}{2\pi}\int_0^{2\pi}{\sqrt{c^2\cos^2(x)+2ac\cos(x)+a^2}}\ dx\\
&=\frac{1}{2\pi}\int_0^{2\pi}{(c\cdot\cos(x)+a)}\ dx\\
&=\frac{1}{2\pi}[c\int_0^{2\pi}{\cos(x)}\ dx+\int_0^{2\pi}a\ dx]\\
&=\frac{1}{2\pi}\cdot(0 + 2\pi a)\\
&=a
\end{align}</script><p>得證橢圓軌道上地球到太陽的平均距離為半軸長！</p>
<h2 id="程式實作"><a href="#程式實作" class="headerlink" title="程式實作"></a>程式實作</h2><p>這次主要是以程式實作積分，透過將角度切成很小塊再疊加起來取平均，得到函數的平均值。以下影片中的橢圓$a = 13,b = 5,c = 12$，透過將角度切成30度、15度、1度、0.5度觀察疊加的狀況。</p>
<h3 id="角度-30度"><a href="#角度-30度" class="headerlink" title="角度 = 30度"></a>角度 = 30度</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/gb37pmX-P6w" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<h3 id="角度-15度"><a href="#角度-15度" class="headerlink" title="角度 = 15度"></a>角度 = 15度</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/hWMe3eOZVyU" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<h3 id="角度-1度"><a href="#角度-1度" class="headerlink" title="角度 = 1度"></a>角度 = 1度</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/OpcFig66emQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<h3 id="角度-0-5度"><a href="#角度-0-5度" class="headerlink" title="角度 = 0.5度"></a>角度 = 0.5度</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/2C0RBenG2yg" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<p>這四個影片加起來的平均值都是半長軸$a$！</p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>物理筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Manim學習筆記</title>
    <url>/manim/</url>
    <content><![CDATA[<h2 id="Manim安裝"><a href="#Manim安裝" class="headerlink" title="Manim安裝"></a>Manim安裝</h2><blockquote>
<p>Manim is an animation engine for explanatory math videos.</p>
</blockquote>
<p>利用Manim可以生成許多數學類的動畫影片、以及製作一些動畫模擬！</p>
<p>我是利用Mac安裝Manim，只要按照<a href="https://docs.manim.community/en/stable/installation/macos.html">這一篇</a>的說明一步步完成即可，不要上網找教學影片，因為很多都是過時的，在安裝上會出現一些問題。</p>
<p>至於使用教學的部分，可以參考這一篇<a href="https://docs.manim.community/en/stable/index.html">官方使用手冊</a>。Manim總共有三種版本，建議使用Manim Community比較方便，資源比較多！</p>
<span id="more"></span>
<h2 id="語法筆記"><a href="#語法筆記" class="headerlink" title="語法筆記"></a>語法筆記</h2><h3 id="架構程式碼"><a href="#架構程式碼" class="headerlink" title="架構程式碼"></a>架構程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#程式碼區塊</span></span><br></pre></td></tr></table></figure>
<h3 id="終端指令"><a href="#終端指令" class="headerlink" title="終端指令"></a>終端指令</h3><ul>
<li><strong>mp4</strong>:    <code>manim test.py Test -pqm</code></li>
<li><strong>gif</strong>: <code>manim test.py Test -pqm -i</code></li>
</ul>
<p>影片品質設定：<code>-pql,-pqm,-pqh</code></p>
<h3 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        rec = Rectangle(color = WHITE,width = <span class="number">2</span>,height = <span class="number">2.5</span>).to_edge(UL)</span><br><span class="line">        circ = Circle().to_edge(DOWN)</span><br><span class="line">        arr = always_redraw(</span><br><span class="line">            <span class="keyword">lambda</span>: Line(</span><br><span class="line">                start = rec.get_bottom(),end = circ.get_top(),buff = <span class="number">0.5</span></span><br><span class="line">            ).add_tip()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.play(Create(VGroup(rec,circ,arr)))</span><br><span class="line">        self.wait()</span><br><span class="line">        self.play(rec.animate.to_edge(UR),circ.animate.scale(<span class="number">0.5</span>),run_time = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Value-Tracker"><a href="#Value-Tracker" class="headerlink" title="Value Tracker"></a>Value Tracker</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Updaters</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line">        </span><br><span class="line">        k = ValueTracker(<span class="number">0</span>)</span><br><span class="line">        num = always_redraw(</span><br><span class="line">            <span class="keyword">lambda</span>: DecimalNumber().set_value(k.get_value())</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.play(FadeIn(num))</span><br><span class="line">        self.play(k.animate.set_value(<span class="number">10</span>),run_time = <span class="number">5</span>,rate_func = smooth)</span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure>
<h3 id="NumberPlane"><a href="#NumberPlane" class="headerlink" title="NumberPlane"></a>NumberPlane</h3><p>注意：<code>get_graph() —&gt; plot()</code><br>自動排版：<code>alt + shift + f</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        plane = (</span><br><span class="line">            NumberPlane(x_range=[-<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>], x_length=<span class="number">8</span>,</span><br><span class="line">                        y_range=[-<span class="number">4</span>, <span class="number">20</span>, <span class="number">5</span>], y_length=<span class="number">8</span>)</span><br><span class="line">            .to_edge(DOWN)</span><br><span class="line">            .add_coordinates()</span><br><span class="line">        )</span><br><span class="line">        l = plane.get_axis_labels(x_label=<span class="string">&#x27;x&#x27;</span>, y_label=<span class="string">&#x27;f(x)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        par = plane.plot(<span class="keyword">lambda</span> x: (<span class="number">0.5</span>*x) ** <span class="number">2</span>,</span><br><span class="line">                         x_range=[-<span class="number">10</span>, <span class="number">10</span>], color=GREEN)</span><br><span class="line"></span><br><span class="line">        func_l = MathTex(<span class="string">&quot;f(x) = &#123;x&#125;^2&quot;</span>).next_to(par, RIGHT).set_color(GREEN)</span><br><span class="line"></span><br><span class="line">        area = plane.get_riemann_rectangles(</span><br><span class="line">            graph=par, x_range=[-<span class="number">5</span>, <span class="number">5</span>], dx=<span class="number">1</span>, stroke_width=<span class="number">0.1</span>, stroke_color=WHITE)</span><br><span class="line"></span><br><span class="line">        self.play(DrawBorderThenFill(plane), run_time=<span class="number">2</span>)</span><br><span class="line">        self.play(Create(VGroup(par, l, func_l)), run_time=<span class="number">2</span>)</span><br><span class="line">        self.wait()</span><br><span class="line">        self.play(Create(area))</span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure>
<h3 id="ValueTrackers-to-Graphing-Scenes"><a href="#ValueTrackers-to-Graphing-Scenes" class="headerlink" title="ValueTrackers to Graphing Scenes"></a>ValueTrackers to Graphing Scenes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        k = ValueTracker(-<span class="number">4</span>)</span><br><span class="line">        ax = Axes(x_range=[-<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>], y_range=[-<span class="number">2</span>, <span class="number">16</span>, <span class="number">2</span>],</span><br><span class="line">                  x_length=<span class="number">5</span>, y_length=<span class="number">5</span>).to_edge(DOWN).add_coordinates()</span><br><span class="line">        func = ax.plot(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, x_range=[-<span class="number">4</span>, <span class="number">4</span>], color=BLUE)</span><br><span class="line">        slope = always_redraw(</span><br><span class="line">            <span class="keyword">lambda</span>: ax.get_secant_slope_group(</span><br><span class="line">                graph=func, dx=<span class="number">0.01</span>, x=k.get_value(), secant_line_color=GREEN, secant_line_length=<span class="number">5</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        pt = always_redraw(</span><br><span class="line">            <span class="keyword">lambda</span>:</span><br><span class="line">            Dot().move_to(ax.c2p(k.get_value(), func.underlying_function(k.get_value())))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.add(ax, func, slope, pt)</span><br><span class="line">        self.wait()</span><br><span class="line">        self.play(k.animate.set_value(<span class="number">4</span>), run_time=<span class="number">10</span>)</span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure>
<h3 id="Open-a-file"><a href="#Open-a-file" class="headerlink" title="Open a file"></a>Open a file</h3><p><strong>1. svg file:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">H = <span class="string">&quot;/Users/peienwu/Downloads/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line">        Icon = SVGMobject(<span class="string">f&quot;<span class="subst">&#123;H&#125;</span>//test.svg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.play(FadeIn(Icon))</span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure>
<p><strong>2. png file:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line">        Icon = ImageMobject(<span class="string">f&quot;/Users/peienwu/Downloads/minion.jpeg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.play(FadeIn(Icon))</span><br><span class="line">        self.wait()</span><br><span class="line">        self.play(Icon.animate.to_edge(LEFT))</span><br></pre></td></tr></table></figure>
<h3 id="Bar-chart"><a href="#Bar-chart" class="headerlink" title="Bar chart"></a>Bar chart</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyclbr <span class="keyword">import</span> Function</span><br><span class="line"><span class="keyword">from</span> manim <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DifferentRotations</span>(<span class="params">Scene</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">self</span>):</span></span><br><span class="line">        num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">        ver = [<span class="string">&quot;v1.0&quot;</span>, <span class="string">&quot;v2.0&quot;</span>, <span class="string">&quot;v3.0&quot;</span>, <span class="string">&quot;v4.0&quot;</span>, <span class="string">&quot;v5.0&quot;</span>]</span><br><span class="line"></span><br><span class="line">        r = BarChart(</span><br><span class="line">            num,</span><br><span class="line">            max_value=<span class="built_in">max</span>(num),</span><br><span class="line">            bar_names=ver,</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">        self.play(Create(r), run_time=<span class="number">2</span>)</span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure>
<h2 id="影片成果"><a href="#影片成果" class="headerlink" title="影片成果"></a>影片成果</h2><ul>
<li>文章：<a href="https://peienwu.com/2022/02/07/Bertrand_Paradox/#more">Bertrand Paradox</a></li>
<li>文章：<a href="https://peienwu.com/2022/04/21/%E6%A9%A2%E5%9C%93%E8%BB%8C%E9%81%93%E4%B8%8A%E8%A1%8C%E6%98%9F%E5%88%B0%E5%A4%AA%E9%99%BD%E5%B9%B3%E5%9D%87%E8%B7%9D%E9%9B%A2/">橢圓軌道上行星到太陽平均距離</a></li>
<li>影片：<a href="https://www.youtube.com/channel/UC9ioraLAwW20eSupf2-e6Dw">Youtube頻道</a></li>
</ul>
]]></content>
      <categories>
        <category>程式模擬</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>Manim</tag>
      </tags>
  </entry>
  <entry>
    <title>婚姻匹配問題（Stable Marriage Problem）</title>
    <url>/marriage/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>對於婚姻匹配問題有以下描述。</p>
<blockquote>
<p>Given n men and n women, where each person has ranked all members of the opposite sex in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners.</p>
<p>When there are no such pairs of people, the set of marriages is deemed stable.<br><span id="more"></span><br>在所有婚姻狀態均「穩定」的已婚社群，每對婚姻中的男、女，各自都無法找到更心儀的、喜歡他、她甚於喜歡自己配偶的對象。換句話說，男人即使心中有他認為比太太更好的女人，這女人也不會認為他比自己的先生好。同樣地，女人心中即使有她認為比先生更好的男人，這男人也不會認為她比自己的太太好。</p>
</blockquote>
<p>下圖為四男（小寫字母）以及四女（大寫字母）對異性的偏好順序，第一格代表男生對女生的偏好順序，第二格則代表女生對男生的偏好順序。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">1,3</td>
<td style="text-align:center">2,3</td>
<td style="text-align:center">3,2</td>
<td style="text-align:center">4,3</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">1,4</td>
<td style="text-align:center">4,1</td>
<td style="text-align:center">3,3</td>
<td style="text-align:center">2,2</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">2,2</td>
<td style="text-align:center">1,4</td>
<td style="text-align:center">3,4</td>
<td style="text-align:center">4,1</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">4,1</td>
<td style="text-align:center">2,2</td>
<td style="text-align:center">3,1</td>
<td style="text-align:center">1,4</td>
</tr>
</tbody>
</table>
</div>
<p>我們發現到只有$(a,C),(b,D),(c,A),(d,B)$是唯一一組穩定的配對，對於其他的配對必可找到一對男女喜歡彼此的程度勝過對原本的伴侶。</p>
<h2 id="Gale-Shapley-Algorithm（男方求婚法）"><a href="#Gale-Shapley-Algorithm（男方求婚法）" class="headerlink" title="Gale-Shapley Algorithm（男方求婚法）"></a>Gale-Shapley Algorithm（男方求婚法）</h2><p>演算法步驟如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有男生各自向他們最喜歡的女生求婚;</span><br><span class="line">每當（有女生被兩個以上的男生求婚）</span><br><span class="line">&#123;    這個女生暫時保留所有求婚者中她最喜歡的一個，而拒絕其他人；</span><br><span class="line">     被拒絕的男生退而求其次，向不曾拒絕過他的人當中最喜歡的女生求婚；&#125;</span><br></pre></td></tr></table></figure>
<h3 id="數學證明"><a href="#數學證明" class="headerlink" title="數學證明"></a>數學證明</h3><h4 id="小觀察"><a href="#小觀察" class="headerlink" title="小觀察"></a>小觀察</h4><p>如果是男生不斷向女生求婚，則有以下的觀察：</p>
<ol>
<li>一個女生一旦訂婚，她對訂婚對象的喜好程度會不斷增加。</li>
<li>一個男生一旦訂婚，他對訂婚對象的喜好程度會不斷下降。</li>
</ol>
<h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><ol>
<li><p>Gale-Shapley Algorithm 的結果必定是<strong>完美配對</strong>。</p>
<div class="note success">
            <p>注意到每一個女生最多只會拒絕$n-1$個男生（必定留下一個），這時候每個女生都一定會被求婚過，否則，因為每一個女生只會暫時接受一個求婚者，一定還有一個未被接受的男生還可以向某一位女生求婚。</p>
          </div>
</li>
<li><p>Gale-Shapley Algorithm 的結果必定是<strong>穩定的</strong>。</p>
<div class="note success">
            <p>假設這個匹配裡出現不穩定配對，不失一般性假設是$(a,B)$，其中 $a$ 喜歡 $B$ 勝過於他的配偶 $A$，而 $B$ 喜歡 $a$ 多過他的配偶 $b$。由於 $a$ 比較喜歡 $B$，他必定曾經向 $B$ 求婚過，但最後沒有和 $B$ 配對，表示 $a$ 被拒絕而當時 $B$ 身旁是有一個求婚者是 $B$ 比較喜歡的，因此這個求婚者在 $B$ 的排行中也優先於 $b$ （優先於 $a$ 因而優先於 $b$），根據觀察一，不可能最後 $B$ 跟 $b$ 配對在一起（女生對訂婚對象喜好程度只會不斷增加），矛盾。</p>
          </div>
</li>
</ol>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p>根據引理1,2，我們知道 Gale-Shapley Algorithm 輸出的匹配必定是完美配對且不存在不穩定配對。根據定義，得證。</p>
<h4 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h4><p>證明算法的複雜度為：$O(n^2)$。</p>
<ol>
<li>總共不會超過 $n^2$ 個求婚要求：每個男生只會對一個女生求婚最多一次，總共有 $n$ 個女生，因此最多有 $n^2$ 個求婚要求。</li>
<li>對於每一個求婚要求以 $O(1)$ 處理：可以藉由一個二維陣列 $O(1)$ 比較女生對男生的喜好程度，同時維護一個佇列使我們能 $O(1)$ 取得男生要下一個要配對的女生。</li>
</ol>
<p>得證 Gale-Shapley Algorithm 的複雜度是 $O(n^2)$。</p>
<h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3616">題目連結</a></p>
<p>這題是女生求婚法。</p>
<p>比較難處理的部分是輸入，其他就照著虛擬碼執行算法。在以下程式碼中，我們使用<em>cur_que</em>放入尚未成功配對的女生，每一個女生下一個要配對的男生則儲存在<em>que</em>中，並利用<em>Man</em>記錄男生目前配對到的女生。</p>
<p>執行完演算法之後，利用反函數找出<em>Man</em>女生配對到的男生並輸出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ff first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">pii P[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">gale_shapley</span><span class="params">(queue&lt;<span class="keyword">int</span>&gt; *q)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; cur_que;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; Man;Man.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cur_que.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!cur_que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> woman = cur_que.<span class="built_in">front</span>(),man = q[woman].<span class="built_in">front</span>();</span><br><span class="line">        q[woman].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!Man[man])&#123;</span><br><span class="line">            Man[man] = woman;</span><br><span class="line">            cur_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(P[woman][man].ss &lt; P[Man[man]][man].ss)&#123;</span><br><span class="line">            cur_que.<span class="built_in">push</span>(Man[man]);</span><br><span class="line">            Man[man] = woman;</span><br><span class="line">            cur_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Man;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            P[i][temp].ff = j;</span><br><span class="line">            q[i].<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            P[temp][i].ss = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans[N];</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; Man = <span class="built_in">gale_shapley</span>(q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ans[Man[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(t)cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延伸問題"><a href="#延伸問題" class="headerlink" title="延伸問題"></a>延伸問題</h2><ol>
<li>證明男方求婚法會給出男性的最佳匹配。</li>
<li>如何有效率的找出所有可能的穩定匹配？</li>
<li>承上，根據Wiki所述，試證明$n$男$n$女穩定匹配數的平均會漸進於$e^{-1}n\ln n$。</li>
<li>證明找出穩定匹配數的問題是一個<a href="https://en.wikipedia.org/wiki/%E2%99%AFP-complete">#P-complete</a>的問題。</li>
</ol>
<p>下圖是男女對數$n$跟穩定匹配數$S$的關係圖，其增長的速度與$n\ln n$同級：<br><img src="https://i.imgur.com/phjJi3v.png" alt=""></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm">Wiki:Gale–Shapley Algorithm</a></p>
<p><a href="https://web.ntnu.edu.tw/~algo/Matching2.html">演算法筆記:Matching</a></p>
<p><a href="https://ur.booksc.eu/book/4740030/49e7a5">Michael Dzierzawa, Marie-José Oméro, Statistics of stable marriages, Physica A 287 (1–2) (2000) 321–333</a></p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>三門問題（Monty Hall Problem）</title>
    <url>/monty-hall/</url>
    <content><![CDATA[<p><strong>三門問題</strong>，或<strong>蒙提霍爾問題</strong>是一個違反直覺的條件機率問題，本文將從不同角度切入，探討不同選擇的機率大小。</p>
<h2 id="問題敘述"><a href="#問題敘述" class="headerlink" title="問題敘述"></a>問題敘述</h2><p><a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=47158">資料來源</a><br><a href="https://www.youtube.com/watch?v=iBdjqtR2iK4">影片網址</a><br>在 2008 年上映的美國電影《決勝21點》中，劇中主角班 (Ben Campbell)在非線性代數的課堂上與授課教授米奇(Mickey Rosa) 有一段精彩的對話：</p>
<blockquote>
<p>米奇：「假設你正參加一個遊戲節目，你有機會從三扇不同的門裡選一扇，其中一扇門後面有一輛新車，另外兩扇門後面各有一頭山羊？你要選擇哪一扇門？」</p>
<p>班：  「一號門。」<br><span id="more"></span></p>
<p>米奇：「好！這時節目主持人，順便一提，他知道門後的秘密，他去打開另一扇門，比方說他開了三號門，後面是一頭山羊。這時節目主持人說：「班，你想要堅持選擇一號門，還是換成二號門？」現在問題是–改變選擇(換另一扇門)是否對你有利?」</p>
<p>班：  「是的」</p>
<p>米奇：「記住！主持人知道那輛車在哪裡，你怎麼知道他不是在耍你？……」</p>
<p>班：  「我並不介意，因為我的答案是基於統計學，……，當一開始他讓我選一扇門時，我有 33.3% 的機率是選對的，但當他開其中一扇門時，然後又讓我選時，此刻如果我選擇換一扇門，選對的機率是 66.7%，……。」</p>
</blockquote>
<p>換句話說，假設你正在參加一個游戲節目，你被要求在三扇門中選擇一扇：其中一扇後面有一輛車；其餘兩扇後面則是山羊。你選擇了一道門，假設是一號門，<strong>然後知道門後面有什麼的主持人</strong>，開啟了另一扇後面有山羊的門，假設是三號門。他然後問你：「你想選擇二號門嗎？」轉換你的選擇對你來說是一種優勢嗎？</p>
<hr>
<p>答案：<strong>換門</strong>贏得獎品的機率為$\frac{2}{3}$，<strong>不換門</strong>為$\frac{1}{3}$，因此<font color="#f00">應該選擇換門！</font></p>
<p>這個問題可以擴展成N門問題，也就是主持人在開了$N-2$道門以後，分析換門與不換門贏得汽車的機率。</p>
<h2 id="條件機率：貝式定理"><a href="#條件機率：貝式定理" class="headerlink" title="條件機率：貝式定理"></a>條件機率：貝式定理</h2><p>在條件機率中，以$P(A|B)$表示在B發生的條件下A發生的機率，其值：</p>
<script type="math/tex; mode=display">P(A|B)=\frac{P(A\cap B)}{P(B)}</script><p>我們還可以畫出以下樹狀圖做分析：<br><img src="https://i.imgur.com/nfOcm7U.png" alt=""><br>假設 $A$ 為得獎的情況，$A’$ 為不得獎的情況，$B$ 為換門的情況，$B’$ 為不換門的情況<br>如果要得獎會發生以下兩種狀況：</p>
<ol>
<li>不換門得獎：$P(A|B’)=\frac{\frac{1}{6}}{\frac{1}{6}+\frac{1}{3}}=\frac{1}{3}\cong 0.33$</li>
<li>換門得獎：$P(A|B)=\frac{\frac{1}{3}}{\frac{1}{6}+\frac{1}{3}}=\frac{1}{3}\cong 0.66$</li>
</ol>
<p>從貝式定律可以得到，換門的機率比較高！</p>
<h2 id="窮舉法（列表觀察）"><a href="#窮舉法（列表觀察）" class="headerlink" title="窮舉法（列表觀察）"></a>窮舉法（列表觀察）</h2><p>我們也可以透過列表得到相同的結論，在下表中假設「選中」為參與者第一次選中的門，「開門」則是主持人打開的有山羊的門，「換門」則是剩下的那個門</p>
<p>這邊可能會有一個疑惑（如果沒有那不要理我XD）：<br>當我第一次選中有車的門時為什麼只有列一次，主持人不是可以選擇打開兩個有山羊的門其中一個，不應是兩種狀況？</p>
<p>只有一種是因為後面有車的門觀眾只會選到一次，不像山羊觀眾可以選兩次，並且主持人打開哪一道門實際是沒有影響，都視為同一種狀況！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>新車</th>
<th>山羊</th>
<th>山羊</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>選中</td>
<td>開門</td>
<td>換門</td>
<td>不換門贏</td>
</tr>
<tr>
<td>換門</td>
<td>選中</td>
<td>開門</td>
<td>換門贏</td>
</tr>
<tr>
<td>換門</td>
<td>開門</td>
<td>選中</td>
<td>換門贏</td>
</tr>
</tbody>
</table>
</div>
<p>從上表可以清楚看出，換門之後贏的機會是$\frac{2}{3}$，不換門則是$\frac{1}{3}$。</p>
<h2 id="直覺想法"><a href="#直覺想法" class="headerlink" title="直覺想法"></a>直覺想法</h2><h3 id="錯誤想法-遲到法"><a href="#錯誤想法-遲到法" class="headerlink" title="錯誤想法-遲到法"></a>錯誤想法-遲到法</h3><p>有些人會問：當我從三道門選完之後，主持人打開了一扇門。這時候我請另外一個場外人來看現在的局面：兩扇門關閉，一扇門打開是山羊，那這時候這個局外人選中的機會不就是$\frac{1}{2}$？</p>
<p>這個推論其實是正確的，以一個局外人看到的情況與機率確實是$\frac{1}{2}$，但這樣的思考前提是錯誤的，因為這位局外人<font color="#f00">並沒有參與一開始三門的選擇！</font><br>條件機率有一個重要的概念，也就是一個事件的機率會<font color="#f00">隨著情境的不同（提供訊息的改變）而可能會有所改變</font>，這就是一個很明顯的例子</p>
<h3 id="幫助理解的思考方法"><a href="#幫助理解的思考方法" class="headerlink" title="幫助理解的思考方法"></a>幫助理解的思考方法</h3><blockquote>
<p>1990 年 9 月 9 日，瑪麗蓮‧沃斯‧薩萬特 (Marilyn vos Savant) 在《繽紛遊行》(Parade) 的「請問瑪麗蓮」專欄中，回答讀者提出的三門問題，沃斯‧薩萬特是金氏世界紀錄最高智商 228 的人，她認為選擇換的勝算比較大。為了說服讀者，她請大家想像有 1,000,000 扇門，她說：</p>
<p>你選擇 1 號門，而主持人知道門後有什麼，他總是避開有獎的那扇門，除了 777,777 號門外，把別的門都打開了。這時你會毫不猶豫地換到另一扇門，是吧?」</p>
</blockquote>
<p>從N道門中選擇其中一道門中獎機率$\frac{1}{N}$，不中獎的機率為$\frac{N-1}{N}$，也就是說有$\frac{N-1}{N}$的機率汽車在另外$N-1$道門中。這時候主持人幫你一個大忙，他打開了其中沒有汽車的$N-2$道門，不就是幫助你<font color="#f00">剔除了不可能選中的情況</font>，也就代表把$\frac{N-1}{N}$的中獎機率集中在剩下的那一扇門中！</p>
<p>因此可以得到結論：在$N$門問題中，假設主持人總共會打開$N-2$道門，那換門中獎的機率會是$\frac{N-1}{N}$，不換門中獎則是$\frac{1}{N}$</p>
<h2 id="程式實作：以C-模擬"><a href="#程式實作：以C-模擬" class="headerlink" title="程式實作：以C++模擬"></a>程式實作：以C++模擬</h2><p>如果上面的東西都無法說服你，那就來寫一個程式模擬吧！寫程式最重要的就是要證明模擬是正確的，因此會印出若干組結果看看是否合理！<br>這個程式會亂數幫觀眾選一扇門（隨機選），與中獎的門（也是隨機選），接著主持人打開門後會剩下觀眾選的與一個還沒有被開的門</p>
<h3 id="主持人打開N-2道門（剩2道門做選擇）"><a href="#主持人打開N-2道門（剩2道門做選擇）" class="headerlink" title="主持人打開N-2道門（剩2道門做選擇）"></a>主持人打開N-2道門（剩2道門做選擇）</h3><p>我們取$N=3$ 做例子（當然也可以隨意輸入），第一個3表示門的數量，接下來的100000表示模擬次數<br><img src="https://i.imgur.com/SWsVaD1.png" alt=""></p>
<p>印出前五次的模擬情況作觀察，這個程式在印出未中獎時，換門中獎的事件加一；反之，印出中獎時，不換門中獎的事件加一，模擬結果符合預期！</p>
<p>如果共有10道門，一樣符合預期，換門中獎機率落在$\frac{9}{10}$左右<br><img src="https://i.imgur.com/zWhUjZq.png" alt=""></p>
<h3 id="主持人打開K道門（剩N-K道門做選擇）"><a href="#主持人打開K道門（剩N-K道門做選擇）" class="headerlink" title="主持人打開K道門（剩N-K道門做選擇）"></a>主持人打開K道門（剩N-K道門做選擇）</h3><p>如果給個變化題，主持人想說不要對觀眾那麼好，在未被觀眾選中的$N-1$ 道門中開啟K道後面有羊的門。我們知道會有$\frac{N-1}{N}$的機率會在不是觀眾選的另外$N-1$道門中，但在這$N-1$道門中因為打開了$K$道門，剩下$N-1-K$道門可以選擇，因此可以列出以下式子：</p>
<script type="math/tex; mode=display">\frac{N-1}{N}\times \frac{1}{N-K-1}=\frac{N-1}{N^2-NK-1}</script><p>這就是換門中獎的機率！</p>
<p>我們可以將換門中獎的機率扣掉不換門中獎的機率：</p>
<script type="math/tex; mode=display">\begin{split}\frac{1}{N}\cdot \frac{N-1}{N-K-1}-\frac{1}{N} &=\frac{1}{N}(\frac{N-1}{N-K-1}-1) \\&= \frac{1}{N}\cdot\frac{K}{N-K-1}\end{split}</script><p>已知$N-K\geq2$ 且$K\geq0$，因此無論開多少門（甚至不開），<font color="#f00">換門的中獎機率永不小於不換門的機率！</font></p>
<p>以上為設定9個門，主持人打開5道門，執行一百萬次的結果。<br>根據上面的公式，我們預期會有$\frac{8}{27}\cong 0.2963$的機率換了會中獎，符合模擬的結果</p>
<h3 id="有a輛車，主持人開K道門"><a href="#有a輛車，主持人開K道門" class="headerlink" title="有a輛車，主持人開K道門"></a>有a輛車，主持人開K道門</h3><p>這就比較簡單了，原本只有1輛車，變成a輛車自然中獎的機率就會變a倍，套用上面的公式，換門中獎機率：</p>
<script type="math/tex; mode=display">\frac{a\cdot(N-1)}{N^2-NK-1}</script><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> selected_door,selected[<span class="number">1000000</span>],make_change=<span class="number">0</span>,keep=<span class="number">0</span>,N,M,open;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;open&gt;&gt;M; <span class="comment">//輸入門的數量N，主持人開門數open，模擬次數M</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;            <span class="comment">//執行M次</span></span><br><span class="line">        selected_door = <span class="built_in">rand</span>()%N;    <span class="comment">//選擇一個門放汽車</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(j==selected_door)selected[j]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> selected[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> audience_selected = <span class="built_in">rand</span>()%N; <span class="comment">//觀眾選擇一個門</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,ind=<span class="number">0</span>;j&lt;open;ind++)&#123; <span class="comment">//將K扇門打開</span></span><br><span class="line">          <span class="keyword">if</span>(ind!=audience_selected &amp;&amp; ind!=selected_door)&#123;</span><br><span class="line">              selected[ind]=<span class="number">2</span>;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> change_door = <span class="number">0</span>; <span class="comment">//要換到的門</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;vec; <span class="comment">//可以換的選擇</span></span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(j!=audience_selected &amp;&amp; selected[j]!=<span class="number">2</span>)&#123;</span><br><span class="line">              vec.<span class="built_in">push_back</span>(j);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> vec_size = vec.<span class="built_in">size</span>();</span><br><span class="line">        change_door = vec[(<span class="built_in">rand</span>()%vec_size)];</span><br><span class="line">        <span class="keyword">if</span>(change_door == selected_door)make_change++; <span class="comment">//紀錄換而贏的次數</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(audience_selected == selected_door)keep++; <span class="comment">//紀錄不換而贏的次數</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">4</span>)&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;次模擬&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;觀眾選擇：&quot;</span>&lt;&lt;audience_selected+<span class="number">1</span>&lt;&lt;<span class="string">&quot; 號門&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;中獎的門為：&quot;</span>&lt;&lt;selected_door+<span class="number">1</span>&lt;&lt;<span class="string">&quot; 號門&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;沒有被主持人打開的門：&quot;</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec_size;j++)cout&lt;&lt;vec[j]+<span class="number">1</span>&lt;&lt;<span class="string">&quot;號門,&quot;</span>;</span><br><span class="line">          cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;觀眾選擇要換的門為：&quot;</span>&lt;&lt;change_door+<span class="number">1</span>&lt;&lt;<span class="string">&quot; 號門&quot;</span>&lt;&lt;endl;</span><br><span class="line">          <span class="keyword">if</span>(audience_selected == selected_door)cout&lt;&lt;<span class="string">&quot;不換門中獎&quot;</span>&lt;&lt;endl;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(change_door == selected_door)cout&lt;&lt;<span class="string">&quot;換門中獎&quot;</span>&lt;&lt;endl;</span><br><span class="line">          <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;換門不換門皆不會中獎&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">5</span>);    <span class="comment">//印出機率</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;不換門贏的機率：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)keep/M&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;換了門贏的機率：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)make_change/M&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="警察抓酒鬼問題"><a href="#警察抓酒鬼問題" class="headerlink" title="警察抓酒鬼問題"></a>警察抓酒鬼問題</h2><p>這個問題可以用來比較一下三門問題：</p>
<blockquote>
<p>某酒鬼有90%的日子都會出去喝酒，喝酒只隨機去固定的三家酒吧。今天警察找了其中兩家酒吧都沒有找到酒鬼。問：酒鬼在第三家酒吧的機率？</p>
</blockquote>
<p>我們假設事件$A_1$為酒鬼喝酒的機率、$A_2$為酒鬼在家的機率，$B_1$為酒鬼在前兩個酒吧被抓的機率、$B_2$為酒鬼沒有在前兩個酒吧被抓的機率</p>
<p>我們要找的是酒鬼沒有在前兩個酒吧被抓的條件下喝酒的機率，可以套用貝氏定理：</p>
<script type="math/tex; mode=display">\begin{split}P(A_1|B_2)&=\frac{P(A_1\cap B_2)}{P(B_2)}\\&=\frac{P(A_1)\cdot P(B_2|A_1)}{P(A_1)\cdot P(B_2|A_1)+{P(A_2)\cdot P(B_2|A_2)}}\\&=\frac{\frac{9}{10}\times\frac{1}{3}}{\frac{9}{10}\cdot\frac{1}{3}+\frac{1}{10}\times 1} \\&=\frac{3}{4}=0.75\end{split}</script><p>正解是75%，也可以顯而易見的用$\frac{30\%}{30\%+10\%}=75\%$得到答案</p>
<p>這題想要討論的是，在三門問題中，<font color="#f00">主持人是知道</font>哪一些門是沒有汽車的，所以故意打開；但是在這個問題中，<font color="#f00">警察是不知道哪一個酒吧有酒鬼</font>，兩題本身的前提就不同，不能拿來互相解釋</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在分析完三門問題、程式實際模擬和比較其他題目之後，得到一個結論：三門問題中主持人並不是亂選，而是把沒有車的那些門打開，這跟平常直覺的機率想法是不同的！</p>
<p>雖然對大多數人的直覺反應而言，選擇換門與不換門似乎中獎的機率是相同的，但經過上述一連串利用貝氏定理的討論與歸納後，證實了反而換門才是最明智的選擇。「人的認知有兩種，一是先驗的古典機率，一是經驗的機率，前者會干擾後者；鴿子只有後者，在蒙提霍爾問題上，高人一籌。人其實是聰明反被聰明誤。」(曾志朗，2012)</p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>2021暑期筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>最近點對：詳解4種不同複雜度之算法</title>
    <url>/pair/</url>
    <content><![CDATA[<blockquote>
<p>題目敘述<br>給定二維平面上 $n$ 個點，每一點都有座標 $(x_i,y_i)$ ，求出最近的點對之歐幾里德距離為多少？<br>$dis(p_i,p_j) = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$<br><span id="more"></span></p>
</blockquote>
<p><strong>平面最近點對</strong>有好多種實作方式，從最差的暴力枚舉、稍微優化的掃描線演算法、到分治與隨機，有4種不同的時間複雜度。利用<a href="https://tioj.ck.tp.edu.tw/problems/1500">TIOJ 1500</a>這一題最近點對的裸題，來實測各種不同複雜度下所需要的執行時間。</p>
<h2 id="暴力枚舉"><a href="#暴力枚舉" class="headerlink" title="暴力枚舉"></a>暴力枚舉</h2><h3 id="時間複雜度：-O-N-2"><a href="#時間複雜度：-O-N-2" class="headerlink" title="時間複雜度：$O(N^2)$"></a>時間複雜度：$O(N^2)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262968">Submission</a><br><strong>時間：TLE,10440</strong></p>
<p><img src="https://i.imgur.com/DL0tBBb.png" alt=""></p>
<p>暴力$O(n^2)$將所有點進行枚舉，因為值域是 $n≤50000$ ，平方枚舉會有TLE的問題。</p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        ld d = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                d = <span class="built_in">min</span>(d, <span class="built_in">dis</span>(p[i],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="掃描線算法"><a href="#掃描線算法" class="headerlink" title="掃描線算法"></a>掃描線算法</h2><h3 id="時間複雜度：Worst-Case-O-N-2"><a href="#時間複雜度：Worst-Case-O-N-2" class="headerlink" title="時間複雜度：Worst Case $O(N^2)$"></a>時間複雜度：Worst Case $O(N^2)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262966">Submission</a><br><strong>時間：AC,1668</strong><br><img src="https://i.imgur.com/6iSbet4.png" alt=""></p>
<p>這一種作法是改善過後的暴力枚舉，利用計算幾何中掃描線的概念，先將所有點依照x座標進行排序（y座標隨意）。接著想像一條從左往右掃的掃描線，對於每一條掃描線看右邊的點，如果當前最近點對距離為 $d$，因此只要遇上x座標差距大於 $d$ 的點時，即可繼續下一輪的枚舉。</p>
<p>加上排序的關係，其時間複雜度至少為 $O(n\log n)$，但這種掃描線的方式無法有效過濾所有點都在相同的x座標上的情況，因此最差的時間複雜度會退化成 $O(n^2)$ ，不過聽說平均的狀況下是很快的！</p>
<p><img src="https://i.imgur.com/Ae9k1HR.png" alt=""></p>
<p>上圖為掃描線執行最近點對的一個示意圖，黑線為掃描線，$d$ 為掃描線左邊所有點的最近點對距離，我們只要每一輪枚舉這個點與右邊x座標差在 $d$ 以內的所有點，即可進行下一輪的更新！</p>
<h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p,p+n);</span><br><span class="line">        ld d = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j].x &gt; p[i].x + d)<span class="keyword">break</span>;</span><br><span class="line">                d = <span class="built_in">min</span>(d, <span class="built_in">dis</span>(p[i],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="掃描線算法（優化後）"><a href="#掃描線算法（優化後）" class="headerlink" title="掃描線算法（優化後）"></a>掃描線算法（優化後）</h2><h3 id="時間複雜度：-O-N-log-N"><a href="#時間複雜度：-O-N-log-N" class="headerlink" title="時間複雜度：$O(N\log N)$"></a>時間複雜度：$O(N\log N)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/278456">Submission</a><br><strong>時間：AC,148</strong></p>
<p>原本以為上面的掃描線就是他的極限了，沒想到上面的worst case還可以透過set優化成 $O(n\log n)$！簡單來說，方法一樣是想像一條掃描線由左而右，一樣照上面的想法，把x座標差大於d的點排除，之後利用set二分搜找出y座標在範圍內的點進行枚舉更新答案。</p>
<ol>
<li>將點輸入並且排序，X座標為主，Y座標為輔。</li>
<li>使用set，並以Y座標為排序基準（pair的首項），以儲存第 $i$ 點的左方、水平距離小於等於d的點。</li>
<li>右掃描線依序窮舉各點作為右端點。<br>　(1) Erase與右端點水平距離大於d的點們（左掃描線右移）<br>　(2) 用二分搜找出與第 $i$ 點垂直距離小於d的點，並嘗試更新<br>　(3) 將第 $i$ 點加入set中。</li>
</ol>
<p><img src="https://i.imgur.com/yMs369S.png" alt=""></p>
<h3 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;pii&gt; p;</span><br><span class="line">set&lt;pii&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;p[<span class="number">0</span>].y,p[<span class="number">0</span>].x&#125;);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;ld ans = <span class="number">5e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">ceil</span>(ans);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; i &amp;&amp; p[l].x &lt; p[i].x - d)&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(&#123;p[l].y,p[l].x&#125;);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it_l = s.<span class="built_in">lower_bound</span>(&#123;p[i].y - d,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">auto</span> it_r = s.<span class="built_in">upper_bound</span>(&#123;p[i].y + d,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = it_l;it != it_r;it++)&#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,<span class="built_in">dis</span>(&#123;it-&gt;y,it-&gt;x&#125;,p[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123;p[i].y,p[i].x&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="時間複雜度：-O-N-log-N-1"><a href="#時間複雜度：-O-N-log-N-1" class="headerlink" title="時間複雜度：$O(N\log N)$"></a>時間複雜度：$O(N\log N)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262111">Submission</a><br><strong>時間：AC,196</strong></p>
<p><img src="https://i.imgur.com/aOV2MWE.png" alt=""></p>
<p>分治做最近點對的基本想法，先將所有點依照x座標排序，利用遞迴得到分割點左右兩邊所有點的最短距離（兩點並不會跨過中間分隔線），枚舉所有會橫跨兩側且有可能更新最短距離的點對。</p>
<p><img src="https://i.imgur.com/2NGuJc5.png" alt=""></p>
<p>從兩半邊的遞迴得到目前的最近點對距離 $d = min(d_l,d_r)$ ，將分隔線附近x座標差距小於$d$的點通通都枚舉一遍。可能會有一個疑問，我們是不是可以縮小枚舉的範圍，否則點的數量可能會太多導致複雜度爆炸？除了x座標可以做點的篩選之外，在枚舉的過程中，我們會利用將所有點對y座標排序，將y座標直線距離大於 $d$ 的情況剔除，所剩下真的需要枚舉點也只會剩下常數個，因此可以放心枚舉。</p>
<p><strong>複雜度分析：</strong> 腦海中想像遞迴樹的長相，會發現每一層都需要都需要對y座標進行排序，時間為$O(n\log n)$ ，每一次都將n的值除以2，因此共有$O(\log n)$ 層，總共的時間複雜度為 $O(n\log^2n)$。（不過實際上應該會比這個快，因為並不是要對所有點都進行排序）。</p>
<script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2})+O(n\log n) = O(n\log^2n)</script><p>如果要做得更快，可以在y座標排序的地方稍微動動手腳。既然每一層都要對y座標進行排序，排序好的東西再排序一次其實沒有什麼意義，因此就可以用）<a href="/N9zvIzP_Se-hpWZSaMv-sQ">合併排序（merge sort）</a>的方式，將所有已經排序好的兩個左右序列進行$O(n)$的合併（可以用std::merge()完成），如此一來，就不須要每一層花到 $O(n\log n)$ 的ㄕˊ間進行排序，使總複雜度降低為 $O(n\log n)$！</p>
<script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2})+O(n) = O(n\log n)</script><h3 id="程式碼-3"><a href="#程式碼-3" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF1 100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;pii&gt; p,temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1 = a.x-b.x,y1 = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x1 * x1 + y1 * y1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間[l,r]</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>,mid_pos = p[mid].x;;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="built_in">min</span>(<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r));</span><br><span class="line">    </span><br><span class="line">    temp.<span class="built_in">assign</span>((r-l+<span class="number">1</span>),&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">merge</span>(</span><br><span class="line">        p.<span class="built_in">begin</span>() + l, p.<span class="built_in">begin</span>() + mid + <span class="number">1</span>,</span><br><span class="line">        p.<span class="built_in">begin</span>() + mid + <span class="number">1</span>, p.<span class="built_in">begin</span>() + r + <span class="number">1</span>,</span><br><span class="line">        temp.<span class="built_in">begin</span>(), cmp</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r)p[i] = temp[i-l];</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p[i].x - mid_pos) &lt;= ans)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = temp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, i+<span class="number">1</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dis</span>(temp[i],temp[j]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(temp[i].y-temp[j].y) &gt; ans)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隨機算法"><a href="#隨機算法" class="headerlink" title="隨機算法"></a>隨機算法</h2><h3 id="時間複雜度：期望-O-N"><a href="#時間複雜度：期望-O-N" class="headerlink" title="時間複雜度：期望 $O(N)$"></a>時間複雜度：期望 $O(N)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262969">Submission</a><br><strong>時間：AC,488</strong></p>
<p><img src="https://i.imgur.com/X756Jf4.png" alt=""></p>
<p>用隨機算法做最近點對的期望複雜度是 $O(n)$ ，也就是說如果一開始進行的Random_shuffle有做好的話，期望可以在線性時間解決這個問題。基本的想法如下：</p>
<ol>
<li>將最近點對距離設為d，初始為第一、二個點之間的距離</li>
<li>將每一個點的座標塞入以 $\frac{d}{2}$ 為邊長的網格中</li>
<li>將點加入網格中，查看要加入的網格是否已經有點在其中</li>
<li>一個網格不可容納兩個點，否則必須更新最近點對的距離</li>
<li>在更新最近點對距離之後，將前面的點的網格座標以新的$d$進行更新</li>
</ol>
<p>這個算法用到隨機的因子，因此如果在一開始有將所有點進行均勻的打散的話，可以做到期望複雜度 $O(n)$。</p>
<p><strong>複雜度分析：</strong><br>考慮加入第i+1個點時出現新的最近點對，發生的機率為：在$C_2^{i+1}$個配對中跟i+1個點產生最近點對共有i種可能因此機率為$\frac{2}{i+1}$。</p>
<p>當機率發生的時候，必須將所有的點都刪掉重新來一遍（r變小，重新推入i+1個點），需要付出$O(i+1)$的時間，相乘起來加入每一個點期望的複雜度為$O(1)$，因此總時間複雜度為$O(n)$。</p>
<h3 id="程式碼-4"><a href="#程式碼-4" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000LL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swift 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ld r,d,ans;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">25</span>] = &#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">25</span>] = &#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Grid</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,ind;</span><br><span class="line">&#125;point[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函式實作</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.<span class="built_in">clear</span>();</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Grid</span><span class="params">(<span class="keyword">int</span> ind)</span></span>&#123; <span class="comment">//input網格座標</span></span><br><span class="line">    <span class="keyword">int</span> x = point[ind].x/r;</span><br><span class="line">    <span class="keyword">int</span> y = point[ind].y/r;</span><br><span class="line">    <span class="keyword">return</span> x*INF+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">dis</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x,y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(<span class="number">0</span>),<span class="number">0</span>));m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(<span class="number">1</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ind = <span class="number">2</span>;ind &lt; n;ind++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = point[ind].x/r,y = point[ind].y/r,better=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(nx*INF+ny);</span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">double</span> distance = <span class="built_in">dis</span>(point[it-&gt;second],point[ind]);</span><br><span class="line">                <span class="keyword">if</span>(distance&lt;d)&#123;</span><br><span class="line">                    better = <span class="number">1</span>;</span><br><span class="line">                    ans = <span class="built_in">dis</span>(point[it-&gt;second],point[ind]);</span><br><span class="line">                    d = distance;</span><br><span class="line">                    r = d/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(better)&#123;</span><br><span class="line">            m.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=ind;i++)m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(i),i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(ind), ind));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            x+=swift;y+=swift;</span><br><span class="line">            point[i].x = x;point[i].y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">random_shuffle</span>(point, point+n);</span><br><span class="line">        <span class="keyword">int</span> smalln = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        ans = <span class="built_in">dis</span>(point[<span class="number">0</span>],point[<span class="number">1</span>]);</span><br><span class="line">        d = <span class="built_in">dis</span>(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=smalln;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=smalln;j++)&#123;</span><br><span class="line">                d = <span class="built_in">min</span>(d,<span class="built_in">dis</span>(point[i], point[j]));</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,<span class="built_in">dis</span>(point[i],point[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r = d/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相關題目"><a href="#相關題目" class="headerlink" title="相關題目"></a>相關題目</h2><ul>
<li><a href="https://neoj.sprout.tw/problem/795/">NEOJ 最近點對</a></li>
<li><a href="https://tioj.ck.tp.edu.tw/problems/1105">TIOJ 最遠點對</a></li>
</ul>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>最近點對</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>暑假筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路徑（Shortest Path Problem）</title>
    <url>/path1/</url>
    <content><![CDATA[<p>今年是2021，資芽的二階主題跟2020上的有很多的差別，因此會利用暑假把2020的東西也補一補！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="路徑與權重"><a href="#路徑與權重" class="headerlink" title="路徑與權重"></a>路徑與權重</h3><ul>
<li>$G=(V,E)$</li>
<li>尋找最短路徑權重和最小</li>
<li>無帶權：BFS直接做(or DFS)</li>
<li>有帶權最短路徑<span id="more"></span>
</li>
</ul>
<h3 id="Floyd-Warshall：全點對最短路徑-All-Pairs"><a href="#Floyd-Warshall：全點對最短路徑-All-Pairs" class="headerlink" title="Floyd-Warshall：全點對最短路徑(All Pairs)"></a>Floyd-Warshall：全點對最短路徑(All Pairs)</h3><ul>
<li><p>不支援負環</p>
</li>
<li><p>想法：DP轉移（三個迴圈中點、起點、終點依序鬆弛）</p>
</li>
<li>$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$</li>
<li>如果改寫成定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路</li>
<li>則轉移：$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$</li>
<li>因此中間點k必須在最外層（不過<a href="https://arxiv.org/pdf/1904.01210.pdf">有論文指出</a>順序顛倒一樣可以得到正確解）</li>
<li>優點：實作容易，缺點：時間 $O(v^3)$ 、無法處理負環（可處理負邊）</li>
</ul>
<h3 id="Dijkstra’s：單點源最短路徑"><a href="#Dijkstra’s：單點源最短路徑" class="headerlink" title="Dijkstra’s：單點源最短路徑"></a>Dijkstra’s：單點源最短路徑</h3><ul>
<li><p>優點：時間 $O(E+V^2)$、無法處理負邊</p>
</li>
<li><p>想法：Greedy（和DP）</p>
</li>
<li>維護：1. 未拜訪的節點集合$U$ 2. $d[i]$ 目前起點到 $i$ 最短路 3. 目前考慮節點 $p$</li>
<li>重複以下動作直到u為空：<ul>
<li>對於所有與 $p$ 連接的節點 $q$，$d[q] = min(d[q],d[p]+weight[p][q])$</li>
<li>當 $p$ 相鄰節點都走過：在 $u$ 中移除 $p$</li>
<li>將 $p$ 更新成U中離起點距離最短的點 $min(d[j])$</li>
</ul>
</li>
<li>可以變成 $O((E+V)logV)$-&gt;邊較為稀疏的圖時有利（使用priority_queue）</li>
<li>不能處理負邊，因為 $d[i]$ 較小的處理完之後就不會再更動了，加入負邊可能更小</li>
<li>拿距離最小的點 $k$ 去更新其他點，不能保證更新後其他點一定是最短路</li>
<li>上一步走完 $k$ 連接所有邊後，從集合 $U$ 中移除，因為沒有負邊， $k$ 必定是最短路</li>
</ul>
<h3 id="Bellman-Ford：單點源最短路徑"><a href="#Bellman-Ford：單點源最短路徑" class="headerlink" title="Bellman-Ford：單點源最短路徑"></a>Bellman-Ford：單點源最短路徑</h3><ul>
<li><p>可以處理負環</p>
</li>
<li><p>時間：$O(VE)$</p>
</li>
<li>想法：Relax鬆弛</li>
<li>一條邊 $\delta(u,v)$ 滿足 $dis[v] = min(dis[v],dis[u]+weight[u][v])$</li>
<li>對每一條邊進行鬆弛，因為鬆弛沒有按照最短路順序，因此要做V-1次</li>
<li>此為暴力作法</li>
<li>執行V-1次的worst case：<ul>
<li>剛好跟最短路徑的順序相反</li>
<li>每次 Relax 後只能優化單一子路徑</li>
<li>共有V個頂點，需要有V-1 條子路徑，每一次一條</li>
<li>檢查負環：做完之後卻有滿足$d[v] &gt; d[u]+w(u,v)$ ，表示有負環</li>
</ul>
</li>
</ul>
<h3 id="優化：SPFA-Shortest-Path-Faster-Algorithm"><a href="#優化：SPFA-Shortest-Path-Faster-Algorithm" class="headerlink" title="優化：SPFA(Shortest Path Faster Algorithm)"></a>優化：SPFA(Shortest Path Faster Algorithm)</h3><ul>
<li><p>每次只relax更新過的點</p>
</li>
<li><p>使用queue優化，有點像BFS過程</p>
<ul>
<li>1.把起點 Push 到 Queue</li>
<li>2.從 Queue 裡 Pop 出一筆資料</li>
<li>3.該筆資料的所有邊進行 Relax</li>
<li>4.有更新到的頂點再 Push 到 Queue</li>
<li>5.重複步驟 2 ~ 4，直到 Queue 為空</li>
</ul>
</li>
<li>時間：$O(VE)$ -&gt;worst case，期望 $O(KE)$ ，K大概是2吧（反正挺快的）</li>
</ul>
<h3 id="DAG-Shortest-Path"><a href="#DAG-Shortest-Path" class="headerlink" title="DAG Shortest Path"></a>DAG Shortest Path</h3><p>首先對所有點進行拓墣排序，花上時間 $O(V+E)$，接著對每一條邊進行鬆弛，時間$O(E)$，因此總時間複雜度是 $O(V+E)$。這個時間複雜度是很快的，但相對的限制也非常多，除了不能有負邊與負環之外，更不能有正環在其中，否則不能進行拓墣排序（在之前筆記<a href="/OYm7TyO2RquZwdUFLx8PFQ">進階圖論（一）</a>）有提到，也就是這一中圖必須是DAG(Directed Acyclic Graph)！</p>
<p>一個有趣的應用：<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%95%AB%E8%A9%95%E6%A0%B8%E8%A1%93">PERT</a></p>
<h3 id="最短路徑樹"><a href="#最短路徑樹" class="headerlink" title="最短路徑樹"></a>最短路徑樹</h3><ul>
<li><p>紀錄predecessor(樹父節點唯一)</p>
</li>
<li><p>起點到每個點的最短路徑都唯一的話，那把這些路徑疊起來會變成一棵樹</p>
</li>
<li>樹：每一點都有唯一來源（最短路）</li>
</ul>
<h3 id="最短路徑比較"><a href="#最短路徑比較" class="headerlink" title="最短路徑比較"></a>最短路徑比較</h3><p>最短路徑問題共有以下求解方式（當然還有一堆），整理比較圖：<br><img src="https://i.imgur.com/uUUmhcL.jpg" alt=""></p>
<h3 id="負環"><a href="#負環" class="headerlink" title="負環"></a>負環</h3><p>上表中的可以處理負環的SPFA和Bellman-Ford是以什麼樣的方式處理？（遇到負環權重應該是$-\infty$）上方所謂負環是指下圖這種情況（當出發點為s，終點為t求最短路徑的問題），因為沒有經過負環，因此 $\delta(s,t)$ 可以被SPFA和Bellman-Ford求出正確的最短路徑為1。我們可以利用從終點回朔最短路徑（利用predecessor紀錄）看是否有重複經過的點，如果有則表示途中有經過負環！</p>
<p><img src="https://i.imgur.com/MJnJXUp.png" alt=""></p>
<p>至於其他的算法，都會求出不正確的數值！</p>
<div class="note default">
            <p><strong>Floyd warshall</strong><br>這個演算法是處理全點對的最短路徑，如果有負環，那一定有任兩點的最短距離是錯誤的。不過我們一樣可以利用Floyd-Warshall演算法判斷圖中是否有負環，只要<font color="#f00">檢查每一個點走到自己的距離是否為負</font> ，即$dis[i][i]<0$ 是否成立，如果成立表示圖中有負環。<br></p><p><strong>Dijkstra</strong><br>這個演算法要求的限制更多，圖中<font color="#f00">不可以有負邊</font>（更別提多個負邊組成的赴環），原因是在Dijkstra求最短路的過程中使用到貪心的想法，當我們從heap裡面取出目前距離最短的點之後，便不會再次被更新。如果有負邊的話，貪心法的過程會發生錯誤，導致得到不正確的答案。</p><p><img src="https://i.imgur.com/Gkg2mex.jpg" alt=""></p><p>此圖中如果邊 $\delta(B,A)$ 為一負邊，當A被移出集合U中便不會有任何再次被更新的機會，但卻因為這條負邊的關係，導致從$s$到$A$的最短距離並不會被正確更新到！</p>
          </div>
<p>以上大概就是最短距離的演算法整理，還有一個全點對最短路徑Johnson’s Algorithm，大概就是對任一點做 Bellman-Ford（順便判斷有沒 有負環)，得到點權之後，用調整完的邊權做 V 次 Dijkstra，可以比Floyd-Warshall有更好的表現，到時候看。</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>最短路徑</category>
      </categories>
      <tags>
        <tag>2021暑期筆記</tag>
        <tag>2020資訊之芽</tag>
      </tags>
  </entry>
  <entry>
    <title>七橋問題、最短路徑問題及其延伸</title>
    <url>/path3/</url>
    <content><![CDATA[<p>這篇文章的主題有以下：</p>
<ol>
<li>歐拉路徑、迴路（七橋問題）</li>
<li>漢米頓路徑、迴路</li>
<li>最短路徑演算法（Dijkstra,Bellman-Ford,Floyd-Warshall）</li>
<li>旅行業務員問題（TSP）</li>
</ol>
<span id="more"></span>
<h2 id="歐拉路徑、迴路（七橋問題）"><a href="#歐拉路徑、迴路（七橋問題）" class="headerlink" title="歐拉路徑、迴路（七橋問題）"></a>歐拉路徑、迴路（七橋問題）</h2><h3 id="問題簡介"><a href="#問題簡介" class="headerlink" title="問題簡介"></a>問題簡介</h3><p><img src="https://i.imgur.com/buHMNgV.png" alt=""></p>
<p>七橋問題的描述是：該如何在所有橋都只能走一遍的前提下，把這個地方所有的橋都走遍（每條邊洽經過一次）？</p>
<p>由數學歸納法得證，我們只要統計每個點的度數並記錄奇點的個數，只要大於二則不存在歐拉路徑。</p>
<h3 id="實作程序"><a href="#實作程序" class="headerlink" title="實作程序"></a>實作程序</h3><p><strong>1. 判斷奇點個數</strong>，若奇點個數k：</p>
<ul>
<li>k &gt; 2，那麼無解</li>
<li>k = 2，則選擇其中一個奇點作為起點</li>
<li>k = 0，則選擇任意一個點作為起點</li>
</ul>
<p><strong>2. DFS 執行下列步驟</strong><br>若當前節點還有尚未走過的邊，那麼拜訪該邊，並在拜訪完後輸出該邊，否則離開當前結點</p>
<p><strong>3. 若還有節點尚未拜訪，則無解</strong><br><strong>4. 否則輸出順序即為一組解</strong></p>
<h3 id="程式碼實作"><a href="#程式碼實作" class="headerlink" title="程式碼實作"></a>程式碼實作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 501</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,Edge[N][N],ans[<span class="number">1025</span>],ind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Edge[cur][i])&#123;</span><br><span class="line">            Edge[cur][i]--;Edge[i][cur]--;</span><br><span class="line">            <span class="built_in">DFS</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[ind++] = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(Edge, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Edge));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Edge[a][b]++;</span><br><span class="line">        Edge[b][a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;                <span class="comment">//開始的節點編號</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">500</span>;j++)&#123;</span><br><span class="line">            sum+=Edge[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)&#123;             <span class="comment">//找到第一個度數為奇數的節點</span></span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(start);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ind<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旅行業務員問題（TSP）與漢米頓路徑"><a href="#旅行業務員問題（TSP）與漢米頓路徑" class="headerlink" title="旅行業務員問題（TSP）與漢米頓路徑"></a>旅行業務員問題（TSP）與漢米頓路徑</h2><h3 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h3><p><img src="https://i.imgur.com/Zb3ihAn.png" alt=""></p>
<p>漢米頓路徑是類似於歐拉路徑，但每一條邊恰好經過一次的限制變成點恰好經過一次，但此問題的難度比歐拉迴路高上好幾倍，為一個NP-Complete的問題。</p>
<p><img src="https://i.imgur.com/W5izpYM.png" alt=""></p>
<p>旅行商務員問題則是描述平面上n個城市，是否存在一條路徑將每一個點恰好走過一次後回到出發點。此問題為一個漢米頓迴路問題的經典問題。</p>
<p><a href="https://neoj.sprout.tw/problem/187/">題目連結</a><br>第一次寫<strong>TSP</strong>(Traveling Salesman Problem)，題目敘述如下：</p>
<blockquote>
<p>給定一系列城市和每對城市之間的距離，求解存取每一座城市一次並回到起始城市的最短迴路。</p>
</blockquote>
<h3 id="實作程序-1"><a href="#實作程序-1" class="headerlink" title="實作程序"></a>實作程序</h3><p>我們透過位元的動態規劃，可以將原本$o(n!)$的時間複雜度變成以$O(n^2\cdot 2^n)$的複雜度解決這個問題。</p>
<p>這是一個已經被證明$NP-Hard$ 的問題，暴力作法是要檢查所有路徑的情況，因為共有n個點，每一個點又連接n-1個點，繼續下去總共會有N!種情況，因此複雜度為$O(n!)$。<br>總共的點數共有n個，根據多邊形的邊數公式可以知道一共有$\frac{n^2-n}{2}$條邊，每一條邊都有各自的距離。<br>如果改用DP做，時間複雜度可以壓到時間複雜度$O(n^2\cdot2^n)$，比$O(n!)$還優秀！這一題用到的是DP優化中的<font color="#f00">狀態壓縮</font>，具體的實作細節如下：</p>
<div class="note success">
            <p><strong>位元運算</strong><br>在這一題需要用到位元運算，用16個bit表示每一個點有沒有被走訪過。用這樣的表示方法可以讓code更為節儉，也就是狀態壓縮的概念。</p><p><strong>左移運算子(&lt;&lt;)</strong><br>這一題會一直反覆被用到，1&lt;&lt;t代表把1往左移動t單位，用10進位表示就是$2^t$。每往左移動一格，數字就會變成原來的兩倍！</p><p><strong>狀態壓縮</strong><br>將十進位整數s以二進位表示，會得到一串01字串，假設s=10，則 $s = 1010_{(2)}$。以這題來說，這樣的字串我們可以用來表示第4和第2個點已經被拜訪，而第3跟第1個點還沒有被拜訪。</p>
          </div>
<h4 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h4><p>定義 $dp[n][s]$ 表示目前在第n點上，s為走過的點（狀態壓縮）的最短距離</p>
<h4 id="轉移式"><a href="#轉移式" class="headerlink" title="轉移式"></a>轉移式</h4><p>$dp[n][s] = min(dp[i][s-(1&lt;&lt;n)]+dis[i][n])$, for all i such that s&amp;(1&lt;&lt;i)!=0</p>
<p>這個轉移式很有意思，因為s代表了每一個點是否有被走過，當我要更新dp[n][s]時，我要確保此時的狀態s中的點n必須為1。同時，因為1&lt;&lt;i用二進位表示只有第i位會是1其他都是0，做and運算就看s的第i位決定結果。</p>
<p>對於每一個i必須確保第i點在狀態s中有被造訪，因此有了後面的條件。另外轉移式中的s-(1&lt;&lt;N)是把第n個點從未造訪的狀態轉移。</p>
<h4 id="邊界"><a href="#邊界" class="headerlink" title="邊界"></a>邊界</h4><p>$dp[0][1] = 0,\quad dp[i][j]= \infty$</p>
<p>距離的預設狀態為無限大，第一個點的初始狀態是最短距離0</p>
<h4 id="實作小細節"><a href="#實作小細節" class="headerlink" title="實作小細節"></a>實作小細節</h4><p><strong>迴圈順序</strong><br>在轉移的過程中，迴圈的第一層必須是狀態，第二層才是城市。如果顛倒過來的話，會導致前面的城市在狀態還沒有被更新的時候就已經失去了之後被更新的機會，因此城市的迴圈必須放在第二層！</p>
<p><strong>求答案</strong><br>因為我們要求的是回到原點的最短距離，因此在全部轉移完成之後，利用一個迴圈把回去原點的路的距離加上去，求得最小值。</p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,dis[<span class="number">20</span>][<span class="number">20</span>];cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;dis[i][j];</span><br><span class="line">            dis[j][i] = dis[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[N][<span class="number">66000</span>],m = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//將0點到自己的距離設為1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(n^2 2^n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;            <span class="comment">//i表示2^n每一種狀態</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;        <span class="comment">//j表示城市</span></span><br><span class="line">            <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))<span class="keyword">continue</span>; <span class="comment">//j城市要是被造訪過的狀態</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;    <span class="comment">//可以到的所有點中的狀態</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp; <span class="number">1</span>&lt;&lt;k)&#123;        <span class="comment">//確保轉移過去的有被造訪過</span></span><br><span class="line">                    dp[j][i] = <span class="built_in">min</span>(dp[j][i],dp[k][i-(<span class="number">1</span>&lt;&lt;j)]+dis[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)ans = <span class="built_in">min</span>(ans,dp[i][m<span class="number">-1</span>]+dis[i][<span class="number">0</span>]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路徑演算法"><a href="#最短路徑演算法" class="headerlink" title="最短路徑演算法"></a>最短路徑演算法</h2><h3 id="Floyd-Warshall：全點對最短路徑-All-Pairs"><a href="#Floyd-Warshall：全點對最短路徑-All-Pairs" class="headerlink" title="Floyd-Warshall：全點對最短路徑(All Pairs)"></a>Floyd-Warshall：全點對最短路徑(All Pairs)</h3><ul>
<li><p>不支援負環</p>
</li>
<li><p>想法：DP轉移（三個迴圈中點、起點、終點依序鬆弛）</p>
</li>
<li>$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$</li>
<li>如果改寫成定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路</li>
<li>則轉移：$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$</li>
<li>因此中間點k必須在最外層（不過<a href="https://arxiv.org/pdf/1904.01210.pdf">有論文指出</a>順序顛倒一樣可以得到正確解）</li>
<li>優點：實作容易，缺點：時間 $O(v^3)$ 、無法處理負環（可處理負邊）</li>
</ul>
<h3 id="Dijkstra’s：單點源最短路徑"><a href="#Dijkstra’s：單點源最短路徑" class="headerlink" title="Dijkstra’s：單點源最短路徑"></a>Dijkstra’s：單點源最短路徑</h3><ul>
<li><p>優點：時間 $O(E+V^2)$、無法處理負邊</p>
</li>
<li><p>想法：Greedy（和DP）</p>
</li>
<li>維護：1. 未拜訪的節點集合$U$ 2. $d[i]$ 目前起點到 $i$ 最短路 3. 目前考慮節點 $p$</li>
<li>重複以下動作直到u為空：<ul>
<li>對於所有與 $p$ 連接的節點 $q$，$d[q] = min(d[q],d[p]+weight[p][q])$</li>
<li>當 $p$ 相鄰節點都走過：在 $u$ 中移除 $p$</li>
<li>將 $p$ 更新成U中離起點距離最短的點 $min(d[j])$</li>
</ul>
</li>
<li>可以變成 $O((E+V)logV)$-&gt;邊較為稀疏的圖時有利（使用priority_queue）</li>
<li>不能處理負邊，因為 $d[i]$ 較小的處理完之後就不會再更動了，加入負邊可能更小</li>
<li>拿距離最小的點 $k$ 去更新其他點，不能保證更新後其他點一定是最短路</li>
<li>上一步走完 $k$ 連接所有邊後，從集合 $U$ 中移除，因為沒有負邊， $k$ 必定是最短路</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">      S &lt;- Ø</span><br><span class="line">      Q &lt;- V[G]</span><br><span class="line">      while Q ≠ Ø</span><br><span class="line">          do u &lt;- EXTRACT-MIN(Q)</span><br><span class="line">              S &lt;- S ∪ &#123;u&#125;</span><br><span class="line">              for each vertex v ∈ Adj[u]</span><br><span class="line">                  do RELAX(u,v,w)</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford：單點源最短路徑"><a href="#Bellman-Ford：單點源最短路徑" class="headerlink" title="Bellman-Ford：單點源最短路徑"></a>Bellman-Ford：單點源最短路徑</h3><ul>
<li><p>可以處理負環</p>
</li>
<li><p>時間：$O(VE)$</p>
</li>
<li>想法：Relax鬆弛</li>
<li>一條邊 $\delta(u,v)$ 滿足 $dis[v] = min(dis[v],dis[u]+weight[u][v])$</li>
<li>對每一條邊進行鬆弛，因為鬆弛沒有按照最短路順序，因此要做V-1次</li>
<li>此為暴力作法</li>
<li>執行V-1次的worst case：<ul>
<li>剛好跟最短路徑的順序相反</li>
<li>每次 Relax 後只能優化單一子路徑</li>
<li>共有V個頂點，需要有V-1 條子路徑，每一次一條</li>
<li>檢查負環：做完之後卻有滿足$d[v] &gt; d[u]+w(u,v)$ ，表示有負環</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BELLMAN-FORD(G,w,s)</span><br><span class="line">      INITIALIZE-SINGLE-SOURCE(G,s)</span><br><span class="line">      for i &lt;- 1 to |V[G]|-1</span><br><span class="line">          do for each edge (u,v)∈ E[G]</span><br><span class="line">              do RELAX(u,v,w)</span><br><span class="line">      for each edge (u,v)∈ E[G]</span><br><span class="line">          do if d[v] &gt; d[u]+w(u,v)</span><br><span class="line">              then return FALSE</span><br><span class="line">      return TRUE</span><br></pre></td></tr></table></figure>
<h3 id="優化：SPFA-Shortest-Path-Faster-Algorithm"><a href="#優化：SPFA-Shortest-Path-Faster-Algorithm" class="headerlink" title="優化：SPFA(Shortest Path Faster Algorithm)"></a>優化：SPFA(Shortest Path Faster Algorithm)</h3><ul>
<li><p>每次只relax更新過的點</p>
</li>
<li><p>使用queue優化，有點像BFS過程</p>
<ul>
<li>1.把起點 Push 到 Queue</li>
<li>2.從 Queue 裡 Pop 出一筆資料</li>
<li>3.該筆資料的所有邊進行 Relax</li>
<li>4.有更新到的頂點再 Push 到 Queue</li>
<li>5.重複步驟 2 ~ 4，直到 Queue 為空</li>
</ul>
</li>
<li>時間：$O(VE)$ -&gt;worst case，期望 $O(KE)$ ，K大概是2吧（反正挺快的）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shortest-Path-Faster-Algorithm(G, s)</span><br><span class="line">      for each vertex v ≠ s in V(G)</span><br><span class="line">          d(v) := ∞</span><br><span class="line">      d(s) := 0</span><br><span class="line">      offer s into Q</span><br><span class="line">      while Q is not empty</span><br><span class="line">          u := poll Q</span><br><span class="line">          for each edge (u, v) in E(G)</span><br><span class="line">              if d(u) + w(u, v) &lt; d(v) then</span><br><span class="line">                  d(v) := d(u) + w(u, v)</span><br><span class="line">                 if v is not in Q then</span><br><span class="line">                     offer v into Q</span><br></pre></td></tr></table></figure>
<h3 id="DAG-Shortest-Path"><a href="#DAG-Shortest-Path" class="headerlink" title="DAG Shortest Path"></a>DAG Shortest Path</h3><p>首先對所有點進行拓墣排序，花上時間 $O(V+E)$，接著對每一條邊進行鬆弛，時間$O(E)$，因此總時間複雜度是 $O(V+E)$。這個時間複雜度是很快的，但相對的限制也非常多，除了不能有負邊與負環之外，更不能有正環在其中，否則不能進行拓墣排序（在之前筆記進階圖論（一）有提到，也就是這一中圖必須是DAG(Directed Acyclic Graph)！</p>
<p>一個有趣的應用：<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%95%AB%E8%A9%95%E6%A0%B8%E8%A1%93">PERT</a></p>
<h2 id="延伸筆記"><a href="#延伸筆記" class="headerlink" title="延伸筆記"></a>延伸筆記</h2><ul>
<li>最短路徑問題</li>
<li>進階圖論（一）</li>
<li>最短路徑例題</li>
</ul>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>離散數學</tag>
        <tag>多元選修</tag>
      </tags>
  </entry>
  <entry>
    <title>三維空間中的反射定律模擬</title>
    <url>/reflection/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>上週補習班開始教「平面方程式」，有一題範例感覺特別的酷，題目如下：</p>
<blockquote>
<p>空間坐標系中，有一平面鏡E，一雷射光線經過點$A(1,-1,2)$射向鏡面E上的點$B(0,1,0)$，反射又經過點$C(4,-3,2)$，試求平面E的方程式為何？</p>
</blockquote>
<p>解法大概就是利用菱形對角線平分的概念求出平面方程式！由這一題延伸，我想看看當改變已知平面的各項參數時，反射光的向量會有怎麼樣的變化，於是就嘗試用VPython模擬出來！</p>
<span id="more"></span>
<p><img src="https://i.imgur.com/CLng02c.png" alt=""></p>
<p><img src="https://i.imgur.com/Qt5Ktgo.png" alt=""></p>
<h2 id="反射定律及數學"><a href="#反射定律及數學" class="headerlink" title="反射定律及數學"></a>反射定律及數學</h2><p>平面的情況很好理解，入射角等於反射角，但當來到三維時，除了角度一樣之外，這三個向量還必須在同一個平面上：</p>
<p><img src="https://i.imgur.com/mub19sF.png" width="400"></p>
<p>原題我們是利用已知的$\overrightarrow{BA},\overrightarrow{BC}$，利用菱形邊長相等且平分夾角的性質，將長度調整成一樣之後相加即可求出平面的法向量，進一步求得反射的平面：</p>
<p><img src="https://i.imgur.com/pL9itZU.png" alt=""></p>
<p>要利用$\overrightarrow{BA}$以及平面方程式逆推反射光向量，在確認法向量的方向向量之後，將平面法向量的長度設為$|\vec{n}| = 2\overline{AB}\cos\theta$，由$\vec n = \overrightarrow{BA}+\overrightarrow{BC}$即可推得與$\overrightarrow{BA}$長度相同的$\overrightarrow{BC}$！</p>
<p><img src="https://i.imgur.com/Aysupto.png" alt=""></p>
<p>綜合以上，令反射平面方程式為$ax+by+cz = 0$，$\vec n = (a,b,c)$，入射角為$\theta$，則：</p>
<script type="math/tex; mode=display">\begin{split}\overrightarrow{BC} &= \frac{2|\overrightarrow{BA}|\cos\theta}{|\vec n|}\vec n - \overrightarrow{BA}
\\&=\frac{2|\overrightarrow{BA}|(\vec n\cdot\overrightarrow{BA})}{|\vec n|^2\,\overrightarrow{BA}}\vec n - \overrightarrow{BA}\end{split}</script><h2 id="模擬及程式碼"><a href="#模擬及程式碼" class="headerlink" title="模擬及程式碼"></a>模擬及程式碼</h2><h3 id="使用說明"><a href="#使用說明" class="headerlink" title="使用說明"></a>使用說明</h3><p><a href="https://glowscript.org/#/user/ck1090758/folder/%E4%BA%8C%E5%B9%B4%E7%B4%9ATEST/program/mirrorreflectionsimulation">模擬連結</a><br>他會要求輸入發射源的$x,y,z$座標，完成後可以利用鍵盤’A,S’鍵調整平面$ax+by+cz=0$上$a$的大小（A變大、S變小），$b$則是’B,N’鍵、$c$是’C,V’鍵。</p>
<p><img src="https://i.imgur.com/BrP36SB.gif" alt=""></p>
<p>利用以上的公式，我們建立各個物件、包含各個座標軸、反射平面以及入射反射光。模擬中兩個黃色的箭頭代表入射光及反射光的向量，灰色箭頭則是平面的法向量。</p>
<h3 id="計算"><a href="#計算" class="headerlink" title="計算"></a>計算</h3><p>計算夾角用到內積算夾角的餘弦$\cos\theta = \frac{\vec a\cdot\vec b}{|\vec a||\vec b|}$，算內積函式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dt</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a.x*b.x+a.y*b.y+a.z*b.z</span><br></pre></td></tr></table></figure>
<p>接著就是計算$|\vec n|$的長度sz，對$\vec n$取單位向量後乘上長度，並設為平面的法向量，將$\vec n$與入射光向量相減得到反射光向量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sz = <span class="number">2</span> * mag(ball.pos) * dt(plane.up,ball.pos) / (mag(plane.up)*mag(ball.pos))</span><br><span class="line">n = norm(plane.up) * sz</span><br><span class="line"></span><br><span class="line">plane.up = vec(a,b,c)</span><br><span class="line">normal.axis = n</span><br><span class="line"></span><br><span class="line">arr_out.axis = n - ball.pos</span><br></pre></td></tr></table></figure>
<h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GlowScript <span class="number">3.2</span> VPython</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;x = &quot;</span>))</span><br><span class="line">y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;y = &quot;</span>))</span><br><span class="line">z = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;z = &quot;</span>))</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scene = canvas(width=<span class="number">1000</span>, height=<span class="number">500</span>,center = vector(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">range</span> = <span class="built_in">max</span>(x,<span class="built_in">max</span>(y,z))+<span class="number">10</span>) <span class="comment">#設定畫面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dt</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a.x*b.x+a.y*b.y+a.z*b.z</span><br><span class="line"></span><br><span class="line">plane = box(pos=vector(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),length=<span class="number">20</span>, height=<span class="number">0.1</span>, width=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">arrx = arrow(pos=vector(-<span class="number">10</span>,<span class="number">0</span>,-<span class="number">5</span>), axis=vector(<span class="number">20</span>,<span class="number">0</span>,<span class="number">0</span>), shaftwidth=<span class="number">0.1</span>, color=color.red)</span><br><span class="line">arry = arrow(pos=vector(-<span class="number">10</span>,<span class="number">0</span>,-<span class="number">5</span>), axis=vector(<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>), shaftwidth=<span class="number">0.1</span>, color=color.blue)</span><br><span class="line">arrz = arrow(pos=vector(-<span class="number">10</span>,<span class="number">0</span>,-<span class="number">5</span>), axis=vector(<span class="number">0</span>,<span class="number">0</span>,<span class="number">20</span>), shaftwidth=<span class="number">0.1</span>, color=color.green)</span><br><span class="line"></span><br><span class="line">ball = sphere(pos=vector(x,y,z),radius=<span class="number">0.5</span>,color = color.red)</span><br><span class="line"></span><br><span class="line">arr_in = arrow(pos=ball.pos, axis=plane.pos-ball.pos, shaftwidth=<span class="number">0.5</span>, color=color.yellow)</span><br><span class="line">arr_out = arrow(pos=vec(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), axis=vector(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), shaftwidth=<span class="number">0.5</span>, color=color.yellow)</span><br><span class="line">normal = arrow(pos=vec(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), shaftwidth=<span class="number">0.1</span>, color=color.white)</span><br><span class="line"></span><br><span class="line">label_a = label(pos=vec(<span class="built_in">max</span>(x,<span class="built_in">max</span>(y,z))+<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>), box = <span class="number">0</span> ,height = <span class="number">20</span>, color = color.green)</span><br><span class="line">label_b = label(pos=vec(<span class="built_in">max</span>(x,<span class="built_in">max</span>(y,z))+<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>), box = <span class="number">0</span> ,height = <span class="number">20</span>, color = color.green)</span><br><span class="line">label_c = label(pos=vec(<span class="built_in">max</span>(x,<span class="built_in">max</span>(y,z))+<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>), box = <span class="number">0</span> ,height = <span class="number">20</span>, color = color.green)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rate(<span class="number">10</span>)</span><br><span class="line">    label_a.text = <span class="string">&#x27;&#123;&#125;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;a = &#x27;</span>,a)</span><br><span class="line">    label_b.text = <span class="string">&#x27;&#123;&#125;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;b = &#x27;</span>,b)</span><br><span class="line">    label_c.text = <span class="string">&#x27;&#123;&#125;&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;c = &#x27;</span>,c)</span><br><span class="line">    </span><br><span class="line">    ev = scene.waitfor(<span class="string">&#x27;click keydown&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> ev.key == <span class="string">&#x27;A&#x27;</span><span class="keyword">or</span> ev.key == <span class="string">&#x27;a&#x27;</span>:a += <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">if</span> ev.key == <span class="string">&#x27;B&#x27;</span><span class="keyword">or</span> ev.key == <span class="string">&#x27;b&#x27;</span>:b += <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">if</span> ev.key == <span class="string">&#x27;C&#x27;</span><span class="keyword">or</span> ev.key == <span class="string">&#x27;c&#x27;</span>:c += <span class="number">0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ev.key == <span class="string">&#x27;S&#x27;</span><span class="keyword">or</span> ev.key == <span class="string">&#x27;s&#x27;</span>:a -= <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">if</span> ev.key == <span class="string">&#x27;N&#x27;</span><span class="keyword">or</span> ev.key == <span class="string">&#x27;n&#x27;</span>:b -= <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">if</span> ev.key == <span class="string">&#x27;V&#x27;</span><span class="keyword">or</span> ev.key == <span class="string">&#x27;v&#x27;</span>:c -= <span class="number">0.1</span></span><br><span class="line">    </span><br><span class="line">    sz = <span class="number">2</span> * mag(ball.pos) * dt(plane.up,ball.pos) / (mag(plane.up)*mag(ball.pos))</span><br><span class="line">    n = norm(plane.up) * sz</span><br><span class="line">    </span><br><span class="line">    plane.up = vec(a,b,c)</span><br><span class="line">    normal.axis = n</span><br><span class="line">    </span><br><span class="line">    arr_out.axis = n - ball.pos</span><br></pre></td></tr></table></figure>
<h2 id="延伸內容"><a href="#延伸內容" class="headerlink" title="延伸內容"></a>延伸內容</h2><p>既然有反射勢必有折射定律的模擬，牽扯到不同介質的折射率以及角度的計算$n_1\sin\theta_1 = n_2\sin\theta_2$，之後可以嘗試寫一個模擬試試！</p>
]]></content>
      <categories>
        <category>程式模擬</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>VPYTHON</tag>
        <tag>模擬</tag>
      </tags>
  </entry>
  <entry>
    <title>線段樹（Segment Tree）</title>
    <url>/seg1/</url>
    <content><![CDATA[<p>今年是2021，資芽的二階主題跟2020上的有很多的差別，因此會利用暑假把2020的東西也補一補！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="儲存"><a href="#儲存" class="headerlink" title="儲存"></a>儲存</h3><p>線段樹很多人都用陣列來實作，空間$O(n)$，在處理樹的左右節點也十分的方便。如果以1-base來儲存陣列這棵線段樹，左右節點可以用以下的index來表示。線段樹有一個優點就是它可以用儲存完滿二元樹的方式來儲存，雖然它不一定是完滿但會是平衡的一棵樹。左節點：$2n$，右節點$2n+1$。<br><img src="https://i.imgur.com/PxXXqsl.png" alt=""><br><span id="more"></span></p>
<h3 id="空間大小"><a href="#空間大小" class="headerlink" title="空間大小"></a>空間大小</h3><p>一般來說線段樹的陣列會開$seg[4\times n]$，由以下證明得到的結果：</p>
<div class="note default">
            <p>對於一個有$2^k$的葉節點數的一棵樹，總共的節點共有 $\sum_{i=0}^k 2^i = 2^{k+1}-1$ 個節點。若今天陣列共有n個元素，則代表葉節點共有$2^{\lceil \log_2 n\rceil}$ 個，總節點數量共有$2^{\lceil \log_2 n\rceil+1}-1$ 個。<br>假設$n = 2^k+p,0≤p≤2^k$，則帶入前面公式 $2^{\lceil \log_2 n\rceil}=2^{k+1}$，根據前面推得的總節點數可以知道為 $2^{k+2}-1$，其值恆小於$4n$，因此開$4n$的陣列一定可以容納整個線段樹。</p>
          </div>
<p>由以上推倒可以知道一般都會開$seg[4\times n]$，但是如果n剛好是二的冪次，其實只會用到$2n$的空間，有一半會被浪費掉，不過沒差，因為多開總比少開來得好！<br><a href="https://gist.github.com/peienwu/368723520e3c39e4e0edc27a0823da69">懶標線段樹程式碼連結</a>，懶標這東西實在折磨人，學長寫的一個堪稱不用下推的懶標程式碼，結果他是錯的！！！害我Debug超久，可惡<br><img src="https://i.imgur.com/mEY8cFD.png" alt=""><br>這是學長的query程式碼，可以看到他回傳的是$(r-l)\times lazy[cur]$，這是錯誤的，因為不一定左右兩子樹都會被全部加上懶標的值（可能只會有部分交集），但這份code卻直接加上去，會多算而WA，要注意！<br><img src="https://i.imgur.com/nsd2KVP.png" alt=""><br>更改版，對區間取聯集應該就對了！</p>
<h3 id="實作部分"><a href="#實作部分" class="headerlink" title="實作部分"></a>實作部分</h3><p>這個版本是用struct實作，比起用陣列實作，這個版本更為方便閱讀，容易理解。為了方便索引值查詢左右子樹，使用1-base來儲存線段樹，同時利用一個struct儲存每一個節點。同時，每一個區間採用的是左閉右開 $[l,r)$，區間和的實作如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>            <span class="comment">//線段樹每一個節點</span></span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>,tag=<span class="number">0</span>,sz; <span class="comment">//val原本的值、tag懶標、sz區間大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rv</span><span class="params">()</span></span>&#123;           <span class="comment">//回傳實際節點的值</span></span><br><span class="line">        <span class="keyword">return</span> val+tag*sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br></pre></td></tr></table></figure>
<h4 id="建立-Build"><a href="#建立-Build" class="headerlink" title="建立(Build)"></a>建立(Build)</h4><p>分別遞迴建立左右子樹，同時更新每一個節點的大小sz。因為是左閉右開，直接左右相減r-l即可完成更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;    <span class="comment">//建立線段樹</span></span><br><span class="line">    seg[cur].sz = r-l;              <span class="comment">//更新節點的大小</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;                 <span class="comment">//空區間回傳</span></span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;                     <span class="comment">//設定當前節點的值</span></span><br><span class="line">        seg[cur].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;                <span class="comment">//分別遞迴建立左右子樹</span></span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].val+seg[<span class="number">2</span>*cur+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下推-push"><a href="#下推-push" class="headerlink" title="下推(push)"></a>下推(push)</h4><p>懶標真是驚人的想法，在區間修改的時候以$O(logn)$在要修改的區間先懶標標記起來，等到要query的時候把懶標推下去，這樣可以確保區間修改的複雜度是$O(logn)$，同時query的時候順便下推，一來比較好實作、二來複雜度也不會有什麼改變， 因為下推的複雜度是$O(1)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把id的懶標在query的時候往下推</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    seg[<span class="number">2</span>*id].tag += seg[id].tag;   <span class="comment">//左子樹懶標更新</span></span><br><span class="line">    seg[<span class="number">2</span>*id+<span class="number">1</span>].tag += seg[id].tag; <span class="comment">//右子樹懶標更新</span></span><br><span class="line">    seg[id].val = seg[id].<span class="built_in">rv</span>();     <span class="comment">//更新實際值</span></span><br><span class="line">    seg[id].tag = <span class="number">0</span>;                <span class="comment">//往下推完之後設定為預設</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="區間詢問-query"><a href="#區間詢問-query" class="headerlink" title="區間詢問(query)"></a>區間詢問(query)</h4><p>這裡的重點是下推，如果把懶標下推，可以確保區間修改的時間是$O(logn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">//空集合直接回傳</span></span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur].<span class="built_in">rv</span>();     <span class="comment">//包含在要詢問的範圍中，回傳實際值</span></span><br><span class="line">    <span class="built_in">push</span>(cur);                                  <span class="comment">//將懶標在遞迴下去的過程中下推</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;                          <span class="comment">//遞迴查詢左右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr)+<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="區點修改-modify"><a href="#區點修改-modify" class="headerlink" title="區點修改(modify)"></a>區點修改(modify)</h4><p>可以這樣理解，在區間修改中，透過遞迴完左右子樹拉上來的過程中，更新樹上較上方的節點的值（用懶標更新）。此時下方節點都還沒有被更新，等到query的時候會往下push順便把值也一起更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//區間修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=l||ql&gt;=r||qr&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;</span><br><span class="line">        seg[cur].tag += val;               <span class="comment">//將被完整包含的區間的懶標加上修改值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ql,qr,val);          <span class="comment">//修改左右子樹</span></span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);        <span class="comment">//遞迴完拉上來的過程中把上面的數值更新成有懶標的結果</span></span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].<span class="built_in">rv</span>()+seg[<span class="number">2</span>*cur+<span class="number">1</span>].<span class="built_in">rv</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="單點修改-modify"><a href="#單點修改-modify" class="headerlink" title="單點修改(modify)"></a>單點修改(modify)</h4><p>這一題沒有要求單點修改，所以以下是RMQ的單點修改。概念較為簡單，用$O(logn)$找到要修改的點，直接修改即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ind,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span> &amp;&amp; l==ind)&#123;</span><br><span class="line">        seg[cur]=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind&lt;mid)<span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ind,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ind,val);</span><br><span class="line">    seg[cur] = <span class="built_in">min</span>(seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="動態開點"><a href="#動態開點" class="headerlink" title="動態開點"></a>動態開點</h3><blockquote>
<p>有一個長度是 $10^9$ 的序列，一開始裡面的元素都是$0$，有 $Q$ 筆操作，每一個操作是以下其中兩種：</p>
<ol>
<li>把之間的值都加上$v$</li>
<li>詢問的區間和</li>
</ol>
</blockquote>
<p>開這麼多點顯然會MLE，既然使用陣列型儲存線段樹會爆，因為這麼大的值域顯然有許多點是不會被使用到的，那就改成使用指標型來開這個線段樹，以下為每一個節點的架構：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node *l;    <span class="comment">//指向左子樹</span></span><br><span class="line">    Node *r;    <span class="comment">//指向右子樹</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//維護區間和</span></span><br><span class="line">    </span><br><span class="line">&#125;;<span class="comment">//注意struct裡面可有struct的指標，但不能有實體</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>線段樹</category>
      </categories>
      <tags>
        <tag>2021暑假筆記</tag>
        <tag>2020資訊之芽</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第一、二週：基礎資結、複雜度、樹</title>
    <url>/sprout1-2/</url>
    <content><![CDATA[<p>第一次上課，原本想說會輕鬆的度過一個禮拜<br>沒想到直接用單調隊列當作開場，讓第一個星期圍繞著stack 與queue的資結世界中<br>但也很慶幸的，在第一週終於學會用很節簡的程式碼寫單調隊列<br>第二週的內容則是<strong>複雜度分析</strong><br>P 與NP 問題真讓人一頭是大，雖然在競程中對於較複雜的複雜度問題很少派上用場<br>不過還是蠻有趣的，只要證明P=NP就可以很多錢了！</p>
<span id="more"></span>
<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>第一週主題：基礎資料結構（queue, stack, 單調隊列）<br>第二週主題：複雜度分析、樹狀結構</p>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><p>挑幾題比較有趣的</p>
<h3 id="大善人老闆救濟東南亞兒童"><a href="#大善人老闆救濟東南亞兒童" class="headerlink" title="大善人老闆救濟東南亞兒童"></a>大善人老闆救濟東南亞兒童</h3><p><a href="https://neoj.sprout.tw/problem/19/">題目連結</a><br><img src="https://i.imgur.com/1MHCZeb.png" alt=""><br>這一題很熟悉，在去年9月剛開學的資讀學長有講過，結果那時候根本聽不懂QQ<br>但現在來看，這一題就是模擬stack ，很基礎的題目<br>可以用queue (也可以不用)配上stack，分別模擬Station 跟B站 的情況</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,arr[<span class="number">100005</span>];cin&gt;&gt;n;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">            q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(i+<span class="number">1</span>);<span class="comment">//push 進station</span></span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;!q.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()==q.<span class="built_in">front</span>())&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">empty</span>())cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中國人排隊問題"><a href="#中國人排隊問題" class="headerlink" title="中國人排隊問題"></a>中國人排隊問題</h3><p><a href="https://neoj.sprout.tw/problem/20/">題目連結</a><br>這一題有一個條件有點難維護，就是如果同一團體的人要排隊<br>而隊中已經有同一團人在裡面時，他就要排在團裡面最後一個位置<br>因此要用iterator 陣列指向每個團隊的末端之類的<br>好好維護<strong>細節</strong>可以減少debug 的時間！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Line #&quot;</span>&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">1000005</span>],gt[<span class="number">1005</span>];<span class="comment">//紀錄在哪一個團體當中</span></span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        <span class="built_in">memset</span>(gt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(gt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k;cin&gt;&gt;k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">                arr[temp] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list&lt;<span class="keyword">int</span>&gt; ls;</span><br><span class="line">        list&lt;<span class="keyword">int</span>&gt;::iterator it[<span class="number">1005</span>];<span class="comment">//指向第i個團體的尾端</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            string s;<span class="keyword">int</span> cur;</span><br><span class="line">            cin&gt;&gt;s;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                cin&gt;&gt;cur;</span><br><span class="line">                <span class="keyword">int</span> i = arr[cur];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(gt[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                        ls.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                        it[i] = --ls.<span class="built_in">end</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        it[i] = ls.<span class="built_in">insert</span>(++it[i],cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gt[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ls.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> i = ls.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;<span class="number">0</span>)gt[arr[i]]--;</span><br><span class="line">                cout&lt;&lt;ls.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">                ls.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="陸行鳥大賽車"><a href="#陸行鳥大賽車" class="headerlink" title="陸行鳥大賽車"></a>陸行鳥大賽車</h3><p><a href="https://neoj.sprout.tw/problem/21/">題目連結</a><br>這一題我嘗試了兩個方法<br>第一個方法：用vector 紀錄名次，但就是會TLE ，原因：需要O(N)找到當前的車車在第幾名，如果遭受攻擊，也要用O(N)來erase vector的元素，結果長這樣：<br><img src="https://i.imgur.com/FNJVrB8.png" alt=""><br>講師說：不要用vector 的erase ，因為他會耗費O(N)的時間</p>
<p>第二個方法：用一個struct 的陣列，裡面包了每一台車的資訊包含他的名次，這樣就可以用O(1)更改每一台車的名次，算是第一個算法的優化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> player_id;</span><br><span class="line">    node *next,*prev;</span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        prev = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node *player[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        player[i] = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        player[i]-&gt;player_id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        player[i]-&gt;prev = player[i<span class="number">-1</span>];</span><br><span class="line">        player[i]-&gt;next = player[i+<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="comment">//初始化設定</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">            player[b]-&gt;prev-&gt;next = player[b]-&gt;next;</span><br><span class="line">            player[b]-&gt;next-&gt;prev = player[b]-&gt;prev;</span><br><span class="line">        &#125;<span class="comment">//編號b的車車被消滅</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!player[b]-&gt;prev-&gt;prev)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> pp,p,n;</span><br><span class="line">            pp = player[b]-&gt;prev-&gt;prev-&gt;player_id;</span><br><span class="line">            p = player[b]-&gt;prev-&gt;player_id;</span><br><span class="line">            n = player[b]-&gt;next-&gt;player_id;</span><br><span class="line">            </span><br><span class="line">            player[pp]-&gt;next = player[b];</span><br><span class="line">            player[b]-&gt;prev = player[pp];</span><br><span class="line">            player[b]-&gt;next = player[p];</span><br><span class="line">            player[p]-&gt;next = player[n];</span><br><span class="line">            player[n]-&gt;prev = player[p];</span><br><span class="line">            player[p]-&gt;prev = player[b];</span><br><span class="line">        &#125;<span class="comment">//交換名次的部分，不過應該有方法可以更簡單</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> ind = N+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(player[ind]-&gt;prev!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ind!=N+<span class="number">1</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(player[ind]-&gt;player_id);</span><br><span class="line">        &#125;</span><br><span class="line">        ind = player[ind]-&gt;prev-&gt;player_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超大螢幕設置"><a href="#超大螢幕設置" class="headerlink" title="超大螢幕設置"></a>超大螢幕設置</h3><p><a href="https://neoj.sprout.tw/problem/513/">題目連結</a><br>講師在課堂上有講解這個題目的算法，就是對每個「大樓」（剛剛看才知道）分別往左往右看（單調隊列），看到第一個小於自己就停止<br>單調隊列問了講師之後，參照他的寫法，用vector 儲存「位置的index」而不要用pair ，明顯增加了程式碼的易讀性！</p>
<p><strong>這是用pair 版本</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(temp, i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans[n+<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">    p.<span class="built_in">push</span>(vec[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].first &gt;= p.<span class="built_in">top</span>().first)&#123;</span><br><span class="line">            p.<span class="built_in">push</span>(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!p.<span class="built_in">empty</span>() &amp;&amp; p.<span class="built_in">top</span>().first &gt; vec[i].first)&#123;</span><br><span class="line">                ans[p.<span class="built_in">top</span>().second<span class="number">-1</span>][<span class="number">0</span>] = i-p.<span class="built_in">top</span>().second+<span class="number">1</span>;</span><br><span class="line">                p.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            p.<span class="built_in">push</span>(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ans[p.<span class="built_in">top</span>().second<span class="number">-1</span>][<span class="number">0</span>] = n-p.<span class="built_in">top</span>().second+<span class="number">1</span>;</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="built_in">push</span>(vec[n<span class="number">-1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].first &gt;= p.<span class="built_in">top</span>().first)&#123;</span><br><span class="line">            p.<span class="built_in">push</span>(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!p.<span class="built_in">empty</span>() &amp;&amp; p.<span class="built_in">top</span>().first &gt; vec[i].first)&#123;</span><br><span class="line">                ans[p.<span class="built_in">top</span>().second<span class="number">-1</span>][<span class="number">1</span>] = p.<span class="built_in">top</span>().second-i<span class="number">-1</span>;</span><br><span class="line">                p.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            p.<span class="built_in">push</span>(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ans[p.<span class="built_in">top</span>().second<span class="number">-1</span>][<span class="number">1</span>] = p.<span class="built_in">top</span>().second;</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        sum = vec[i].first*(ans[i][<span class="number">0</span>]+ans[i][<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        total = <span class="built_in">max</span>(total,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而這個是用講師習慣的作法，明顯短了很多：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> arr[n+<span class="number">5</span>],lft[n+<span class="number">5</span>],rht[n+<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]&lt;=arr[stk.<span class="built_in">back</span>()])stk.<span class="built_in">pop_back</span>();</span><br><span class="line">        lft[i] = i-stk.<span class="built_in">back</span>();</span><br><span class="line">        stk.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())stk.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    stk.<span class="built_in">push_back</span>(n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]&lt;=arr[stk.<span class="built_in">back</span>()])stk.<span class="built_in">pop_back</span>();</span><br><span class="line">        rht[i] = stk.<span class="built_in">back</span>()-i<span class="number">-1</span>;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans[n+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans[i<span class="number">-1</span>] = arr[i]*(lft[i]+rht[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;*<span class="built_in">max_element</span>(ans,ans+n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="檸檬汽水傳說（NPSC）"><a href="#檸檬汽水傳說（NPSC）" class="headerlink" title="檸檬汽水傳說（NPSC）"></a>檸檬汽水傳說（NPSC）</h3><p><a href="https://neoj.sprout.tw/problem/22/">題目連結</a><br>這題我覺得很難！<br>一開始想說維護一個遞增的單調隊列，沒想到一直吃WA<br>好吧，上網找答案<br>結果是發現，題目很機車的需要處理相同元素的情況<br>因為一排一樣的數字可以橫跨很多個數字，形成數對<br>好不容易處理完之後上傳code 又吃WA<br>debug 了好久，才發現是因為第一個連續出現的數字好好處理<br>因為第一個數字就算跟後面連續的數字相同也不能再跟前面構成任何數對！<br>總算，經過好久好久，終於才AC ，真是得來不易！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,cnt[<span class="number">1000005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));<span class="comment">//紀錄s當下該數出現次數</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="keyword">int</span> k,top = s.<span class="built_in">size</span>();cin&gt;&gt;k;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>()&lt;k)&#123;</span><br><span class="line">                cnt[top--] = <span class="number">0</span>;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>())s.<span class="built_in">push_back</span>(k);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">back</span>()==k &amp;&amp; top&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    cnt[top+<span class="number">1</span>]+=cnt[top]+<span class="number">1</span>;</span><br><span class="line">                    ans+=cnt[top+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                s.<span class="built_in">push_back</span>(k);ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二元搜尋樹"><a href="#二元搜尋樹" class="headerlink" title="二元搜尋樹"></a>二元搜尋樹</h3><p><a href="https://neoj.sprout.tw/problem/48/">題目連結</a><br>很特別的一題，原來BST 用中序遍歷就是排序好的數列！<br>有了前序跟中序之後，就可以透過遞迴來還原整棵二元樹了！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node *node = <span class="keyword">new</span> Node;</span><br><span class="line">    node-&gt;val = *preorder;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;root_index&lt;length;root_index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[root_index]==*preorder)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = <span class="built_in">BinaryTree</span>(preorder+<span class="number">1</span>, inorder,root_index);</span><br><span class="line">    node-&gt;right = <span class="built_in">BinaryTree</span>(preorder+root_index+<span class="number">1</span>, inorder+root_index+<span class="number">1</span>,length-root_index<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;node-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2005</span>],sorted[<span class="number">2005</span>];</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;arr[n])&#123;</span><br><span class="line">        sorted[n] = arr[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sorted, sorted+n);</span><br><span class="line">    <span class="built_in">BinaryTree</span>(arr, sorted, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="樹重心"><a href="#樹重心" class="headerlink" title="樹重心"></a>樹重心</h3><p><a href="https://neoj.sprout.tw/problem/293/">題目連結</a><br>超愛這一題，竟然可以用DFS 跑一次O(N)把所有的點的資訊全部求出來<br>透過簡單的運算把看起來很複雜的題目很優美的解出來！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Edge[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//子節點總數（扣掉算父節點）</span></span><br><span class="line">    <span class="keyword">int</span> maxn;<span class="comment">//子數最大的那一個</span></span><br><span class="line">&#125;node[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    visit[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = Edge[id].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Edge[id][i];</span><br><span class="line">        <span class="keyword">if</span>(visit[temp]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">dfs</span>(temp);</span><br><span class="line">        node[id].sum += t;</span><br><span class="line">        node[id].maxn = <span class="built_in">max</span>(node[id].maxn,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node[id].sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//initialize</span></span><br><span class="line">            Edge[i].<span class="built_in">clear</span>();</span><br><span class="line">            node[i].maxn = node[i].sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            Edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">            Edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = n,index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">max</span>(node[i].maxn,n-node[i].sum<span class="number">-1</span>);<span class="comment">//子與父求慘度</span></span><br><span class="line">            <span class="keyword">if</span>(temp&lt;ans)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                ans = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>這兩週手寫都是數學證明！<br>有夠悲慘，因為題目很多都不會啊，還要去問老師，結果老師也沒有給出一個好的解方FF<br>換個角度想，就算脫離數學證明，作業一樣不會簡單到哪裡去的！</p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>資芽筆記</tag>
        <tag>樹</tag>
        <tag>資結</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第三週：基礎圖論、淹水問題</title>
    <url>/sprout3/</url>
    <content><![CDATA[<p>前兩次上課還沒來得及補齊，先來紀錄一下第三週的內容</p>
<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>這一週的主題是基礎圖論、淹水問題(BFS)還有Heap!把這幾個單元排在一起真的是負擔很重QQ<br><span id="more"></span></p>
<ul>
<li>基礎圖論之前就有聽過，所以在寫題目感覺還好，不會很吃力</li>
<li>Heap則是我第一次接觸到的資料結構，當周上課前把影片（介紹Binary Heap）之後，上課就直接講合併Heap、黑魔法Heap、左偏樹等等把我電爛的東西</li>
<li>淹水問題，上課沒有特別介紹，因為講師說他不喜歡<em>Flood Fill</em> 演算法所以只講了可以用 <em>dx</em> 和 <em>dy</em> 表示上下左右的方位，其他的都沒講，只能自己看影片了呀～</li>
</ul>
<font color="#f00">這一週是段考週呀</font> 我得花一些時間讀段考，不然段考要爆炸了...</font>

<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><h3 id="Heap-練習"><a href="#Heap-練習" class="headerlink" title="Heap 練習"></a>Heap 練習</h3><p><a href="https://neoj.sprout.tw/problem/59/">題目連結</a><br>刻一個heap嘛，不想刻就call stl( <em>std::priorityqueue</em> 就不放上來了)<br>自己刻一個binary heap ，沒有想象中的簡單，有些細節會不小心漏掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,top=<span class="number">1</span>,heap[<span class="number">1000005</span>];<span class="comment">//complete binary tree</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    heap[top] = n;</span><br><span class="line">    <span class="keyword">int</span> father_pos = top/<span class="number">2</span>,pos = top;</span><br><span class="line">    <span class="keyword">while</span>(father_pos&gt;<span class="number">0</span> &amp;&amp; heap[father_pos]&gt;heap[pos])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[father_pos], heap[pos]);</span><br><span class="line">        pos = father_pos;</span><br><span class="line">        father_pos/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top = top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = heap[<span class="number">1</span>];</span><br><span class="line">    heap[<span class="number">1</span>] = heap[--top];</span><br><span class="line">    heap[top] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>,left = now*<span class="number">2</span>, right = now*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">min</span>(heap[right],heap[left]);</span><br><span class="line">    <span class="keyword">while</span>(heap[left]!=<span class="number">0</span> &amp;&amp; heap[right]!=<span class="number">0</span> &amp;&amp; heap[now]&gt;temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[now]&gt;heap[right] &amp;&amp; heap[left]&gt;heap[right])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[right], heap[now]);</span><br><span class="line">            now = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(heap[now]&gt;heap[left])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[left], heap[now]);</span><br><span class="line">            now = left;</span><br><span class="line">        &#125;</span><br><span class="line">        right = now*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        left = now*<span class="number">2</span>;</span><br><span class="line">        temp = <span class="built_in">min</span>(heap[right],heap[left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(heap[right]!=<span class="number">0</span> &amp;&amp; heap[now]&gt;heap[right])<span class="built_in">swap</span>(heap[right], heap[now]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(heap[left]!=<span class="number">0</span> &amp;&amp; heap[now]&gt;heap[left])<span class="built_in">swap</span>(heap[left], heap[now]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap[<span class="number">1</span>]==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">memset</span>(heap, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(heap));</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> b;cin&gt;&gt;b;</span><br><span class="line">            <span class="built_in">push</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">empty</span>())cout&lt;&lt;<span class="string">&quot;empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">pop</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哪裡有卦，哪裡就有源-TOJ-1101"><a href="#哪裡有卦，哪裡就有源-TOJ-1101" class="headerlink" title="哪裡有卦，哪裡就有源(TOJ 1101)"></a>哪裡有卦，哪裡就有源(TOJ 1101)</h3><p><a href="https://neoj.sprout.tw/problem/1101/">題目連結</a><br>明顯的二分圖水題喔～<br>用 dfs 把經過的點標出黑白，過程中如果遇到問題就表示非二分圖了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">100005</span>],color[<span class="number">100005</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">bool</span> col)</span></span>&#123;</span><br><span class="line">    visit[id] = <span class="number">1</span>;</span><br><span class="line">    color[id] = col;</span><br><span class="line">    <span class="keyword">int</span> len = edge[id].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = edge[id][i];</span><br><span class="line">        <span class="keyword">if</span>(visit[temp])&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[temp]==col)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(temp, !col))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">int</span> m;cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)edge[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(color));</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">            edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">0</span>))&#123;</span><br><span class="line">                    f = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)cout&lt;&lt;<span class="string">&quot;NORMAL.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;RAINBOW.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="喵喵抓老鼠"><a href="#喵喵抓老鼠" class="headerlink" title="喵喵抓老鼠"></a>喵喵抓老鼠</h3><p><a href="https://neoj.sprout.tw/problem/44/">題目連結</a><br>這一題是用BFS找最短路徑，因為沒有權重，所以可以直接用BFS看多久會最先走到老鼠<br>x y 座標原本用2個queue 分別存x跟y ，沒想到MLE了，後來改用struct，還是MLE!!<br>不過在27行的地方有一個Bug，害我找了好久…去問了<font color="#f00">電神</font>，才發現 visit 應該要在push 的時候就紀錄了，不要等到pop的時候，不然很多重複的會被push 進去（簡單來說，一個位置只能被push一次）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 102</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sx,sy;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//左下右上</span></span><br><span class="line"><span class="keyword">char</span> maze[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> visit[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,path;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; qq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now_x = sx, now_y = sy;</span><br><span class="line">    qq.<span class="built_in">push</span>(node&#123;sx,sy,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!qq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        now_x = qq.<span class="built_in">front</span>().x;</span><br><span class="line">        now_y = qq.<span class="built_in">front</span>().y;</span><br><span class="line">        <span class="keyword">if</span>(maze[now_x][now_y]==<span class="string">&#x27;@&#x27;</span>)<span class="keyword">return</span> qq.<span class="built_in">front</span>().path;</span><br><span class="line">        <span class="keyword">int</span> front = qq.<span class="built_in">front</span>().path+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = now_x+dx[i],ny = now_y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(!visit[nx][ny] &amp;&amp; maze[nx][ny]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                qq.<span class="built_in">push</span>(node&#123;nx,ny,front&#125;);</span><br><span class="line">                visit[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        <span class="keyword">while</span>(!qq.<span class="built_in">empty</span>())qq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;maze[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(maze[i]);j++)</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="string">&#x27;K&#x27;</span>)&#123;</span><br><span class="line">                    sx = i;sy = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;=<span class="number">0</span>)cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;= =\&quot;&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="庭院裡的水池"><a href="#庭院裡的水池" class="headerlink" title="庭院裡的水池"></a>庭院裡的水池</h3><p><a href="https://neoj.sprout.tw/problem/42/">題目連結</a><br>看圖形有幾個連通圖的判斷的水題，可以用dfs 或bfs 做，小心index不要戳到負的</p>
<p><strong>BFS作法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">bool</span> maze[<span class="number">1005</span>][<span class="number">1005</span>],visit[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; qx,qy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now_x=x,now_y=y;</span><br><span class="line">    qx.<span class="built_in">push</span>(x);</span><br><span class="line">    qy.<span class="built_in">push</span>(y);</span><br><span class="line">    <span class="keyword">while</span>(!qx.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        now_x = qx.<span class="built_in">front</span>();now_y = qy.<span class="built_in">front</span>();</span><br><span class="line">        visit[now_x][now_y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = now_x+dx[i], ny = now_y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(!visit[nx][ny] &amp;&amp; maze[nx][ny]==<span class="number">1</span>)&#123;</span><br><span class="line">                qx.<span class="built_in">push</span>(nx);</span><br><span class="line">                qy.<span class="built_in">push</span>(ny);</span><br><span class="line">                visit[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qx.<span class="built_in">pop</span>();</span><br><span class="line">        qy.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">&#x27;#&#x27;</span>)maze[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> maze[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="number">1</span> &amp;&amp; visit[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS作法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">bool</span> maze[<span class="number">1005</span>][<span class="number">1005</span>],visit[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; qx,qy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    visit[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x+dx[i], ny = y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(!visit[nx][ny] &amp;&amp; maze[nx][ny]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">&#x27;#&#x27;</span>)maze[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> maze[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==<span class="number">1</span> &amp;&amp; visit[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比較上面兩種方法的複雜度<br><img src="https://i.imgur.com/WfcJ5I8.png" alt=""><br>BFS明顯優於DFS 啊！（遞迴本身來說就很耗記憶體?!應該是這題特殊的原因，不然應該用DFS 較優）</p>
<h3 id="染色遊戲—台北縣98資訊學科能力競賽"><a href="#染色遊戲—台北縣98資訊學科能力競賽" class="headerlink" title="染色遊戲—台北縣98資訊學科能力競賽"></a>染色遊戲—台北縣98資訊學科能力競賽</h3><p><a href="https://neoj.sprout.tw/problem/46/">題目連結1</a><a href="https://neoj.sprout.tw/problem/46/">題目連結2</a></p>
<blockquote>
<p>一題好題勝過百題水題</p>
</blockquote>
<p>現在終於體會到這一句話的精髓！這是一題難題呀（neoj的測資很緊）<br>首先先看<strong>顏色儲存的方式</strong><br>如果我想要讓混色時一個運算進行，那要如何以數字形式儲存顏色就顯德相當重要<br>可以發現，用加法並不是個粉好的方法，因為顏色的數字有可能超過7<br>因此可以用取OR的方式來完成：</p>
<blockquote>
<p>YELLOW : 001<br>BLUE : 010<br>GREEN : 011<br>RED : 100<br>ORANGE : 101<br>PURPLE : 110<br>DARK(BLACK) : 111</p>
</blockquote>
<p>如果以這樣的編碼方式，剛剛好可以以OR運算來就可以模擬染色（這應該只能用觀察出來吧）<br>有了顏色的編碼方式之後，接下來就是處理<strong>點擴散</strong>的問題<br>由 $n&lt;=1000$ 可知，如果要用2個for迴圈走訪整個畫布是不可行的<br>因為這樣就已經$10^6$ 多幾個常數就TLE了。<br>不能走訪每一個點，就只能好好的把要看的點push進queue裡面<br>每一次針對要找的節點，就能節省不必要的運算</p>
<p>最後，要怎麼維護<strong>點</strong>呢？<br>用一個<em>struct</em> 儲存，除了座標之外，就是出現的時間還有顏色<br><div class="note success">
            <p><strong>我遇到TLE 或 WA的BUG：</strong></p><ol><li>用 $n^2$ 掃描整個畫布—TLE</li><li>push進一個struct時要在名字部分<strong>括號起來</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>((node)&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><ol><li>沒有加上遇到減少就break的條件，所以每一次都必須要整個畫布都變成黑色才會輸出—TLE</li><li>沒有紀錄一個點有沒有被三原色走過，一個點可能被走過很多次—TLE</li><li>邊界要好好維護，一個較方便的作法，讓index都從1開始，這樣相加相減變成-1 時才不會RE</li><li>時間優化：明顯知道答案（如問D的情況），就直接輸出$n^2$就好</li></ol>
          </div></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,col[<span class="number">150</span>],dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,board[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1005</span>][<span class="number">1005</span>][<span class="number">5</span>];<span class="comment">//三原色每一個點只能被走一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    col[<span class="string">&#x27;Y&#x27;</span>] = <span class="number">1</span>;col[<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span>;col[<span class="string">&#x27;G&#x27;</span>] = <span class="number">3</span>;col[<span class="string">&#x27;R&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">    col[<span class="string">&#x27;O&#x27;</span>] = <span class="number">5</span>;col[<span class="string">&#x27;P&#x27;</span>] = <span class="number">6</span>;col[<span class="string">&#x27;D&#x27;</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> col[a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,time,color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        queue&lt;node&gt; qq;</span><br><span class="line">        <span class="built_in">memset</span>(board, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(board));</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;b++;c++;</span><br><span class="line">            qq.<span class="built_in">push</span>((node)&#123;b,c,<span class="number">1</span>,<span class="built_in">encode</span>(a)&#125;);</span><br><span class="line">            board[b][c] = <span class="built_in">encode</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="built_in">encode</span>(a),cur_sum = <span class="number">0</span>,ans = <span class="number">0</span>,time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&#x27;B&#x27;</span>||a==<span class="string">&#x27;Y&#x27;</span>||a==<span class="string">&#x27;R&#x27;</span>)cur_sum++;<span class="comment">//當要求的是三原色，初始的數量可以加一</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;n*n&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="comment">//如果是D的話，只需要輸出n^2，可以節省不少時間</span></span><br><span class="line">        <span class="keyword">while</span>(!qq.<span class="built_in">empty</span>())&#123;<span class="comment">//BFS 開始</span></span><br><span class="line">            <span class="keyword">while</span>(!qq.<span class="built_in">empty</span>() &amp;&amp; qq.<span class="built_in">front</span>().time==time)&#123;<span class="comment">//開始每一個時刻的模擬</span></span><br><span class="line">                <span class="keyword">int</span> nx = qq.<span class="built_in">front</span>().x,ny = qq.<span class="built_in">front</span>().y;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = nx+dx[i],y = ny+dy[i];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;=<span class="number">0</span> ||x&gt;n||y&lt;=<span class="number">0</span>||y&gt;n||board[x][y]==<span class="number">7</span>||</span><br><span class="line">                       visit[x][y][qq.<span class="built_in">front</span>().color])<span class="keyword">continue</span>;<span class="comment">//超出邊界或曾拜訪或已塗黑可跳過</span></span><br><span class="line">                    qq.<span class="built_in">push</span>((node)&#123;x,y,time+<span class="number">1</span>,qq.<span class="built_in">front</span>().color&#125;);<span class="comment">//push下一時刻的node</span></span><br><span class="line">                    <span class="keyword">int</span> new_color = board[x][y]|qq.<span class="built_in">front</span>().color;<span class="comment">//比較新的顏色與舊的顏色</span></span><br><span class="line">                    <span class="keyword">if</span>(new_color!=board[x][y])&#123;<span class="comment">//顏色不同時要比較狀況</span></span><br><span class="line">                        <span class="keyword">if</span>(new_color==target)cur_sum++;<span class="comment">//新顏色是但舊顏色不一樣 則加一</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(board[x][y]==target)cur_sum--;<span class="comment">//舊的是新的不是 則減一</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    board[x][y]|=qq.<span class="built_in">front</span>().color;<span class="comment">//對新方塊上色</span></span><br><span class="line">                    visit[x][y][qq.<span class="built_in">front</span>().color] = <span class="number">1</span>;<span class="comment">//此顏色已經拜訪</span></span><br><span class="line">                &#125;</span><br><span class="line">                qq.<span class="built_in">pop</span>();<span class="comment">//pop from queue</span></span><br><span class="line">            &#125;</span><br><span class="line">            time++;<span class="comment">//一輪模擬結束</span></span><br><span class="line">            <span class="keyword">if</span>(ans&gt;cur_sum)<span class="keyword">break</span>;<span class="comment">//因為數量會先非嚴格遞增、後非嚴格遞減</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>這一週的手寫作業是介紹c++ 的記憶體使用方式，什麼變數應該會被存在什麼位置之類的，heap 與stack 還有虛擬記憶體，以及為什麼有時候寫dfs遞迴下去會RE的問題（我是還沒有遇過啦）<br><img src="https://i.imgur.com/mFgJxBF.png" alt=""><br>總之終於沒有數學證明題了！</p>
<hr>
<font color="#f00">今天段考果然炸裂了QQQQQQQ</font>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>資芽筆記</tag>
        <tag>圖論</tag>
        <tag>淹水問題</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第四週：枚舉算法</title>
    <url>/sprout4/</url>
    <content><![CDATA[<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>這一週的主題是<strong>枚舉(enumeration)</strong>，內容主要環繞二分搜、三分搜、DFS剪枝這些部分。<br>這一週的內容算是相對輕鬆，解數獨的部分也是蠻有趣的！<br><span id="more"></span></p>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><h3 id="數獨"><a href="#數獨" class="headerlink" title="數獨"></a>數獨</h3><p><a href="https://neoj.sprout.tw/problem/62/">題目連結</a><br>首先是數獨，很有趣，之前有做過類似的是<strong>八皇后問題</strong><br>用到<strong>DFS剪枝</strong>，<a href="https://peienwu.com/2021/03/07/Sudoku/">筆記在這</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sudoku</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maze[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string s)</span></span>;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan_maze</span><span class="params">()</span></span>;<span class="comment">//</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">select</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next_empty</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solving</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col )</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::print</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;=====&quot;</span>&lt;&lt;s&lt;&lt;<span class="string">&quot;======&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;maze[i][j];</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;|&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Sudoku::select</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> box[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maze[i][c]&gt;<span class="number">0</span>)box[maze[i][c]<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(maze[r][i]&gt;<span class="number">0</span>)box[maze[r][i]<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row_start = <span class="number">3</span>*(r/<span class="number">3</span>),col_start = <span class="number">3</span>*(c/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[row_start+i][col_start+j]&gt;<span class="number">0</span>)</span><br><span class="line">                box[maze[row_start+i][col_start+j]<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!box[i])ans.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sudoku::next_empty</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ind&lt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][ind]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = i*<span class="number">9</span>+ind;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            ind++;</span><br><span class="line">        &#125;</span><br><span class="line">        ind = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="built_in">next_empty</span>(row, col),nr,nc;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; candidate = <span class="built_in">select</span>(row, col);</span><br><span class="line">    <span class="keyword">int</span> len = candidate.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        maze[row][col] = candidate[i];</span><br><span class="line">        pos = <span class="built_in">next_empty</span>(row, col);</span><br><span class="line">        nr = pos/<span class="number">9</span>; nc = pos%<span class="number">9</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nr, nc);</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maze[row][col] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::scan_maze</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&#x27;.&#x27;</span>)maze[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> maze[i][j] = temp -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::solving</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first_empty = <span class="built_in">next_empty</span>(<span class="number">0</span>, <span class="number">0</span>),nr,nc;</span><br><span class="line">    nr = first_empty/<span class="number">9</span>; nc = first_empty%<span class="number">9</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(nr, nc);</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">select</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(v.<span class="built_in">size</span>()&gt;<span class="number">0</span>)f = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag || f)cout&lt;&lt;<span class="string">&quot;No solution.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;solved&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Sudoku sodoku1;</span><br><span class="line">    sodoku1.<span class="built_in">scan_maze</span>();</span><br><span class="line">    sodoku1.<span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">    sodoku1.<span class="built_in">solving</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lotto-UVA"><a href="#Lotto-UVA" class="headerlink" title="Lotto(UVA)"></a>Lotto(UVA)</h3><p><a href="https://neoj.sprout.tw/problem/63/">題目連結</a><br>這一題主要就是建立一個排列樹，把每一種可能的情況用遞迴列出來<br><img src="https://i.imgur.com/cKGOtgP.png" alt=""><br>這一題用DFS明顯比BFS來得好、<strong>空間</strong>省很多（用一下資芽的圖XD)<br><img src="https://i.imgur.com/sOjMiuk.png" alt=""></p>
<p>來看程式碼吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> arr_ind, <span class="keyword">int</span> cur[],<span class="keyword">int</span> cur_ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr_ind&gt;n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur_ind&gt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;cur[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-(<span class="number">6</span>-cur_ind); i++)&#123;</span><br><span class="line">        cur[cur_ind] = arr[arr_ind+i];</span><br><span class="line">        <span class="built_in">permutation</span>(arr_ind+i+<span class="number">1</span>, cur, cur_ind+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(f)cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr+n);</span><br><span class="line">    <span class="keyword">int</span> cur[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">permutation</span>(<span class="number">0</span>, cur, <span class="number">0</span>);</span><br><span class="line">    f=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>這一題必須很小心輸入輸出，它們會讓你WA很久呀！</p><ol><li>行末不要多餘空白</li><li>測資全部印出來後，末端<strong>不要多餘換行</strong></li></ol><p>大概就這兩點</p>
          </div>
<h3 id="田忌賽馬-NPSC"><a href="#田忌賽馬-NPSC" class="headerlink" title="田忌賽馬(NPSC)"></a>田忌賽馬(NPSC)</h3><p><a href="https://neoj.sprout.tw/problem/69/">題目連結</a><br>之前有寫過這一題，不過現在再寫一次還是WA了很久，對於二分搜的維護（到底是取到0還是1）還要更熟悉<br>除此之外，我因為邊界問題（$10^8$ 或是$10^8+1$）沒有仔細注意就一直WA</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">lli n,k,t,M,upper = <span class="number">100000000</span>,lower = <span class="number">-1</span>;  </span><br><span class="line">lli mine[N],develop[N],enemy[N],curr[N];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">win</span><span class="params">(lli day)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> it = <span class="number">0</span>,sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        curr[i] = mine[i]+day*develop[i];  </span><br><span class="line">    <span class="built_in">sort</span>(curr, curr+n);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(curr[i]&gt;enemy[it])&#123;  </span><br><span class="line">            sum++;  </span><br><span class="line">            it++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> (sum&gt;=k);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);  </span><br><span class="line">    cin&gt;&gt;t;  </span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;  </span><br><span class="line">        upper = <span class="number">100000000</span>;lower = <span class="number">-1</span>;  </span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">            cin&gt;&gt;mine[i]&gt;&gt;develop[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">            cin&gt;&gt;enemy[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">sort</span>(enemy, enemy+n);  </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">win</span>(upper))cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(upper-lower!=<span class="number">1</span>)&#123;  </span><br><span class="line">                M = (upper+lower)/<span class="number">2</span>;  </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">win</span>(M))upper = M;  </span><br><span class="line">                <span class="keyword">else</span> lower = M;  </span><br><span class="line">            &#125;  </span><br><span class="line">            cout&lt;&lt;upper&lt;&lt;endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>這樣維護二分搜也可以，就是保證 r 一定是1（l就不一定）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>, arr[n+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)arr[i] = mine[i]+mid*rate[i];</span><br><span class="line">        <span class="built_in">sort</span>(arr, arr+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> f = <span class="built_in">can_win</span>(arr, enemy);</span><br><span class="line">        <span class="keyword">if</span>(f)r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>單純二分搜，找01分界點！</p>
          </div>
<h3 id="Happiness-Function-2013-台清交程式設計競賽"><a href="#Happiness-Function-2013-台清交程式設計競賽" class="headerlink" title="Happiness Function(2013 台清交程式設計競賽)"></a>Happiness Function(2013 台清交程式設計競賽)</h3><p><a href="https://neoj.sprout.tw/problem/72/">題目連結</a><br>很酷的題目，首先必須做一點數學上的分析<br><div class="note info">
            <p>假設題目給定的n個二次函數依序為$A_1(x),A_2(x),…,A_n(x)$<br>令函數$f(t)=max(A_j(t), 1&lt;=j&lt;=n)$<br>則$f(t)$為一個U型函數</p>
          </div><br>有了這個性質之後就可以利用<strong>三分搜</strong>來找U型函數的最小值!</p>
<p>值得注意的是：</p>
<ol>
<li><em>float</em> 是<strong>單精度</strong>浮點數、<em>double</em> 是<strong>雙精度</strong>浮點數，我用 float吃了好幾個WA，結果用double 直接 AC</li>
<li>while 迴圈裡面的判斷不要用浮點數相減，會出事（TLE）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> float a</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">12</span>],b[<span class="number">12</span>],c[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> t, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i]*(t-b[i])*(t-b[i])+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">5</span>);</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        <span class="keyword">double</span> left = <span class="number">0.0</span>, right = <span class="number">300.0</span>;</span><br><span class="line">        <span class="keyword">double</span> now_l = <span class="number">0</span>,now_r = <span class="number">0</span>,nl = <span class="number">0</span>,nr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;=<span class="number">10000</span>)&#123;</span><br><span class="line">            nl = (<span class="number">2</span>*left+right)/<span class="number">3</span>;</span><br><span class="line">            nr = (<span class="number">2</span>*right+left)/<span class="number">3</span>;</span><br><span class="line">            now_l = now_r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)now_r = <span class="built_in">max</span>(now_r, <span class="built_in">func</span>(nr,i));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)now_l = <span class="built_in">max</span>(now_l, <span class="built_in">func</span>(nl,i));</span><br><span class="line">            <span class="keyword">if</span>(now_r &gt; now_l)right = nr;</span><br><span class="line">            <span class="keyword">else</span> left = nl;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;now_l&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>簡單統整，就是三分搜找最低點！</p>
<h3 id="東方古墓古文"><a href="#東方古墓古文" class="headerlink" title="東方古墓古文"></a>東方古墓古文</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/73">題目連結</a><br>這一題主要是二分搜工作量上限X，寫一個函數判斷是否工作量X是否可行<br>Debug 超久，不知道在幹嘛，結果最後是卡在二分搜的上界範圍不夠大<br>要開到$10^9$這麼大！<br>時間複雜度：$N$$log$(總工作量)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n,m,arr[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ok</span><span class="params">(<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;lim)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        <span class="keyword">if</span>(sum+arr[i+<span class="number">1</span>] &gt; lim)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        arr[n] = -INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1000000001</span>,l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r-l &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">is_ok</span>(mid))r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">1000000001</span>)cout&lt;&lt;<span class="number">1000000000</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="極速馬拉松"><a href="#極速馬拉松" class="headerlink" title="極速馬拉松"></a>極速馬拉松</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/60">題目連結</a><br>這一題難的主要是變數太多<br>只要理解它到底要幹嘛，就可以發現可以利用$O(N)$枚舉出固定去間內最大的距離<br>之後再$O(logN)$ 二分搜時間<br>就可以用$O(logN)$ AC這一題</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,m,s,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> speed_time = m/c,max_distance = <span class="number">0</span>,cur_m = m%c;</span><br><span class="line">    <span class="keyword">int</span> cur_distance = b*speed_time,<span class="keyword">cur_t</span> = speed_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">cur_t</span>&lt;time)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = time-<span class="keyword">cur_t</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)&#123;<span class="comment">//時限內最多可以跑多遠</span></span><br><span class="line">            cur_distance = b*speed_time;</span><br><span class="line">            <span class="keyword">cur_t</span> = speed_time+i;</span><br><span class="line">            cur_m = (m%c)+d*i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> step = <span class="built_in">min</span>(cur_m/c,time-<span class="keyword">cur_t</span>);</span><br><span class="line"></span><br><span class="line">            cur_m = cur_m-step*c;</span><br><span class="line">            <span class="keyword">cur_t</span>+=step;</span><br><span class="line">            cur_distance += b*step;</span><br><span class="line"></span><br><span class="line">            cur_distance+=a*(time-<span class="keyword">cur_t</span>);</span><br><span class="line">            max_distance = <span class="built_in">max</span>(max_distance,cur_distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> max_distance = b*time;</span><br><span class="line">    <span class="keyword">return</span> max_distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> max_distance = <span class="built_in">func</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=max_distance)cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl&lt;&lt;max_distance&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">int</span> r = t,l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (r+l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">func</span>(mid)&gt;s)r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="人生低潮"><a href="#人生低潮" class="headerlink" title="人生低潮"></a>人生低潮</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1926">題目連結</a></p>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>手寫作業介紹字串比對、各種排序演算法。這是我算是第一次搞懂快速排序在幹嘛，不然之前都是看兩個指針在指來指去不知道確切的功能是什麼。<br>除了快排之外，基數排序也是第一次看到，原來排序可以做到<strong>線性時間複雜度！</strong><br>大開眼界！（不過只是用於整數排序）<br>這次手寫覺得有些困難，不過學到了很多東西！（可以來做一個各種排序演算的筆記）</p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>資芽筆記</tag>
        <tag>枚舉</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第五週：貪心算法</title>
    <url>/sprout5/</url>
    <content><![CDATA[<p>這一週主題是<strong>Greedy</strong>，其實貪心法的題目要難可以到很難，有點像一個抽象的想法，需要透過反覆的實作與練習（顯然我缺乏），來更容易的想到題目的解法！</p>
<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>影片的內容主要是在證明greedy 的正確性，超複雜的數學證明（又是數學證明！）<br>原本以為上課會延續證明的內容，沒想到完全沒有講到證明的內容，都是在講解例題（也不錯，有很多題需要慢慢理解）<br>所以列了上課講過的例題，一定要搞懂！</p>
<span id="more"></span>
<p><img src="https://i.imgur.com/l9YwEbU.png" alt=""><br>絕對不要輕忽 Greedy 啊，想法看似單純，要想出解法，還是需要經驗的！</p>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><h3 id="Add-all-UVA"><a href="#Add-all-UVA" class="headerlink" title="Add all(UVA)"></a>Add all(UVA)</h3><p><a href="https://neoj.sprout.tw/problem/70/">題目連結</a><br>這一題可以輕鬆觀察出規律：數字越早被相加，被加總的次數就會越多<br>因此，維護一個priority_queue，每次pop出最小的兩個數字再push 回去，可以保證總和一定會是最小的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;qq;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            qq.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(qq.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            a = qq.<span class="built_in">top</span>();qq.<span class="built_in">pop</span>();</span><br><span class="line">            b = qq.<span class="built_in">top</span>();qq.<span class="built_in">pop</span>();</span><br><span class="line">            qq.<span class="built_in">push</span>(a+b);</span><br><span class="line">            ans+=(a+b);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        qq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="円円攻略黃河-TIOJ"><a href="#円円攻略黃河-TIOJ" class="headerlink" title="円円攻略黃河(TIOJ)"></a>円円攻略黃河(TIOJ)</h3><p><a href="https://neoj.sprout.tw/problem/74/">題目連結</a><br>這一題要求最長的長短相間的序列長度，雖然知道是Greedy ，但第一時間想不到具體的作法<br>卡了有一點久，總共嘗試了三次，前兩次以為對，但WA 後還是發現其中的Bug</p>
<ol>
<li>從第一個數字開始，找到下一個比自己小的數字，再找比那一個大的，重複幾次直到結束<div class="note info">
            <p>問題在於，第一個數字可能很小，導致接下來的序列長度很短</p>
          </div></li>
<li>找到第一個「下一個數比自己小」的數字，接著重複第1點的步驟<div class="note info">
            <p>因為要保證序列是最長的，會希望在找比自己大或小的數字時可以盡量最大或最小，才可以確保所有數字能有機會被包含進去</p>
          </div></li>
<li>對每一個數字如果要找大於自己的，就一直繼續往上找直到最大，如果要找最小的也是一樣<div class="note info">
            <p>以 <em>5 1 2 4 5 3 6</em> 來說，就是從5開始，接下來是1（最小了），接下來往上找，可以找到2, 4, 5，而為了盡量讓數字大才能包到接下來的數字（如果選2下一個就不能是3），所以選5，再來就是3 跟6 。<br>所以序列為： <em>5 1 5 3 6</em> ， 長度為5</p>
          </div>
想說應該要AC 了，沒想到沒有memset 所以吃了一個WA ！</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> n,arr[<span class="number">1000005</span>];</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>, ind = <span class="number">0</span>, ans = <span class="number">1</span>;<span class="comment">//0-&gt;down 1-&gt;up</span></span><br><span class="line">        <span class="keyword">while</span>(ind&lt;n &amp;&amp; arr[ind]&lt;=arr[ind+<span class="number">1</span>])ind++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(ind&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height == <span class="number">0</span> &amp;&amp; arr[ind]!=arr[ind+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">while</span>(arr[ind]&gt;=arr[ind+<span class="number">1</span>])ind++;</span><br><span class="line">                height = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(height == <span class="number">1</span> &amp;&amp; arr[ind]!=arr[ind+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">while</span>(arr[ind]&lt;=arr[ind+<span class="number">1</span>])ind++;</span><br><span class="line">                height = <span class="number">0</span>;</span><br><span class="line">                ans+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ind++;<span class="comment">//如果有連續相同數字需要加</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="誰先晚餐"><a href="#誰先晚餐" class="headerlink" title="誰先晚餐"></a>誰先晚餐</h3><p><a href="https://neoj.sprout.tw/problem/89/">題目連結</a><br>按照Greegy 的想法，吃最慢的人要最先吃，吃最快的人要後吃，才能讓整個時間盡量的縮短<br>這一題之前學長講解過，所以自然是比較簡單。But! 要怎麼證明這樣可以得到最佳解呢～留到手寫作業！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> eat,cook;</span><br><span class="line">&#125;people[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(student a,student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.eat &gt; b.eat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;people[i].cook&gt;&gt;people[i].eat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(people, people+n, comp);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,cook = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cook+=people[i].cook;<span class="comment">//煮飯時間一定總數不會改變</span></span><br><span class="line">            <span class="keyword">int</span> leave = cook+people[i].eat;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, leave);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包裝禮物"><a href="#包裝禮物" class="headerlink" title="包裝禮物"></a>包裝禮物</h3><p><a href="https://neoj.sprout.tw/problem/78/">題目連結</a><br>一直吃WA ，吃到懷疑人生哎～<br>想法：由大方塊到小方塊，盡量填滿，如果過程中大小為4的方塊變成負的，可以先欠著，直到最後一次由大小為1的來補，這樣可以確保每一格方塊不是被1*1的填滿就是剩下最少的空格</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,e,f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>&amp;&amp;c==<span class="number">0</span>&amp;&amp;d==<span class="number">0</span>&amp;&amp;e==<span class="number">0</span>&amp;&amp;f==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = f+e+d;</span><br><span class="line">        a = a - <span class="number">11</span>*e;<span class="comment">//5*5可以用11個1*1填</span></span><br><span class="line">        b = b - <span class="number">5</span>*d;<span class="comment">//一個4*4可以用5個2*2填</span></span><br><span class="line">        ans+=(c/<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(c%<span class="number">4</span>!=<span class="number">0</span>)ans++;</span><br><span class="line">        <span class="keyword">if</span>(c%<span class="number">4</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            a = a - <span class="number">7</span>;</span><br><span class="line">            b = b - <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c%<span class="number">4</span>==<span class="number">2</span>)&#123;</span><br><span class="line">            a = a - <span class="number">6</span>;</span><br><span class="line">            b = b - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c%<span class="number">4</span>==<span class="number">3</span>)&#123;</span><br><span class="line">            a = a - <span class="number">5</span>;</span><br><span class="line">            b = b - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=(b/<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">if</span>(b%<span class="number">9</span>!=<span class="number">0</span>)ans++;</span><br><span class="line">            a = a-(<span class="number">36</span><span class="number">-4</span>*(b%<span class="number">9</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b&lt;<span class="number">0</span>)a = a-(<span class="number">4</span>*(-b));<span class="comment">//如果b有欠，可以用a來補</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=a/<span class="number">36</span>;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">36</span>!=<span class="number">0</span>)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="調校高棕櫚"><a href="#調校高棕櫚" class="headerlink" title="調校高棕櫚"></a>調校高棕櫚</h3><p><a href="https://neoj.sprout.tw/problem/91/">題目連結</a><br>如果想要讓數字盡量小，那勢必要讓數字的位數盡量少<br>因此可以先把3個2合併成8，2個3合併成9<br>而剩下的2跟3可以有6 種組合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>數字個數</th>
<th>0個2</th>
<th>1個2</th>
<th>2個2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0個3</td>
<td>無</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>1個3</td>
<td>2</td>
<td>6</td>
<td>2,6</td>
</tr>
</tbody>
</table>
</div>
<p>先把數字做質因數分解，如果有質數大於10，就輸出-1<br>接下來，再用這6種組合用<strong>if</strong> 排列組合就完成了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,arr[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(ind&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%ind==<span class="number">0</span>)&#123;</span><br><span class="line">                n /= ind;</span><br><span class="line">                arr[ind]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ind++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[<span class="number">2</span>]/<span class="number">3</span>;i++)vec.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">        arr[<span class="number">2</span>]=arr[<span class="number">2</span>]%<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[<span class="number">3</span>]/<span class="number">2</span>;i++)vec.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">        arr[<span class="number">3</span>]=arr[<span class="number">3</span>]%<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]==<span class="number">1</span> &amp;&amp; arr[<span class="number">3</span>]==<span class="number">0</span>)vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]==<span class="number">2</span> &amp;&amp; arr[<span class="number">3</span>]==<span class="number">0</span>)vec.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]==<span class="number">0</span> &amp;&amp; arr[<span class="number">3</span>]==<span class="number">1</span>)vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]==<span class="number">1</span> &amp;&amp; arr[<span class="number">3</span>]==<span class="number">1</span>)vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]==<span class="number">2</span> &amp;&amp; arr[<span class="number">3</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[<span class="number">5</span>];i++)vec.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[<span class="number">7</span>];i++)vec.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)cout&lt;&lt;i;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>這一週手寫作業是greedy 正確性的證明，把覺得應該<strong>怎麼</strong>做的想法轉換成數學式子表達，才能讓我們安心的使用greedy ！<br>蠻開心的，上一次以為分數會很低的手寫作業竟然拿到了100/110，就差一點就可以拿滿分了QQ</p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>資芽筆記</tag>
        <tag>貪心</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第六週：分治算法</title>
    <url>/sprout6/</url>
    <content><![CDATA[<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>分治法，一開始講了三個證明遞迴複雜度的方法：</p>
<ol>
<li><strong>取代法：</strong><br>三步驟：Guess, Verify, Solve<br>靠經驗假設，並驗證（加一些常數之類的）</li>
<li><strong>遞迴樹法</strong><br>不太嚴謹，提供猜答案想法，最後用取代法驗證<br>畫出遞迴樹</li>
<li><strong>主定理（Master Theorem）</strong><br>比較f(n) 和 n^(logba)的關係<br>大於等於小於有三個複雜度<span id="more"></span>
</li>
</ol>
<p>還有例題：</p>
<ol>
<li><strong>區間連續最大和</strong><br><a href="https://zerojudge.tw/ShowProblem?problemid=d784">https://zerojudge.tw/ShowProblem?problemid=d784</a><br>中間切一半，max(左右最大值,跨過中間的最大值)<br>時間複雜度：O(NlogN)<br>有辦法O(n)?</li>
<li><strong>多項式乘法</strong><br>Tioj 1064<br>FFT? （快速點的乘法）<br>Karatsuba algorithm，複雜度O(N^1.58)，還可以用在矩陣乘法</li>
<li><strong>平面最近點對</strong><br> cf429D，Tioj<br>平面分治演算法很多都這樣做，先照x座標排序，中間切割：<br>max(兩點都在左邊、兩點都在右邊、跨過分割線答案)<br>求跨過分割線答案：照y座標排序，距離超過d的不要看，因為附近的點是有限個（最近點距離d），大概最多只需要看7個點，可以在常數時間看完所有點</li>
<li><strong>尋找第k大</strong><br> O(N)尋找第k大-利用分治</li>
</ol>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><h3 id="逆序數對"><a href="#逆序數對" class="headerlink" title="逆序數對"></a>逆序數對</h3><p><a href="https://neoj.sprout.tw/problem/125/">題目連結</a><br>這是要求逆序數對的兩個數字的和，總共卡了兩個地方：</p>
<ol>
<li>TLE 計算和的複雜度爆了</li>
<li>WA 數字溢位後爆了</li>
</ol>
<p>第一點的解決方式：對於每一層利用O(N)的時間算前墜和<br>第二點的解決方式：每做完一個運算就mod 一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,n,arr[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nl = l,nr = mid,ind = <span class="number">0</span>,temp[r-l];</span><br><span class="line">    pre[l<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i)pre[i] = pre[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    <span class="keyword">for</span>(;nl&lt;mid;nl++,ind++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[nr]&lt;arr[nl] &amp;&amp; nr&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> times = mid-nl;<span class="comment">//逆序數對的數量</span></span><br><span class="line">            ans+=pre[mid<span class="number">-1</span>]-pre[nl<span class="number">-1</span>];</span><br><span class="line">            ans+=arr[nr]*times;</span><br><span class="line">            ans = ans%<span class="number">10000019</span>;</span><br><span class="line">            temp[ind] = arr[nr];</span><br><span class="line">            nr++;ind++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp[ind] = arr[nl];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nr&lt;r)&#123;<span class="comment">//把剩下沒放的放進去</span></span><br><span class="line">        temp[ind] = arr[nr];</span><br><span class="line">        nr++;ind++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r-l;++i)arr[i+l] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;arr[i]);</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%<span class="number">10000019</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="好的序列"><a href="#好的序列" class="headerlink" title="好的序列"></a>好的序列</h3><p><a href="https://neoj.sprout.tw/problem/789/">題目連結</a><br>題目簡單來說，就是給定n，要構造出一個1~n的序列，其中不包含3個數字以上的等差數列<br><strong>解題想法：</strong> 我看不懂資芽的解法QQ<br>上網扣別人的扣，看幾乎都是同樣一個寫法，把奇數項的放前面，偶數項的放後面，之後不斷分治下去<br>直接實作然後AC ，於是我一直想到底要怎麼證明這個方法是正確的<br>於是我大概想到了一個上黑色白色的一個算合理的推倒吧<br><div class="note success">
            <p>首先，我們把長度為$n$的序列分別交錯塗上黑白<br><img src="https://i.imgur.com/potNo28.png" alt=""><br>再來，把長度為$n$的序列畫一條線分成$[1,\dfrac{n}{2}]$ 與$[\dfrac{n}{2}+1,n]$兩個序列，把奇數次項的數字放入第一個序列，再把偶數次項的序列放入第二個<br><img src="https://i.imgur.com/3oRNe5R.png" alt=""><br>我們可以發現，考慮橫跨中間線的兩邊是否有可能形成等差數列，可以發現是不可能，因為如果要橫跨兩邊，勢必要從一邊選出兩個，另一邊選一個，而同顏色的差為偶數，不同顏色的差必為奇數，因此<strong>不可能構造出橫跨兩邊的等差數列</strong><br>但可以明顯發現，同一顏色是等差數列，其實只要分兩邊分別遞迴下去就可以了，遞迴處理完就是解答<br><img src="https://i.imgur.com/EJTJh8I.png" alt=""><br>遞迴直到長度為2時就可以return 了</p>
          </div></p>
<p>程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,n,arr[N],temp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DC</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> ind = l,mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)temp[i] = arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i+=<span class="number">2</span>)arr[ind++] = temp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>;i&lt;=r;i+=<span class="number">2</span>)arr[ind++] = temp[i];</span><br><span class="line">    <span class="built_in">DC</span>(l, mid);</span><br><span class="line">    <span class="built_in">DC</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)arr[i] = i;</span><br><span class="line">    <span class="built_in">DC</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="王老先生有塊地喔"><a href="#王老先生有塊地喔" class="headerlink" title="王老先生有塊地喔"></a>王老先生有塊地喔</h3><p><a href="https://neoj.sprout.tw/problem/124/">題目連結</a><br>這一題最需要關注的就是把問題縮小的關鍵<br>大範圍不會做，把規模縮到$2\times2$ 大小的方格總可以做了吧」<br>想辦法讓每一個$2\times2$ 大小的方格都有一格是被填滿的<br>剩下三格就很容易放進去<br><strong>注意：</strong> 行跟列的維護很重要，一開始就要想好要怎麼樣定義儲存格，一維二維該放什麼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">bool</span> maze[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DC</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> X,<span class="keyword">int</span> Y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(maze, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">    maze[X][Y] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">DC</span>(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DC</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> new_N = n/<span class="number">2</span>,x_pos=<span class="number">0</span>,y_pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;x+n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;y+n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                x_pos = i;</span><br><span class="line">                y_pos = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span>(x_pos&gt;=x+new_N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y_pos&gt;=y+new_N)pos = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> pos = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y_pos&gt;=y+new_N)pos = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> pos = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nx = x+new_N,ny = y+new_N;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (pos) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">Report</span>(nx, ny, nx<span class="number">-1</span>, ny, nx, ny<span class="number">-1</span>);</span><br><span class="line">            maze[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx<span class="number">-1</span>][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx][ny<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ny = ny<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">Report</span>(nx, ny, nx<span class="number">-1</span>, ny, nx, ny+<span class="number">1</span>);</span><br><span class="line">            maze[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx<span class="number">-1</span>][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx][ny+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            nx = nx<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">Report</span>(nx, ny, nx+<span class="number">1</span>, ny, nx, ny<span class="number">-1</span>);</span><br><span class="line">            maze[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx+<span class="number">1</span>][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx][ny<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            ny = ny<span class="number">-1</span>;nx = nx<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">Report</span>(nx, ny, nx+<span class="number">1</span>, ny, nx, ny+<span class="number">1</span>);</span><br><span class="line">            maze[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx+<span class="number">1</span>][ny] = <span class="number">1</span>;</span><br><span class="line">            maze[nx][ny+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DC</span>(x, y, new_N);</span><br><span class="line">    <span class="built_in">DC</span>(x+new_N, y, new_N);</span><br><span class="line">    <span class="built_in">DC</span>(x, y+new_N, new_N);</span><br><span class="line">    <span class="built_in">DC</span>(x+new_N, y+new_N, new_N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="糟糕陣列"><a href="#糟糕陣列" class="headerlink" title="糟糕陣列"></a>糟糕陣列</h3><p><a href="https://neoj.sprout.tw/problem/128/">題目連結</a><br>其中一種構造方式：對於第i列第i行的「糟糕陣列」，必須滿足聯集為 ${1,2,…,2k-1}$的數字，我們可以先構造出2*2的糟糕陣列，把它複製到右邊（加上邊長）、右下、與下方（加上邊長，複製完之後因為會有重複一個數字，扣掉就好<br><img src="https://i.imgur.com/4G3GaOA.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">1026</span>][<span class="number">1026</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DC</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(maze, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">    maze[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    maze[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    maze[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    maze[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;=N)&#123;</span><br><span class="line">        <span class="built_in">DC</span>(temp);</span><br><span class="line">        temp = temp*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="built_in">Report</span>(maze[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DC</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now_N = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=now_N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=now_N;j++)&#123;</span><br><span class="line">            maze[i+now_N][j] = maze[i][j]+n;</span><br><span class="line">            maze[i][j+now_N] = maze[i][j]+n;</span><br><span class="line">            maze[i+now_N][j+now_N] = maze[i][j];</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j]==<span class="number">1</span>)maze[i][j+now_N]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p><strong>增倍算法！</strong><br>主要是介紹動態陣列，分析複雜度等等的東西<br>上一週的手寫作業被扣爆！</p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>資芽筆記</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第七週：動態規劃（一）</title>
    <url>/sprout7/</url>
    <content><![CDATA[<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><ul>
<li><p><strong>使用DP時機：</strong></p>
<ul>
<li>最優解問題</li>
<li>計數問題</li>
<li>重複子問題</li>
</ul>
</li>
<li><p><strong>DP 使用過程</strong></p>
<ul>
<li>定義狀態</li>
<li>狀態轉移</li>
<li>找到一個會AC的作法，再慢慢優化</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li><p><strong>使用注意事項：</strong></p>
<ul>
<li>寫好時間複雜度</li>
<li>用「拉」的</li>
<li>用「推」的</li>
<li>盡量使用由下而上</li>
</ul>
</li>
<li><p><strong>DP例題</strong></p>
<ul>
<li>跑步問題（zj b589）</li>
<li>最大連續和</li>
<li>最大不連續和（npsc 2017）</li>
<li>Chest of Drawers (UVA 11420)</li>
<li>最大和矩陣問題</li>
<li>矩陣最大方形</li>
<li>矩陣乘法問題</li>
<li>消消樂（UVA 10559 Blocks）</li>
</ul>
</li>
</ul>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><h3 id="円円數磁磚"><a href="#円円數磁磚" class="headerlink" title="円円數磁磚"></a>円円數磁磚</h3><p><a href="https://neoj.sprout.tw/problem/138/">題目連結</a><br>我不會寫轉移式子啊…<br>首先可以觀察到，因為兩個磁磚的排法有3種，首先可以列出$f(n) = 3\times f(n-2)$ 這個式子，但觀察之後可以發現，如果排列的磁磚不能被兩兩分割，也可是一種新的排法。而對於固定的尺寸大小只會有一種排法，但因為可以顛倒放，因此視為兩種組合。<br><strong>轉移式：</strong><br>$f(n) = 3\times f(n-2)+2\times(f(n-4)+f(n-6)…)$<br>經過數學帶入消去：<br>$f(n-2) = 3\times f(n-4)+2\times(f(n-6)+f(n-8)…)$<br>$f(n) = 4\times f(n-2)-f(n-4)$</p>
<p><strong>邊界：</strong>$dp[0] = 1, dp[2] = 3$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;dp[<span class="number">2</span>] = <span class="number">3</span>;dp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">100001</span>;i+=<span class="number">2</span>)dp[i] =(<span class="number">4</span>*dp[i<span class="number">-2</span>]-dp[i<span class="number">-4</span>]+<span class="number">1000007</span>)%<span class="number">1000007</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">        cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="円円送禮物"><a href="#円円送禮物" class="headerlink" title="円円送禮物"></a>円円送禮物</h3><p><a href="https://neoj.sprout.tw/problem/140/">題目連結</a><br>以後寫DP幾種組合問題就是像這一題一樣暴力破解<br>把每一種情況都寫清楚，不惜開三維陣列也沒關係<br>總之，$dp[i][k][j]$ 代表長度為i，左邊為顏色k，右邊為顏色j<br>（紅色：0、綠色：1、藍色：2）<br>列出每一種狀態的轉移式就好<br>不過，即使頭尾是一藍一綠，但也必須轉移，因為一藍一綠可以在頭或尾加上其他顏色，組成合法解，不過不要輸出就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100005</span>][<span class="number">3</span>][<span class="number">3</span>];<span class="comment">//0:red,1:green,2:blue</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">2</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">2</span>][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">0</span>] = dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>] = dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;<span class="number">100005</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">2</span>])%<span class="number">1000007</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>])%<span class="number">1000007</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">2</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">2</span>])%<span class="number">1000007</span>;</span><br><span class="line">        </span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">2</span>])%<span class="number">1000007</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>])%<span class="number">1000007</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">2</span>] = (dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">2</span>])%<span class="number">1000007</span>;</span><br><span class="line">        </span><br><span class="line">        dp[i][<span class="number">2</span>][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">2</span>])%<span class="number">1000007</span>;</span><br><span class="line">        dp[i][<span class="number">2</span>][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>])%<span class="number">1000007</span>;</span><br><span class="line">        dp[i][<span class="number">2</span>][<span class="number">2</span>] = (dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">2</span>])%<span class="number">1000007</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;cin&gt;&gt;a;</span><br><span class="line">        cout&lt;&lt;(dp[a][<span class="number">0</span>][<span class="number">0</span>]+dp[a][<span class="number">0</span>][<span class="number">1</span>]+dp[a][<span class="number">0</span>][<span class="number">2</span>]+dp[a][<span class="number">1</span>][<span class="number">0</span>]+dp[a][<span class="number">1</span>][<span class="number">1</span>]+dp[a][<span class="number">2</span>][<span class="number">0</span>]+dp[a][<span class="number">2</span>][<span class="number">2</span>])%<span class="number">1000007</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取數字1"><a href="#取數字1" class="headerlink" title="取數字1"></a>取數字1</h3><p><a href="https://neoj.sprout.tw/problem/141/">題目連結</a><br><strong>定義：</strong>$dp[i]$ 為取第i個數字的的最大值<br><strong>轉移式：</strong>$dp[i] = max(dp[i-2]+dp[i-2])+arr[i]$<br>可以發現到，因為$arr[i]$ 都是正數，因此加越多數字就代表最後的數值越大，而相鄰的兩項不能轉移，因此就要看$dp[i-2],dp[i-2]$其中i-4不用看是因為已經包含在i-2裡面了<br><strong>邊界：</strong>$dp[1] = arr[1],dp[2] = arr[2],dp[3] = arr[1]+arr[3]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,arr[<span class="number">100005</span>];cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        dp[<span class="number">1</span>] = arr[<span class="number">1</span>];dp[<span class="number">2</span>] = arr[<span class="number">2</span>];dp[<span class="number">3</span>] = arr[<span class="number">1</span>]+arr[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>],dp[i<span class="number">-3</span>])+arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(dp[n],dp[n<span class="number">-1</span>])&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取數字2"><a href="#取數字2" class="headerlink" title="取數字2"></a>取數字2</h3><p><a href="https://neoj.sprout.tw/problem/142/">題目連結</a><br>上面取數字1的進階版，可以一樣定義，不過轉移式要稍微改變（其實就只是把原本只有2的區間擴大成k）<br><strong>定義：</strong>$dp[i]$ 為取第i個數字的的最大值<br><strong>轉移式：</strong><br>$dp[i]=max(arr[j]+arr[i]),2k\leq i \leq n,i-2k\leq j \leq i-k$<br>轉移式比較複雜一點，不過就是取數字1的延伸<br><strong>邊界：</strong><br>$dp[i] = arr[i],1\leq i \leq k$<br>$dp[i]=max(arr[j]+arr[i]),k+1\leq i \leq 2k,1\leq j \leq i-k$</p>
<p>邊界的話，如果要說成是轉移式也是可以啦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,arr[<span class="number">100005</span>],k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">        <span class="comment">//[1,k]的邊界轉移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)dp[i] = arr[i];</span><br><span class="line">        <span class="comment">//[k+1,2k]的邊界轉移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;=<span class="number">2</span>*k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i-k;j++)&#123;<span class="comment">//看可以配上[1,k]最大的那一個</span></span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],arr[j]+arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-2</span>*k;j&lt;=i-k;j++)&#123;<span class="comment">//開始轉移，掃描k次</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max_element</span>(dp, dp+n+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合成円円"><a href="#合成円円" class="headerlink" title="合成円円"></a>合成円円</h3><p><a href="https://neoj.sprout.tw/problem/143/">題目連結</a><br>開始接觸到區間DP，比單純的DP又多了一些要注意的地方<br>上網查關於區間DP的資料，一般都會有這些內容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (枚舉區間長度)</span><br><span class="line">    <span class="keyword">for</span> (枚舉左端點)</span><br><span class="line">        <span class="keyword">for</span> (枚舉分割點)</span><br><span class="line">            f[l, r] = f[l, k] + f[k, r] + val(l, r)</span><br></pre></td></tr></table></figure>
<p>主要就是，從小的區間長度開始（大的區間需要小的區間的答案），枚舉左端點可以知道區間的範圍，接著再依序枚舉在區間內分割點，把長度為n的區間長度跑完之後就完成了<br>有了這一個$O(n^3)$ 的演算法，就可以開始來實作</p>
<p><strong>定義：</strong><br>$dp[i][j]$ $(1 \leq i,j \leq n)$ 為合併區間 $[i,j]$ 所需要的花費<br><strong>轉移式：</strong><br>$dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum_{i,j}),i \leq k \leq j$<br>合併區間$dp[i][k],dp[k+1][j]$的花費為兩者相加再加上區間[i,j]的總和（可以用前綴維護）<br><strong>邊界：</strong><br>$dp[i][i] = 0,1 \leq i \leq n$</p>
<p>這個演算法的複雜度是$O(n^3)$，之後可以用dp優化的技巧做到更快</p>
<div class="note success">
            <p><strong>問題：這題可不可以用Greedy？</strong><br>我們如果每一次都找兩兩相鄰相加總和最小的兩個加起來，做n-1次，是不是可以找到最佳解？（如果可以，那幹嘛還要辛苦維護$n^3$的算法XD）</p><p>Q:答案是不行，那要反例何時出現？</p><blockquote><p>10 7 6 7</p></blockquote><p>這一組測資如果用Greedy做是63，用dp做是60，可以發現到，如果數字兩兩相加相等，那先加後加的順序就很重要，有可能因為順序不對（先加中間的7跟6），導致7沒辦法跟10合併產生更加的解法！</p><p><strong>找反例的方法：</strong> 這一筆測資是利用隨機生成大量的數字去找出有沒有不一樣，方法by:<br><img src="https://i.imgur.com/rPWTsXk.png" alt=""></p>
          </div>
<p>這一題就先這樣，不過區間DP感覺就是可以很難的東西<br>時間複雜度$O(n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,arr[<span class="number">105</span>],pre[<span class="number">105</span>];cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f3f3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)&#123;<span class="comment">//區間[i,j]長度為len，則j = i+len-1</span></span><br><span class="line">                <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+pre[j]-pre[i<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>這一週沒有手寫！因為下禮拜是第一階段認證考</p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>動態規劃</tag>
        <tag>DP</tag>
        <tag>資芽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第八週：動態規劃（二）</title>
    <url>/sprout8/</url>
    <content><![CDATA[<p>這兩週真是風風雨雨，首先第一週是段考週，所以有很多時間拿去惡補段考。第二週則是疫情關係要在家裡線上上課，結果進度就辣了一大截…趕快追QQ！</p>
<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>一堆的背包問題（真的很多種耶）</p>
<p><strong>01背包問題</strong><br><strong>無限背包問題</strong></p>
<ul>
<li><p>先固定背包數量看價值跟先固定價值看背包數量可以互換</p>
<span id="more"></span>
<p><strong>有限背包問題</strong></p>
</li>
<li><p>多枚舉每個物品要放入的數量</p>
</li>
<li>拆分：把同重量的物品看成不同的物品（複雜度不變）</li>
<li>把$t_i$ 個物品拆成$\lfloor \log_2 t_i+1\rfloor$個物品</li>
<li>分成的堆數最少：$\lceil \log{t_i}+1\rceil$(因為分成 $k$ 堆最多只可能有 $2^k$ 個值)</li>
<li>複雜度：$O(n\log{max(t_i)}W)$</li>
</ul>
<p><strong>混合背包問題</strong></p>
<ul>
<li>遇到什麼樣的物品就怎麼做（對有限個背包拆分）</li>
<li>分成01背包跟無限背包做</li>
</ul>
<p><strong>二維背包問題</strong></p>
<ul>
<li>多一維度狀態轉移（可以壓掉一個維度）</li>
</ul>
<p><strong>分組背包問題</strong></p>
<ul>
<li>再多一維儲存第幾組</li>
</ul>
<p><strong>背包合併</strong></p>
<ul>
<li>直接把物品混起來做</li>
</ul>
<p><strong>背包問題變化</strong></p>
<ul>
<li>(1)求最大價值的方法總數<ul>
<li>用g[i] 儲存重量i 的方法數</li>
</ul>
</li>
<li>(2)求最大價值的一組方案<ul>
<li>g[i] 看有沒有被更新過，有就g[I] = 1，回溯找</li>
</ul>
</li>
<li>(3)求最大價值的字典序最小的一組方案<ul>
<li>把物品倒過來（由大到小）因為越小的(1)要最後考慮，否則1先考慮後面的大的數字會把1覆蓋掉，字典序就變大</li>
</ul>
</li>
<li>(4)求次大價值的解/第K大價值的解<ul>
<li>看投影片</li>
</ul>
</li>
</ul>
<p><strong>分數背包</strong></p>
<ul>
<li>Greedy</li>
</ul>
<p><strong>不同做法複雜度</strong></p>
<ul>
<li>用價值做狀態</li>
<li>用重量做狀態</li>
<li><font color="#f00">V, W都很大但n很小？<ul>
<li>枚舉$2^n$ <font color="#000"></li>
</ul>
</li>
<li>如果V, W都很大n也蠻大？<ul>
<li>折半枚舉（meet in the middle）根號算法</li>
</ul>
</li>
</ul>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><p>背包問題主要有三個變量：價值、重量、物品數量，因此可以有三個作法：</p>
<ol>
<li>以物品數量n 作為狀態，爆搜，複雜度：$O(2^n)$</li>
<li>以價值v 作為狀態(v為物品價值總和），dp作，複雜度：$O(NV)$</li>
<li>以重量w 作為狀態(w為物品重量上限），dp作，複雜度：$O(NW)$</li>
</ol>
<h3 id="高棕櫚農場"><a href="#高棕櫚農場" class="headerlink" title="高棕櫚農場"></a>高棕櫚農場</h3><p><a href="https://neoj.sprout.tw/problem/157/">題目連結</a><br>這一題不能用重量做，因為重量的範圍可以到$10^5$，因此只能用價值來做<br>有一個要點，無限大可以memset定義為<strong>0x3f3f3f3f</strong>，以十進位表示1061109567，在int的範圍但不會超過</p>
<h4 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h4><p>定義$f(n,m)$為取n樣物品,價值恰為m,重量總和最小值</p>
<h4 id="轉移方式"><a href="#轉移方式" class="headerlink" title="轉移方式"></a>轉移方式</h4><p>$f(n,m) = min(f(n-1,m), f(n-1,m-v_n)+w_n), m ≧ v_n$<br>$f(n,m) = f(n-1,m), m &lt; v_n$</p>
<h4 id="邊界條件"><a href="#邊界條件" class="headerlink" title="邊界條件"></a>邊界條件</h4><p>f(0,0) = 0, f(0,k) = INF (k&gt;0)$<br>因為取零樣物品價值要k不可能達到，因此重量設為無限大</p>
<p>我們可以藉由滾動dp來節省空間，壓成一維（跟用重量作為狀態一樣）<br>最後，在從dp裡面取出max(k), for all f(N,k) ≦ W</p>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,val[<span class="number">105</span>],weight[<span class="number">100005</span>];cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">        <span class="comment">//定義f(n,m)取n樣物品,價值為m,重量總和最小</span></span><br><span class="line">        <span class="comment">//dp[i]：價值為i時,重量最小為dp[i]</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10000</span>;j&gt;=val[i];j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j],dp[j-val[i]]+weight[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高棕櫚農場2"><a href="#高棕櫚農場2" class="headerlink" title="高棕櫚農場2"></a>高棕櫚農場2</h3><p><a href="https://neoj.sprout.tw/problem/158/">題目連結</a><br>有些細節是必須要注意的，也就是初始化的細節。<br><div class="note success">
            <p><strong>背包問題是否恰好裝滿</strong></p><p>對於原本初始化dp[0] = 0，代表對於重量限制為0的背包價值最高為0<br>接下來有兩種情況需要討論，第一種是重量限制為w的背包最多的價值</p><p><strong>1. 恰好裝滿</strong><br>此時必須初始化dp[i] = -INF，是因為要恰好裝滿的關係，初始化的dp 數組事實上就是<strong>在沒有任何物品可以放入背包時的合法狀態</strong>，其他除了0之外容量的背包均沒有合法的解，屬於未定義的狀態，所以都應該被賦值為 −∞ 。當前的合法解，一定是從之前的合法狀態推得的(−∞跟−∞取max還是−∞)</p><p><strong>2. 不需恰好裝滿</strong><br>如果背包並非必須被裝滿，那麼任何容量的背包都有一個合法解“什麼也不裝”，這個解的價值為0,所以初始化時狀態的值也就全部為0了。</p><p>如果來看轉移式，$dp[j] = max(dp[j],dp[j-weight[i]]+val[i])$，如果兩者的狀態都屬於未定義，對於需恰好裝滿的狀況，兩者都是−∞，表示沒有合法的狀態可以構成此重量。同時，如果不需恰好裝滿的情況，即使$dp[j]$和$dp[j-weight[i]]$都未定義(等於0)，還是可以被更新（在沒有裝滿的情況下，dp[j] = val[i]）</p>
          </div><br>這一題除了以上發現，還有一個很重要的東西，就是迴圈到底要放哪一層的問題。主要是卡在 for(int p=1;p&lt;=k;p++)到底要放在哪一層的問題，結果是要放在第三層。<br><div class="note info">
            <p>問題一：dp[j][p]取決於dp[j][p] 和dp[j-weight[i]][p-1]，而且對於一個物品最多只能放一次，如果放在第二層，dp[j-weight[i]][p-1] 就已經被更新過了，有可能已經取了第 i 樣物品會有重複取的問題，如果放在第三層，代表對每一種不同的重量先更新放入幾樣物品的1到k，再更新重量，這樣就可以保證dp[j][p]不會取到已經更新的格子（dp[j][p] 沒被更新、dp[j-weight[i]][p-1] 其中第一維的j-weight[i] 也還沒被更新）</p><p>問題二：p要從1到k還是k到1，這其實都可以，因為要取的格子不管從前往後或後往前取都只會取到上一輪(i-1) 的更新東西，因此不影響。還有，因為是定義<strong>最多取p樣物品</strong>，所以無論i為多少，每一次p皆要更新的k（如果k=5，取一樣物品也符合情況）</p>
          </div></p>
<h4 id="定義-1"><a href="#定義-1" class="headerlink" title="定義"></a>定義</h4><p>定義$f(j,p)$看完 <em>i</em> 樣物品後，重量限制為j，<strong>最多</strong>取p樣物品的最大價值</p>
<h4 id="轉移方式-1"><a href="#轉移方式-1" class="headerlink" title="轉移方式"></a>轉移方式</h4><p>$dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i])$</p>
<h4 id="邊界條件-1"><a href="#邊界條件-1" class="headerlink" title="邊界條件"></a>邊界條件</h4><p>$dp[i][j] = 0$ (for all elements in dp)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,k,val[<span class="number">105</span>],weight[<span class="number">10005</span>];cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">105</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=weight[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;p++)&#123;</span><br><span class="line">                    dp[j][p] = <span class="built_in">max</span>(dp[j][p],dp[j-weight[i]][p<span class="number">-1</span>]+val[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[m][k]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 0 4 5 6 6 6</span></span><br><span class="line"><span class="comment"> 0 4 5 6 9 10</span></span><br><span class="line"><span class="comment"> 0 4 5 6 9 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="玩電梯"><a href="#玩電梯" class="headerlink" title="玩電梯"></a>玩電梯</h3><p><a href="https://neoj.sprout.tw/problem/416/">題目連結</a><br><a href="https://codeforces.com/problemset/problem/479/E">題目連結2</a></p>
<p>這一題要用到3個重要的技巧：前綴和、差分、滾動dp<br>差分在某一次手寫作業有寫到，不過那時候沒有很注意這個部分就是了<br><div class="note info">
            <p><strong>差分</strong></p><p>差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：</p><script type="math/tex; mode=display">b_i = \begin{cases}a_i-a_{i-1}, &\text{if }i\gt 1 \\a_1, & \text{if } i = 1\end{cases}</script><p>差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：</p><ol><li>定義一個新的陣列 $b_i$ 表示每一項差分</li><li>設 $b<em>l = b_l+v$，$b</em>{r+1} = b_{r+1}-v$</li><li>將差分的每一項加上前一項，即為原數列 $b<em>i = b</em>{i-1}+b_i$</li></ol><p>第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了O(1)了！</p>
          </div></p>
<p>這一題使用到差分的技巧，讓原本的$O(kn^2)$減少成$O(kn)$，然後就可以過了！</p>
<h4 id="定義-2"><a href="#定義-2" class="headerlink" title="定義"></a>定義</h4><p>定義 $dp[i][j]$ 為第 i 次走到樓層j的方法數</p>
<h4 id="轉移式"><a href="#轉移式" class="headerlink" title="轉移式"></a>轉移式</h4><p>這題如果用拉的比較不好想，所以改用推的試試看<br>$dp[i+1][j] = dp[i+1][j]+dp[i][p],$ for $j\in[p-r],[p+1,p+r],r = |p-b|-1$</p>
<h4 id="邊界條件-2"><a href="#邊界條件-2" class="headerlink" title="邊界條件"></a>邊界條件</h4><p>$dp[0][a] = 1$</p>
<p>轉移式比較複雜一點，不過可以用差分優化搭配前綴和把原本$O(n)$的時間降到$O(1)$<br>從這一題可以發現到，用拉的和用推的有不同的使用時機，可以以思考方式比較清楚的想法去想轉移式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,a,b,k,dp[<span class="number">2</span>][<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sec</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    l = <span class="built_in">max</span>(l,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>);</span><br><span class="line">    r = <span class="built_in">min</span>(r,n);</span><br><span class="line">    dp[(id+<span class="number">1</span>)%<span class="number">2</span>][l] = <span class="built_in">modify</span>(dp[(id+<span class="number">1</span>)%<span class="number">2</span>][l]+v);</span><br><span class="line">    dp[(id+<span class="number">1</span>)%<span class="number">2</span>][r+<span class="number">1</span>] = <span class="built_in">modify</span>(dp[(id+<span class="number">1</span>)%<span class="number">2</span>][r+<span class="number">1</span>]-v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][a] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;k;s++)&#123;  <span class="comment">//每一次電梯移動</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">//每一樓層轉移</span></span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">abs</span>(b-i)<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">sec</span>(i-d,i<span class="number">-1</span>,dp[s%<span class="number">2</span>][i],s);</span><br><span class="line">            <span class="built_in">sec</span>(i+<span class="number">1</span>,i+d,dp[s%<span class="number">2</span>][i],s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[(s+<span class="number">1</span>)%<span class="number">2</span>][i] += dp[(s+<span class="number">1</span>)%<span class="number">2</span>][i<span class="number">-1</span>];</span><br><span class="line">            dp[(s+<span class="number">1</span>)%<span class="number">2</span>][i] = <span class="built_in">modify</span>(dp[(s+<span class="number">1</span>)%<span class="number">2</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dp[(s)%<span class="number">2</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=dp[k%<span class="number">2</span>][i];</span><br><span class="line">        ans = <span class="built_in">modify</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8樓、2樓開始、5樓不能去、2次電梯</span></span><br></pre></td></tr></table></figure>
<h3 id="取名字好困難QQ"><a href="#取名字好困難QQ" class="headerlink" title="取名字好困難QQ"></a>取名字好困難QQ</h3><p><a href="https://neoj.sprout.tw/problem/421/">題目連結</a><br>跟題目一樣，我覺得要通靈才能想到這一題的作法！<br>結果是問了別人才大概感受到這一種作法！！！<br><img src="https://i.imgur.com/EmxSHqM.png" alt=""></p>
<p>我們既然不知道到底一個數字要不要乘2，我們可以透過做LIS的過程來做決定。當我們把乘與2之後的數字跟原本數字一起push進去，就可以發現到LIS不可能同時取到2個數字。利用這個方法就可以用LIS的過程決定一個數字到底應該要變2倍還是不用。<br>要找到最長的非嚴格遞增序列，最大的差別就是要把原本的lower_bound改成upper_bound。一整天想一題的感覺超級糟糕QQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*temp&lt;m)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;m)&#123;</span><br><span class="line">            temp*=<span class="number">2</span>;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="number">2</span>*temp);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">size</span>()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正常做LIS</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; lis;<span class="keyword">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">    lis.<span class="built_in">push_back</span>(vec[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lis.<span class="built_in">back</span>()&lt;=vec[i])lis.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">        <span class="keyword">else</span> *<span class="built_in">upper_bound</span>(lis.<span class="built_in">begin</span>(),lis.<span class="built_in">end</span>(),vec[i]) = vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;lis.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>這一週是講歸約法，作業如下：<br><img src="https://i.imgur.com/amWVYo0.jpg" alt=""><br>這一週手寫作業的狀況還不錯，71/75，不過第一題是緊急向別人求救才把答案改掉<br><img src="https://i.imgur.com/GMtrB99.png" alt=""><br>原本是寫B，後來改A，原因有以下兩點：</p>
<ol>
<li>因為函數在 return 時不會把 stack memory 上的資料清空，所以所有的區域變數都會被留在 stack memory 上，其他函數可能會共用到同一塊記憶體空間。</li>
<li>有可能會對非法的陣列位址取值(RE的情況)，而存取到別的函數的區域變數。</li>
</ol>
<p>所以A是錯誤的！<br>下面是解答的畫法，其實跟我蠻像的XDD<br><img src="https://i.imgur.com/NyN0Kwy.png" alt=""></p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>動態規劃</tag>
        <tag>DP</tag>
        <tag>資芽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>數獨問題（Sudoku）：以C++實作</title>
    <url>/sudoku/</url>
    <content><![CDATA[<p>資訊之芽的上課內容，用了幾節下課加回家的時間把程式實作出來<br>用紙跟筆解數獨的過程就是把所有可能剔除明顯不可能的之後下去試，如果遇到問題就換下一種方式<br><img src="https://i.imgur.com/WrGCOnx.png" alt=""><br><span id="more"></span><br>用程式模擬也是一樣的概念，先把明顯不可能的情況剔除，接下來就一一透過DFS搜尋下去，如果碰壁就回朔回來<br><a href="https://neoj.sprout.tw/problem/62/">NEOJ</a>、<a href="https://tioj.ck.tp.edu.tw/problems/1025">TIOJ</a>（他的範測給得不是很好閱讀XD</p>
<h2 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h2><p>先想出以下的實作步驟，就可以透過程式碼實現</p>
<ol>
<li>讀測資並處理</li>
<li>從左到右、由上而下，找出下一個要填入數字的位置</li>
<li>對每一個點要知道有哪些數字可以被放入（把明顯不行的剔除）</li>
<li>從左上角的空格開始DFS</li>
</ol>
<p>大概就是這一些實作步驟，如果用物件導向class 把所有東西包起來，<del>看起來比較厲害</del><br><strong>DFS 剪枝！</strong></p>
<p><strong>整個大致架構：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sudoku</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maze[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan_maze</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">select</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next_empty</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solving</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>這可以讓main函式顯得更簡單：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Sudoku sodoku1;<span class="comment">//宣告物件</span></span><br><span class="line">    sodoku1.<span class="built_in">scan_maze</span>();<span class="comment">//讀入測資</span></span><br><span class="line">    sodoku1.<span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>);<span class="comment">//印出目前數獨（未解）</span></span><br><span class="line">    sodoku1.<span class="built_in">solving</span>();<span class="comment">//開始解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="輸入與輸出"><a href="#輸入與輸出" class="headerlink" title="輸入與輸出"></a>輸入與輸出</h2><p>設計一個印出數獨的函式，讓輸出方便閱讀一點（一行81個字元有夠醜。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::print</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;=====&quot;</span>&lt;&lt;s&lt;&lt;<span class="string">&quot;======&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;maze[i][j];</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;|&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下來是讀入測資，0代表空格</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::scan_maze</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&#x27;.&#x27;</span>)maze[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> maze[i][j] = temp -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<strong>好的輸出</strong>可以讓眼睛比較輕鬆一點Q</p>
<h2 id="檢查哪些數字可以試試"><a href="#檢查哪些數字可以試試" class="headerlink" title="檢查哪些數字可以試試"></a>檢查哪些數字可以試試</h2><p>這一個函式主要是實現上面的第三點，把明顯不行（在同一行、列、方格）出現過的數字剔除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Sudoku::select</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> box[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//把出現過的數字紀錄下來</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maze[i][c]&gt;<span class="number">0</span>)box[maze[i][c]<span class="number">-1</span>] = <span class="number">1</span>;<span class="comment">//同一列</span></span><br><span class="line">        <span class="keyword">if</span>(maze[r][i]&gt;<span class="number">0</span>)box[maze[r][i]<span class="number">-1</span>] = <span class="number">1</span>;<span class="comment">//同一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row_start = <span class="number">3</span>*(r/<span class="number">3</span>),col_start = <span class="number">3</span>*(c/<span class="number">3</span>);<span class="comment">//方格起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">//同一方格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[row_start+i][col_start+j]&gt;<span class="number">0</span>)</span><br><span class="line">                box[maze[row_start+i][col_start+j]<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!box[i])ans.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//把可以試試看得數字push進vector後回傳</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在遞迴的時候很需要知道下一個要填空的位置在哪裏，又題目要求如果有多組解要輸出<strong>字典序最小</strong>的解，所以要從左而右再由上而下開始找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sudoku::next_empty</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ind = col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ind&lt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][ind]==<span class="number">0</span>)&#123;<span class="comment">//找到0就停止</span></span><br><span class="line">                <span class="keyword">int</span> pos = i*<span class="number">9</span>+ind;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            ind++;</span><br><span class="line">        &#125;</span><br><span class="line">        ind = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找不檔任何空格，已經填滿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="開始遞迴"><a href="#開始遞迴" class="headerlink" title="開始遞迴"></a>開始遞迴</h2><p>DFS!<br>跟八皇后問題很像，都只不過八皇后問題只有<strong>放跟不放</strong>的問題，而數獨是要決定<strong>放什麼</strong>進去<br>首先，找到第一個空格之後DFS，在DFS結束後記得要確認數獨<font color="#f00">結果有沒有符合數獨原本的定義</font>(要不然只會對第一個子題QQ)<br><div class="note success">
            <p>Q: 明明空格是一個一個填上去，為啥還要再檢查一次？<br>A: 經過一小時的debug 之後發現，他給的測資不一定合法呀！<br>可能測資只有第一行第一格一空格，很高興填上去然後說 YA!解完了，但其實在第九行第九格出現了重複數字?!根本不會檢查到啊，但對第一行第一格一空格來說，一切都符合規則、很美好</p>
          </div></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::solving</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first_empty = <span class="built_in">next_empty</span>(<span class="number">0</span>, <span class="number">0</span>),nr,nc;</span><br><span class="line">    nr = first_empty/<span class="number">9</span>; nc = first_empty%<span class="number">9</span>;<span class="comment">//找到出發點</span></span><br><span class="line">    <span class="built_in">dfs</span>(nr, nc);<span class="comment">//dfs下去</span></span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;<span class="comment">//81個數字再check一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">select</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(v.<span class="built_in">size</span>()&gt;<span class="number">0</span>)f = <span class="literal">true</span>;<span class="comment">//DFS完正常大小要是0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag || f)cout&lt;&lt;<span class="string">&quot;No solution.&quot;</span>&lt;&lt;endl;<span class="comment">//無解</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&quot;solved&quot;</span>);<span class="comment">//印出解</span></span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>對每一種可能進行遞迴：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sudoku::dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="built_in">next_empty</span>(row, col),nr,nc;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;<span class="comment">//有一組解了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; candidate = <span class="built_in">select</span>(row, col);</span><br><span class="line">    <span class="keyword">int</span> len = candidate.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        maze[row][col] = candidate[i];</span><br><span class="line">        pos = <span class="built_in">next_empty</span>(row, col);</span><br><span class="line">        nr = pos/<span class="number">9</span>; nc = pos%<span class="number">9</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nr, nc);</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span>;<span class="comment">//如果要輸出很多組解的話可以刪掉這行</span></span><br><span class="line">    &#125;</span><br><span class="line">    maze[row][col] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>這份程式碼只是為了上傳oj，所以只需要一種情況就好<br><a href="https://pastebin.com/bxhCmAPV">完整程式碼在這</a><br>不過，也可以用程式把每一種方法都列出來，數量可以多到不可想像！(我用程式跑了一下，結果直接它直接不理我，上網查才發現 $5\times 10^{27}$之多，天荒地老也算不完！）</p>
<p>這是測試用的數獨：<br><img src="https://i.imgur.com/fYCm4Vq.jpg" alt=""></p>
<p>這是用線上解數獨的軟題跑出來的結果：<br><img src="https://i.imgur.com/twbkUm1.png" alt=""><br>這是程式實測跑出來的結果，都吻合：<br><img src="https://i.imgur.com/7I2kwtZ.png" alt=""></p>
<h2 id="相關延伸：八皇后問題"><a href="#相關延伸：八皇后問題" class="headerlink" title="相關延伸：八皇后問題"></a>相關延伸：八皇后問題</h2><p><a href="https://leetcode.com/problems/n-queens-ii/">題目連結</a><br>這一份程式碼是leetcode八皇后問題的解。像下面這一張圖就是一組合法的解，透過遞迴可以找出每一組解。</p>
<p><img src="https://i.imgur.com/gEH8Zyo.png" alt=""></p>
<p>網路上的資料指出這是一個$NP-Complete$的問題，表示並沒有多項式時間的解法。透過2個簡單的函數（是否可行、遞迴函數）即可實作出來。以下表格給出n為1到11的合法解個數：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>10</td>
<td>4</td>
<td>40</td>
<td>92</td>
<td>352</td>
<td>724</td>
<td>2680</td>
</tr>
</tbody>
</table>
</div>
<p>可以利用這個解直接丟原本的題目，就可以贏過78.93%的Submission（還是乖乖用遞迴寫啦） XD<br><img src="https://i.imgur.com/SMItJxP.png" alt=""></p>
<p>以下是用遞迴寫的程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turn_zero</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x==i &amp;&amp; y==k)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp[i][k])</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(i-x)==<span class="built_in">abs</span>(k-y)||y==k)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Queen_Problem</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            temp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(<span class="number">1</span>,n);</span><br><span class="line">            temp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isSafe</span>(row,i,n))&#123;</span><br><span class="line">                temp[row][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">DFS</span>(row+<span class="number">1</span>,n);</span><br><span class="line">                temp[row][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">turn_zero</span>(n);</span><br><span class="line">        <span class="built_in">Queen_Problem</span>(n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++基礎主題</category>
        <category>枚舉</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>數獨</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>歐拉函數 (Euler&#39;s φ Function)</title>
    <url>/totient/</url>
    <content><![CDATA[<p>多元選修課提到歐拉函數 $\phi$，想說蠻有趣的可以跟程式結合一下，看會發生什麼有趣的事情！</p>
<h2 id="定義與公式"><a href="#定義與公式" class="headerlink" title="定義與公式"></a>定義與公式</h2><p>對於一個正整數 $n$，歐拉函數 $\phi(n)$ 表示閉區間 $[1,n]$ 中的正整數與 $n$ 互質的個數。定義序列 $p$ 為所有正整數 $n$ 質因數分解之後的數字。在不失一般性的假設序列 $p$ 的長度為 $r$，以質因數分解表示 $n$ 即為 $n = p_1^{k_1}\cdot p_2^{k_2}\cdots p_r^{k_r}$，則歐拉函數滿足以下關係式：</p>
<script type="math/tex; mode=display">\begin{split}\phi(n) &= n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_r})
\\&=n\prod_{p|n}(1-\frac{1}{p})
\end{split}</script><span id="more"></span>
<p>特別定義 $\phi(1) = 1$</p>
<p>來看看實際的例子，以20為例。以質因數分解來看，$20 = 2^2\times 5$，因此序列 $p = {2,5}$，則歐拉函數 $\phi(20) = 20\times (1-\frac{1}{2})(1-\frac{1}{5}) = 8$，稍微驗證一下，從1到20的正整數中，與20互質的有 $1,3,7,9,11,13,17,19$ 一共8個數字。</p>
<h2 id="推導與證明"><a href="#推導與證明" class="headerlink" title="推導與證明"></a>推導與證明</h2><h3 id="證明1"><a href="#證明1" class="headerlink" title="證明1"></a>證明1</h3><p>證明一個公式，可以先多加上一些限制，從簡單推導到較複雜的情況。</p>
<ol>
<li><p>$n$ 是質數<br>這種情況比較好處理，因為所有小於等於 $n$ 的正整數都會和 $n$ 互質，因此對於 $n$ 是質數的情況下：</p>
<script type="math/tex; mode=display">\phi(n) = n-1</script></li>
<li><p>$n$ 是合數<br>首先看簡化的情況。假設 $n = p^a$，其中 $p$ 為質數，$a$ 為一大於等於2的正整數。因為 $p$ 是質數，所有不和 $p$ 互質的數字大概會是以下這些：$p,2p,3p,…,(p^{a-1})p$，一共有 $p^{a-1}$ 個數字。我們只要把所有的數字扣掉這些即為歐拉函數 $\phi$ 的函數值：</p>
<script type="math/tex; mode=display">\phi(p^a) = p^a - p^{a-1} = p^a(1-\frac{1}{p})</script></li>
</ol>
<p>由這個式子推廣到歐拉函數原本的公式。我們讓 $n = p_1^{k_1}\cdot p_2^{k_2}\cdots p_r^{k_r}$，因為歐拉函數為一<a href="https://zh.wikipedia.org/wiki/%E7%A9%8D%E6%80%A7%E5%87%BD%E6%95%B8">積性函數</a>，滿足 $\phi(nm) = \phi(n)\phi(m)$，其證明如下：</p>
<p>觀察一個有 $m$ 列 $n$ 行的矩陣，一共有 $mn$ 個數字，從 $1$ 到 $mn$ 。如以下矩陣：</p>
<script type="math/tex; mode=display">\begin{matrix}
1 & 2 & \cdots & n
\\n+1 & n+2 & \cdots & 2n
\\\vdots&\vdots&\ddots&\vdots
\\(m-1)n+1 &  & \cdots & mn
\end{matrix}\quad</script><p>因為每一列都是加上不定數量的 $n$，我們從第一列挑出 $\phi(n)$ 個與 $n$ 互質的數，其他每一列也都是如此，把他們設為 $t<em>1,t_2,…,t</em>{\phi(n)}$：</p>
<script type="math/tex; mode=display">\begin{matrix}
t_1 & t_2 & \cdots & t_{\phi(n)}
\\n+t_1 & n+t_2 & \cdots & n+t_{\phi(n)}
\\\vdots&\vdots&\ddots&\vdots
\\(m-1)n+t_1 &  & \cdots & (m-1)n+t_{\phi(n)}
\end{matrix}\quad</script><p>觀察一下每一直行，由於 $n$ 和 $m$ 互質，同一直行中的每一個數字和 $m$ 都會不同餘。在不同餘的情況下，每一直行都會有 $\phi(m)$ 個與 $m$ 互質的數字。因此，從上面的矩陣可以發現總共有 $\phi(n)\phi(m)$ 個與 $nm$ 互質的數字，因此有$\phi(nm)=\phi(n)\phi(m)$。</p>
<p>有了上述性質之後，我們就可以直接推導公式：</p>
<script type="math/tex; mode=display">\begin{split}\phi(n) &=\phi(p_1^{k_1})\cdot\phi(p_2^{k_2})\cdots\phi(p_r^{k_r})
\\&=p_1^{k_1}(1-\frac{1}{p_1})\cdot p_2^{k_2}(1-\frac{1}{p_2})\cdots p_r^{k_r}(1-\frac{1}{p_r})
\\&=p_1^{k_1}\cdot p_2^{k_2}\cdots p_r^{k_r}\cdot(1-\frac{1}{p_1})\cdot(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_r})
\\&= n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_r})\end{split}</script><p>以上就是歐拉函數公式的推導過程！</p>
<h3 id="證明2"><a href="#證明2" class="headerlink" title="證明2"></a>證明2</h3><p>使用到的是排容原理。這個證明就沒有像上面那麽繁雜，不過有點難理解就是了。首先我們討論 $n$ 的質因數分解由三個質數組成，寫成：$n = p_1^{k_1}\cdot p_2^{k_2}\cdot p_3^{k_3}$，假設在小於等於 $n$ 中能被 $p_1$,$p_2$,$p_3$ 給整除的數字集合為 $A_1,A_2,A_3$，則我們要求的就是：</p>
<script type="math/tex; mode=display">(A_1' \cap A_2' \cap A_3') = (A_1 \cup A_2 \cup A_3)'</script><p>我們要求的就是聯集的補集的部分：<br><img src="https://i.imgur.com/iEWH5Na.png" alt=""></p>
<p>這是公式展開的情況：</p>
<script type="math/tex; mode=display">\begin{split}\phi(n) &= n(1-\frac{1}{p_1})(1-\frac{1}{p_2})(1-\frac{1}{p_3})
\\&=n(1-\frac{1}{p_1}-\frac{1}{p_2}-\frac{1}{p_3}+\frac{1}{p_1p_2}+\frac{1}{p_1p_3}+\frac{1}{p_2p_3}-\frac{1}{p_1p_2p_3})
\\&=(n-\frac{n}{p_1}-\frac{n}{p_2}-\frac{n}{p_3}+\frac{n}{p_1p_2}+\frac{n}{p_1p_3}+\frac{n}{p_2p_3}-\frac{n}{p_1p_2p_3})\end{split}</script><p>這展開之後跟集合寫成的樣子是一樣的，根據排容原理也間接證明公式的正確性！</p>
<h2 id="程式實現"><a href="#程式實現" class="headerlink" title="程式實現"></a>程式實現</h2><p>基本概念就是從2開始往後找所有的質因數，因為個數不重要，只要每一次找到之後更新答案即可。值得注意的是，最後必須對剩下的 $n$ 在做一次，其原因不難理解，當我有兩個質因數剩下還沒有被 i 走過的時候，因為兩個互質，因此必定有一個數會在迴圈內被走到，剩下那一個留下來的就會在外面被更新答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans - ans/i;</span><br><span class="line">            <span class="keyword">while</span>(n % i==<span class="number">0</span>)n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)ans = ans - ans/n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">phi</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這是用程式跑出來的<a href="https://gist.github.com/peienwu/39cf7c563bae22597ac1d185b12c535f">1到10000的歐拉函數</a>，可以參考看看！</p>
<h2 id="好難的圖形"><a href="#好難的圖形" class="headerlink" title="好難的圖形"></a>好難的圖形</h2><p>這張圖是歐拉函數的函數圖形，x軸是 $n$，y軸則是 $\phi(n)$。利用python的matplotlib模組繪製出來的！</p>
<p>以下為待解決問題：</p>
<ul>
<li>$(n,\phi(n))$ 的圖形中，斜率為 $1,\frac{1}{2},\frac{2}{3},\frac{4}{5},\frac{1}{3}$，其原因？</li>
<li>這些斜率是否可以求出數字落在每一條線上的機率？</li>
<li>函數總和的圖形，其方程式是如何推導的？</li>
<li>函數總和公式的誤差圖形呈現類似常態分佈，求其原因。</li>
<li>倒數總和的公式如何推導？</li>
<li>最後一個極限下界公式的推導，跟歐拉-馬斯刻若尼常數關係為何？</li>
</ul>
<h3 id="一般的-n-與-phi-n-關係圖"><a href="#一般的-n-與-phi-n-關係圖" class="headerlink" title="一般的 $n$ 與 $\phi(n)$ 關係圖"></a>一般的 $n$ 與 $\phi(n)$ 關係圖</h3><p>我覺得這東西超酷，有一條斜率為1的很明顯的直線，他代表的是 $\phi(n) = n-1$，這種情況就是當 $n$ 屬於質數的時候會發生。</p>
<p>$n$ 的範圍是1到150<br><img src="https://i.imgur.com/ltC2iws.png" alt=""></p>
<p>$n$ 的範圍是1到1500<br><img src="https://i.imgur.com/RuDTbyB.png" alt=""></p>
<p>$n$ 的範圍是1到10000<br><img src="https://i.imgur.com/jqCNkkL.png" alt=""></p>
<h4 id="斜率-frac-1-2-的情況"><a href="#斜率-frac-1-2-的情況" class="headerlink" title="斜率 $\frac{1}{2}$ 的情況"></a>斜率 $\frac{1}{2}$ 的情況</h4><p>這是嘗試解決問題的區域。</p>
<p>首先，我把斜率為 $0.5\pm0.01$ 的點全部描出來，大概就是這樣：<br><img src="https://i.imgur.com/YbTOlb3.png" alt=""></p>
<p>小範圍跑出來，在100內一共有6個符合條件的數字，分別是：</p>
<blockquote>
<p>2<br>4<br>8<br>16<br>32<br>64</p>
</blockquote>
<p>哇！一切豁然開朗。當 $n$ 為 2 的冪次時，就只有一個 $2$ 是質因數，因此 $\phi(n) = n(1-\frac{1}{2}) = \frac{n}{2}$。但這樣的數字只會越來越少，但點卻沒有變得越來越稀疏，於是我們必須加大數字範圍觀察，<a href="https://gist.github.com/peienwu/aeedeeb925a346f3f6e2cbef04a097ae">數字的列表在這</a>，丟到線上<a href="https://nap.st/prime_factorization_calculator/?lang=zh-TW#result">質因數分解器</a>，會發現有很多數字都是有2個因數，其中一個為2，另外一個為一個較大的質數，數字越大對影響力就越小，因此他們會在斜率為 $\frac{1}{2}$ 的線上。</p>
<p><img src="https://i.imgur.com/qNe9XyV.png" alt=""></p>
<p>像1964就會是$\frac{1}{2}\times \frac{490}{491}$，後面的影響很小，所有大致上接近 $\frac{1}{2}$。</p>
<h4 id="斜率-frac-1-3-的情況"><a href="#斜率-frac-1-3-的情況" class="headerlink" title="斜率 $\frac{1}{3}$ 的情況"></a>斜率 $\frac{1}{3}$ 的情況</h4><p>紅線標出來的是斜率為 $\frac{1}{3}$ 的線條。<br><img src="https://i.imgur.com/h1SdBSa.png" alt=""></p>
<p>情況大概就是這幾種，這些質因數算出來大概就是 $\frac{1}{3}$ 左右。<br><img src="https://i.imgur.com/DBn0tXP.png" alt=""><br><img src="https://i.imgur.com/TDIjZKr.png" alt=""></p>
<h4 id="斜率-frac-2-3-的情況"><a href="#斜率-frac-2-3-的情況" class="headerlink" title="斜率 $\frac{2}{3}$ 的情況"></a>斜率 $\frac{2}{3}$ 的情況</h4><p><img src="https://i.imgur.com/1ykO0vo.png" alt=""></p>
<p>這些數字很多事3乘上某個大質數。<br><img src="https://i.imgur.com/OfSOsrW.png" alt=""></p>
<h4 id="斜率-frac-4-5-的情況"><a href="#斜率-frac-4-5-的情況" class="headerlink" title="斜率 $\frac{4}{5}$ 的情況"></a>斜率 $\frac{4}{5}$ 的情況</h4><p><img src="https://i.imgur.com/GmB7mdI.png" alt=""></p>
<p>一樣的情況，大多是5盛放某個大質數<br><img src="https://i.imgur.com/xHLnmVr.png" alt=""></p>
<h4 id="來比較一下"><a href="#來比較一下" class="headerlink" title="來比較一下"></a>來比較一下</h4><p><img src="https://i.imgur.com/sX2I4ry.png" alt=""></p>
<p>我們設定不同的 $n$ ，看在不同值域中個別斜率上面的點的數量，不過因為我設了小數點後兩位當作可接受的誤差範圍，因此會稍微多一點：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">斜率/次數</th>
<th>1000</th>
<th style="text-align:left">10000</th>
<th style="text-align:left">100000</th>
<th style="text-align:left">1000000</th>
<th>10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td>144</td>
<td style="text-align:left">1205</td>
<td style="text-align:left">10860</td>
<td style="text-align:left">118298</td>
<td>1186321</td>
</tr>
<tr>
<td style="text-align:left">1/2</td>
<td>152</td>
<td style="text-align:left">1425</td>
<td style="text-align:left">13531</td>
<td style="text-align:left">141771</td>
<td>1401372</td>
</tr>
<tr>
<td style="text-align:left">1/3</td>
<td>78</td>
<td style="text-align:left">858</td>
<td style="text-align:left">8031</td>
<td style="text-align:left">82782</td>
<td>826322</td>
</tr>
<tr>
<td style="text-align:left">2/3</td>
<td>67</td>
<td style="text-align:left">721</td>
<td style="text-align:left">6131</td>
<td style="text-align:left">65638</td>
<td>664881</td>
</tr>
<tr>
<td style="text-align:left">4/5</td>
<td>32</td>
<td style="text-align:left">387</td>
<td style="text-align:left">3281</td>
<td style="text-align:left">33560</td>
<td>348334</td>
</tr>
<tr>
<td style="text-align:left">其他</td>
<td>572</td>
<td style="text-align:left">5404</td>
<td style="text-align:left">58166</td>
<td style="text-align:left">557951</td>
<td>5572770</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">斜率</th>
<th style="text-align:left">點的占比</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">11.86%</td>
</tr>
<tr>
<td style="text-align:left">1/2</td>
<td style="text-align:left">14.01%</td>
</tr>
<tr>
<td style="text-align:left">1/3</td>
<td style="text-align:left">8.26%</td>
</tr>
<tr>
<td style="text-align:left">2/3</td>
<td style="text-align:left">6.65%</td>
</tr>
<tr>
<td style="text-align:left">4/5</td>
<td style="text-align:left">3.48%</td>
</tr>
<tr>
<td style="text-align:left">其他</td>
<td style="text-align:left">55.73%</td>
</tr>
</tbody>
</table>
</div>
<p>我想要計算一下他們變化的狀況：</p>
<p><img src="https://i.imgur.com/XHbmuYD.png" alt=""><br><img src="https://i.imgur.com/t2hmRro.png" alt=""></p>
<p>觀察圖形，好像有那麼一點會趨近於一個常數之類的，不過當數字超過 $10^7$ 之後，不管是用 C++或是 PYTHON 都跑不太出來。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phi</span>(<span class="params">n</span>):</span></span><br><span class="line">    ans = <span class="built_in">int</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i*i &gt; n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            ans = ans - ans/i</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n = n / i</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        ans = ans - ans/n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line">x2 = []</span><br><span class="line">y2 = []</span><br><span class="line">times = [<span class="number">1000000</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000000</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now = &quot;</span>,i/<span class="number">100000</span>)</span><br><span class="line">        ans = <span class="built_in">int</span>(phi(i))</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(ans)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(ans/i-(<span class="number">4</span>/<span class="number">5</span>)) &lt;= <span class="number">0.01</span>:</span><br><span class="line">            x2.append(i)</span><br><span class="line">            y2.append(ans)</span><br><span class="line">            <span class="comment">#print(i)</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cnt = &quot;</span>,cnt)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.1)</span></span><br><span class="line"><span class="comment">#plt.plot(x,y,&#x27;o&#x27;,markersize = 1)</span></span><br><span class="line"><span class="comment">#plt.plot(x2,y2,&#x27;o&#x27;,markersize = 1,c = &quot;red&quot;)</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phi</span>(<span class="params">n</span>):</span></span><br><span class="line">    ans = <span class="built_in">int</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i*i &gt; n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            ans = ans - ans/i</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n = n / i</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        ans = ans - ans/n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1500</span>+<span class="number">1</span>):</span><br><span class="line">    ans = <span class="built_in">int</span>(phi(i))</span><br><span class="line">    x.append(i)</span><br><span class="line">    y.append(ans)</span><br><span class="line">    </span><br><span class="line">plt.vlines(x, <span class="number">0</span>, y, linestyle=<span class="string">&quot;-&quot;</span>,linewidth=<span class="number">0.1</span>)</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;o&#x27;</span>,markersize = <span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="總和的關係圖"><a href="#總和的關係圖" class="headerlink" title="總和的關係圖"></a>總和的關係圖</h3><p>除此之外，這個東西也很酷，以下是 $f(n)$ 與 $n$ 的關係圖。滿足以下式子：</p>
<script type="math/tex; mode=display">f(n) = \sum^n_{i=1}\phi(i)</script><p><img src="https://i.imgur.com/DCeZ39L.png" alt=""></p>
<p>上網查後發現這一條線可以用一個關係式表達：</p>
<script type="math/tex; mode=display">f(n) = \sum^n_{i=1}\phi(i) = \frac{3n^2}{\pi^2}</script><p>下圖藍線就是公式的圖，紅色的點則是 $\phi(n)$：<br><img src="https://i.imgur.com/JZRTUeC.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phi</span>(<span class="params">n</span>):</span></span><br><span class="line">    ans = <span class="built_in">int</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i*i &gt; n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            ans = ans - ans/i</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n = n / i</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        ans = ans - ans/n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    s = (math.pi)*(math.pi)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x*x/s</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line">y2 = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    ans = <span class="built_in">int</span>(phi(i))</span><br><span class="line">    <span class="built_in">sum</span> += ans</span><br><span class="line">    x.append(i)</span><br><span class="line">    y2.append(func(i))</span><br><span class="line">    y.append(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;o&#x27;</span>,color = <span class="string">&#x27;red&#x27;</span>,markersize = <span class="number">2</span>)</span><br><span class="line">plt.plot(x,y2,color = <span class="string">&#x27;blue&#x27;</span>,markersize = <span class="number">0.1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>如果計算一下這一條理論線跟實際的誤差繪製出來的圖形：</p>
<script type="math/tex; mode=display">\frac{1}{n}(\sum^n_{i=1}\phi(i)-\frac{3n^2}{\pi^2})</script><p><img src="https://i.imgur.com/Bv80qbM.png" alt=""></p>
<p>很酷喔，當我把每一個誤差的數字當做x軸，y軸則是發生的次數，跑了1000000次之後，他的圖會出來會是像這樣，有點像常態分佈的東西（網路上是說埃爾米特多項式乘上高斯函數之類的東西）：</p>
<blockquote>
<p>The histogram has a distinctive shape, maybe hard to prove. I suspect it’s the Gaussian Unitary Ensemble (a Hermite polynomial times a Gaussian).</p>
</blockquote>
<p><img src="https://i.imgur.com/i45SvDB.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phi</span>(<span class="params">n</span>):</span></span><br><span class="line">    ans = <span class="built_in">int</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i*i &gt; n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            ans = ans - ans/i</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n = n / i</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        ans = ans - ans/n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    s = (math.pi)*(math.pi)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x*x/s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line">box = [<span class="number">0</span>]*<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    box[i] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10000000</span>+<span class="number">1</span>):</span><br><span class="line">    ans = <span class="built_in">int</span>(phi(i))</span><br><span class="line">    <span class="built_in">sum</span> += ans</span><br><span class="line">    temp = <span class="built_in">int</span>(((<span class="built_in">sum</span>-func(i))/i)*<span class="number">2000</span>)</span><br><span class="line">    box[temp] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cur = &quot;</span>,i/<span class="number">100000</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1400</span>):</span><br><span class="line">    x.append(i/<span class="number">2000</span>)</span><br><span class="line">    y.append(box[i])</span><br><span class="line"></span><br><span class="line">plt.vlines(x, <span class="number">0</span>, y, linestyle=<span class="string">&quot;-&quot;</span>,linewidth=<span class="number">0.4</span>)</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;o&#x27;</span>,markersize = <span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="倒數加總的圖形"><a href="#倒數加總的圖形" class="headerlink" title="倒數加總的圖形"></a>倒數加總的圖形</h3><p>下圖則是每一個 $\phi$ 的倒數繪製出來的圖形：</p>
<script type="math/tex; mode=display">f(n) = \sum^n_{i=1}\frac{1}{\phi(i)}</script><p><img src="https://i.imgur.com/7fm1u48.png" alt=""></p>
<p>很酷，但我一樣不知道怎麼解釋</p>
<h3 id="取一堆怪怪的東西"><a href="#取一堆怪怪的東西" class="headerlink" title="取一堆怪怪的東西"></a>取一堆怪怪的東西</h3><p>還沒有結束，這一張圖表示的是 $n$ 對上 $\phi(n)\frac{\ln\ln n}{n}$ 呈現的圖形，據說會滿足以下關係式：</p>
<script type="math/tex; mode=display">\lim_{n\to\infty}\inf\phi(n)\frac{\ln\ln n}{n} = e^{-\gamma}</script><p>指數次方上面是歐拉-馬斯刻若尼常數，畫出來的圖長這樣：</p>
<p><img src="https://i.imgur.com/hA52Dxs.png" alt=""></p>
<p>一樣，公式有夠複雜！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phi</span>(<span class="params">n</span>):</span></span><br><span class="line">    ans = <span class="built_in">int</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i*i &gt; n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            ans = ans - ans/i</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                n = n / i</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        ans = ans - ans/n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5000</span>+<span class="number">1</span>):</span><br><span class="line">    ans = <span class="built_in">int</span>(phi(i))</span><br><span class="line">    x.append(i)</span><br><span class="line">    temp = np.log(i)</span><br><span class="line">    ans *= np.log(temp)</span><br><span class="line">    </span><br><span class="line">    y.append(ans/i)</span><br><span class="line">    </span><br><span class="line">plt.vlines(x, <span class="number">0</span>, y, linestyle=<span class="string">&quot;-&quot;</span>,linewidth=<span class="number">0.05</span>)</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;o&#x27;</span>,markersize = <span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>參考連結：</strong></p>
<ul>
<li><a href="https://mathworld.wolfram.com/TotientFunction.html">連結1</a></li>
<li><a href="https://mathworld.wolfram.com/TotientSummatoryFunction.html">連結2</a></li>
<li><a href="https://mathworld.wolfram.com/search/?query=Totient+Function&amp;x=0&amp;y=0">連結3</a></li>
</ul>
<h2 id="P2303-SDOI2012-Longge-的问题"><a href="#P2303-SDOI2012-Longge-的问题" class="headerlink" title="P2303 [SDOI2012] Longge 的问题"></a>P2303 [SDOI2012] Longge 的问题</h2><p><a href="https://www.luogu.com.cn/problem/P2303">題目敘述</a><br><a href="https://www.luogu.com.cn/record/57881277">Submission</a></p>
<p>這是歐拉函數簡單的應用，對於一個輸入 $n$ 要輸出的是 $\sum_{i=1}^n gcd(i,n)$，也就是每一個數字與 $n$ 的最大公因數總和。簡單的概念就是，$O(n)$ 枚舉所有的因數 $i$ 作為最大公因數，此時只要看與 $\frac{n}{i}$ 互質的數量，$i\times\phi(\frac{n}{i})$ 就會是以 $i$ 作為最大公因數的總和。</p>
<p>特別注意到，我們可以在枚舉 $i$ 的時候，也可以順便處理 $\frac{n}{i}$ 的情況，這樣就可以只枚舉 $\sqrt{n}$ 次就好了！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans - ans/i;</span><br><span class="line">            <span class="keyword">while</span>(n % i==<span class="number">0</span>)n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)ans = ans - ans/n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> qt = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans += (n/i) * <span class="built_in">phi</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i*i!=n)ans += i * <span class="built_in">phi</span>(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>高二上筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS CLASS PART 1</title>
    <url>/apcs1/</url>
    <content><![CDATA[<p>這是2021年暑期APCS課程的所有題目參考解答，共有34題。</p>
<h2 id="A-基礎程式設計-基礎C-程式設計複習"><a href="#A-基礎程式設計-基礎C-程式設計複習" class="headerlink" title="A. [基礎程式設計] 基礎C++程式設計複習"></a>A. [基礎程式設計] 基礎C++程式設計複習</h2><h3 id="a064-成績指標"><a href="#a064-成績指標" class="headerlink" title="a064/ 成績指標"></a>a064/ 成績指標</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[<span class="number">25</span>];cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n);</span><br><span class="line">    cout&lt;&lt;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;arr[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>]&gt;=<span class="number">60</span>)cout&lt;&lt;<span class="string">&quot;best case&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;*(<span class="built_in">lower_bound</span>(arr,arr+n,<span class="number">60</span>)<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(arr[n<span class="number">-1</span>]&lt;<span class="number">60</span>)cout&lt;&lt;<span class="string">&quot;worst case&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;*(<span class="built_in">lower_bound</span>(arr,arr+n,<span class="number">60</span>))&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a096-時間差計算"><a href="#a096-時間差計算" class="headerlink" title="a096/ 時間差計算"></a>a096/ 時間差計算</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1,b1,c1,a2,b2,c2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>,&amp;a1,&amp;b1,&amp;c1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>,&amp;a2,&amp;b2,&amp;c2);</span><br><span class="line">    <span class="keyword">int</span> a = a1*<span class="number">3600</span>+b1*<span class="number">60</span>+c1,b = a2*<span class="number">3600</span>+b2*<span class="number">60</span>+c2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(b-a&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b-a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>,temp/<span class="number">3600</span>,(temp%<span class="number">3600</span>)/<span class="number">60</span>,temp%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">86400</span>+b-a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>,temp/<span class="number">3600</span>,(temp%<span class="number">3600</span>)/<span class="number">60</span>,temp%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a104-雪花片片"><a href="#a104-雪花片片" class="headerlink" title="a104/ 雪花片片"></a>a104/ 雪花片片</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,product[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(product,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(product));</span><br><span class="line">    product[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">80</span>;j++)&#123;</span><br><span class="line">            product[j]=product[j]*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">80</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(product[j]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                product[j+<span class="number">1</span>] += product[j]/<span class="number">10</span>;</span><br><span class="line">                product[j] %=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    product[<span class="number">0</span>]-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">80</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        product[i] += temp*<span class="number">10</span>;</span><br><span class="line">        temp = product[i]%<span class="number">3</span>;</span><br><span class="line">        product[i] /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">80</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(product[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;product[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="B-函式-公用函式、自定函式"><a href="#B-函式-公用函式、自定函式" class="headerlink" title="B. [函式] 公用函式、自定函式"></a>B. [函式] 公用函式、自定函式</h2><h3 id="a114-找出最小的完全平方數"><a href="#a114-找出最小的完全平方數" class="headerlink" title="a114/ 找出最小的完全平方數"></a>a114/ 找出最小的完全平方數</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="number">10</span>,(k<span class="number">-1</span>))));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a;;i++)&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(i*i);</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>(),flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i*i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a115-賓果遊戲"><a href="#a115-賓果遊戲" class="headerlink" title="a115/ 賓果遊戲"></a>a115/ 賓果遊戲</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int ll</span></span><br><span class="line"><span class="comment">//#define ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maze[<span class="number">10</span>][<span class="number">10</span>],cur[<span class="number">10</span>][<span class="number">10</span>],n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;maze[i][j];</span><br><span class="line">            cur[i][j] = maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!= <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j]==n)maze[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>,num = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                maze[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> k,ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)<span class="keyword">if</span>(maze[k][j]!=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">5</span>)ans+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)<span class="keyword">if</span>(maze[i][k]!=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">5</span>)ans+=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)<span class="keyword">if</span>(maze[k][k]!=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(k==<span class="number">5</span>)ans+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+j==<span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = <span class="number">4</span>,y = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(maze[x][y]!=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            x--;y++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k==<span class="number">5</span>)ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans&gt;num)&#123;</span><br><span class="line">                    num = ans;</span><br><span class="line">                    ind = cur[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans==num &amp;&amp; ind&gt;cur[i][j])ind = cur[i][j];</span><br><span class="line">                maze[i][j] = cur[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ind&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a116-一起回家的日子"><a href="#a116-一起回家的日子" class="headerlink" title="a116/ 一起回家的日子"></a>a116/ 一起回家的日子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define ll long long</span></span><br><span class="line"><span class="comment">//#define int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a%b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">leap</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a%<span class="number">100</span>!=<span class="number">0</span>||a%<span class="number">400</span>==<span class="number">0</span>)&amp;&amp;(a%<span class="number">4</span>==<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[<span class="number">100</span>];cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">int</span> ans = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)ans=(ans*arr[i])/<span class="built_in">gcd</span>(ans,arr[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> y,m,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>,&amp;y,&amp;m,&amp;d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> month[<span class="number">15</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    d+=ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(d&gt;month[m])&#123;</span><br><span class="line">        d-=month[m];</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">12</span>)&#123;</span><br><span class="line">            y++;</span><br><span class="line">            m = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">leap</span>(y)&amp;&amp;m==<span class="number">2</span>)&#123;</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d/%02d/%02d\n&quot;</span>,y,m,d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-函式-遞迴函式"><a href="#C-函式-遞迴函式" class="headerlink" title="C. [函式] 遞迴函式"></a>C. [函式] 遞迴函式</h2><h3 id="a117-三色河內塔"><a href="#a117-三色河內塔" class="headerlink" title="a117/ 三色河內塔"></a>a117/ 三色河內塔</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> from,<span class="keyword">char</span> to,<span class="keyword">char</span> by)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">move</span>(n<span class="number">-1</span>,from,by,to);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; ring &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;from&lt;&lt;<span class="string">&quot; =&gt; &quot;</span>&lt;&lt;to&lt;&lt;endl;t++;</span><br><span class="line">    <span class="built_in">move</span>(n<span class="number">-1</span>,by,to,from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">honai</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> from,<span class="keyword">char</span> to,<span class="keyword">char</span> by)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">move</span>(n<span class="number">-1</span>,from,by,to);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; ring &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;from&lt;&lt;<span class="string">&quot; =&gt; &quot;</span>&lt;&lt;to&lt;&lt;endl;t++;</span><br><span class="line">    <span class="built_in">honai</span>(n<span class="number">-2</span>,by,from,to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">honai</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;共需&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;個移動&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a118-指數2-k的四個自然數平方和之所有表示法"><a href="#a118-指數2-k的四個自然數平方和之所有表示法" class="headerlink" title="a118/ 指數2^k的四個自然數平方和之所有表示法"></a>a118/ 指數2^k的四個自然數平方和之所有表示法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 64000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>],sqr[N];</span><br><span class="line"><span class="keyword">int</span> solution = <span class="number">0</span>,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)sqr[i] = i*i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> remain,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">sqrt</span>(remain);</span><br><span class="line">        <span class="keyword">if</span>(sqr[r]==remain)&#123;</span><br><span class="line">            cout&lt;&lt;num[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[<span class="number">2</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[<span class="number">3</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">            solution++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lower = <span class="built_in">max</span>(<span class="number">1</span>,num[id<span class="number">-1</span>]),upper = <span class="built_in">sqrt</span>(remain/(<span class="number">5</span>-id));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lower;i&lt;=upper;i++)&#123;</span><br><span class="line">        num[id]= i;</span><br><span class="line">        <span class="built_in">pick</span>(remain-sqr[i],id+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">pick</span>(<span class="number">1</span>&lt;&lt;n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(solution==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a157-費波那契數列"><a href="#a157-費波那契數列" class="headerlink" title="a157/ 費波那契數列"></a>a157/ 費波那契數列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">40</span>];arr[<span class="number">1</span>] = <span class="number">1</span>;arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>]+arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        cout&lt;&lt;arr[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a158-F91"><a href="#a158-F91" class="headerlink" title="a158/ F91"></a>a158/ F91</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">40</span>];arr[<span class="number">1</span>] = <span class="number">1</span>;arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>]+arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        cout&lt;&lt;arr[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D-基本資料型態-指標、多維陣列"><a href="#D-基本資料型態-指標、多維陣列" class="headerlink" title="D. [基本資料型態] 指標、多維陣列"></a>D. [基本資料型態] 指標、多維陣列</h2><h3 id="a105-爺爺種樹"><a href="#a105-爺爺種樹" class="headerlink" title="a105. 爺爺種樹"></a>a105. 爺爺種樹</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> n,m,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    <span class="keyword">bool</span> arr[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> r1,r2,c1,c2;cin&gt;&gt;r1&gt;&gt;c1&gt;&gt;r2&gt;&gt;c2;</span><br><span class="line">        <span class="keyword">int</span> dr = r2-r1,dc = c2-c1;</span><br><span class="line">        <span class="keyword">if</span>(dr&gt;<span class="number">0</span>)dr = <span class="number">1</span>;<span class="keyword">else</span> dr = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dc&gt;<span class="number">0</span>)dc = <span class="number">1</span>;<span class="keyword">else</span> dc = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r1==r2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=c1;i!=c2;i+=dc)arr[r1][i] = <span class="number">1</span>;</span><br><span class="line">            arr[r1][c2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c1==c2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r1;i!=r2;i+=dr)arr[i][c1] = <span class="number">1</span>;</span><br><span class="line">            arr[r2][c1] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r1,j=c1;i!=r2;i+=dr,j+=dc)&#123;</span><br><span class="line">                arr[i][j] = <span class="number">1</span>;</span><br><span class="line">                arr[r2][c2] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j])ans+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a106-賓果遊戲"><a href="#a106-賓果遊戲" class="headerlink" title="a106. 賓果遊戲"></a>a106. 賓果遊戲</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> name[N],line[N][<span class="number">10</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> people,<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = mp[people][number].first,c = mp[people][number].second;</span><br><span class="line">    line[people][r]+=<span class="number">1</span>;</span><br><span class="line">    line[people][c+<span class="number">4</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(line[people][r]==<span class="number">4</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(line[people][c+<span class="number">4</span>]==<span class="number">4</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r+c==<span class="number">3</span>)&#123;</span><br><span class="line">        line[people][<span class="number">8</span>]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(line[people][<span class="number">8</span>]==<span class="number">4</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r==c)&#123;</span><br><span class="line">        line[people][<span class="number">9</span>]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(line[people][<span class="number">9</span>]==<span class="number">4</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> cha;</span><br><span class="line">    cin&gt;&gt;cha&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(line,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(line));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;name[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            mp[i][temp].first = j/<span class="number">4</span>;</span><br><span class="line">            mp[i][temp].second = j%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">16</span>,flag = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;cha;</span><br><span class="line">    <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        cout&lt;&lt;temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,temp))&#123;</span><br><span class="line">                cout&lt;&lt;name[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a107-加密解密"><a href="#a107-加密解密" class="headerlink" title="a107. 加密解密"></a>a107. 加密解密</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a = <span class="string">&quot;abcdefghijklmnoprstuvwxyz&quot;</span>;</span><br><span class="line">string b = <span class="string">&quot;EXAMPLBCDFGHIJKNORSTUVWYZ&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> n;string s;</span><br><span class="line">    cin&gt;&gt;n;cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    string origin = b ,key = a;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; s[<span class="number">0</span>]&lt;=<span class="string">&#x27;z&#x27;</span>)<span class="built_in">swap</span>(origin,key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = origin.<span class="built_in">find</span>(s[i]),p2 = origin.<span class="built_in">find</span>(s[i+<span class="number">1</span>]);</span><br><span class="line">        cout&lt;&lt;key[<span class="number">5</span>*(p1/<span class="number">5</span>)+(p2%<span class="number">5</span>)]&lt;&lt;key[<span class="number">5</span>*(p2/<span class="number">5</span>)+(p1%<span class="number">5</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a147-促銷活動"><a href="#a147-促銷活動" class="headerlink" title="a147/ 促銷活動"></a>a147/ 促銷活動</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discount</span><span class="params">(<span class="keyword">double</span> &amp;a,<span class="keyword">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        b = <span class="number">0.5</span>*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p1, p2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original price:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    <span class="built_in">discount</span>(p1,p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Price after discount:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a159-錯誤更正"><a href="#a159-錯誤更正" class="headerlink" title="a159/ 錯誤更正"></a>a159/ 錯誤更正</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> row_sum[N],col_sum[N],arr[N][N];</span><br><span class="line">        <span class="built_in">memset</span>(row_sum,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(row_sum));</span><br><span class="line">        <span class="built_in">memset</span>(col_sum,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(col_sum));</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                cin&gt;&gt;arr[i][j];</span><br><span class="line">                row_sum[i]+=arr[i][j];</span><br><span class="line">                col_sum[j]+=arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rcnt = <span class="number">0</span>,ccnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rind = <span class="number">0</span>,cind = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row_sum[i]%<span class="number">2</span>)&#123;</span><br><span class="line">                rcnt += <span class="number">1</span>;</span><br><span class="line">                rind = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(col_sum[i]%<span class="number">2</span>)&#123;</span><br><span class="line">                ccnt += <span class="number">1</span>;</span><br><span class="line">                cind = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rcnt==<span class="number">0</span> &amp;&amp; ccnt==<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rcnt==<span class="number">1</span> &amp;&amp; ccnt==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Change bit (&quot;</span>&lt;&lt;rind&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;cind&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Corrupt&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E-基本資料型態-字串"><a href="#E-基本資料型態-字串" class="headerlink" title="E. [基本資料型態] 字串"></a>E. [基本資料型態] 字串</h2><h3 id="a065-秘密差"><a href="#a065-秘密差" class="headerlink" title="a065. 秘密差"></a>a065. 秘密差</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,len = s.<span class="built_in">size</span>(),p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            ans+=(s[i]-<span class="string">&#x27;0&#x27;</span>)*p;</span><br><span class="line">            p *=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">abs</span>(ans)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a067-ROT13"><a href="#a067-ROT13" class="headerlink" title="a067. ROT13"></a>a067. ROT13</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(p))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isupper</span>(p))</span><br><span class="line">                cout&lt;&lt;(<span class="keyword">char</span>)((p-<span class="string">&#x27;A&#x27;</span>+<span class="number">13</span>)%<span class="number">26</span>+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;(<span class="keyword">char</span>)((p-<span class="string">&#x27;a&#x27;</span>+<span class="number">13</span>)%<span class="number">26</span>+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a108-計算字串間隔距離"><a href="#a108-計算字串間隔距離" class="headerlink" title="a108. 計算字串間隔距離"></a>a108. 計算字串間隔距離</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string,queue&lt;pair&lt;string,<span class="keyword">int</span>&gt;&gt;&gt; mp;</span><br><span class="line"><span class="comment">//地點、動物名、數量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;ch;</span><br><span class="line">    ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>(),a1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[i])==ch)&#123;</span><br><span class="line">            a1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a1+<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[i])==ch)&#123;</span><br><span class="line">            a2 = i;</span><br><span class="line">            cout&lt;&lt;a2-a1&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            a1 = a2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a109-跑長編碼與資料壓縮"><a href="#a109-跑長編碼與資料壓縮" class="headerlink" title="a109. 跑長編碼與資料壓縮"></a>a109. 跑長編碼與資料壓縮</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,origin,after,times;</span><br><span class="line">    string s,t,binary[<span class="number">8</span>]=&#123;<span class="string">&quot;000&quot;</span>,<span class="string">&quot;001&quot;</span>,<span class="string">&quot;010&quot;</span>,<span class="string">&quot;011&quot;</span>,<span class="string">&quot;100&quot;</span>,<span class="string">&quot;101&quot;</span>,<span class="string">&quot;110&quot;</span>,<span class="string">&quot;111&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        origin = s.<span class="built_in">size</span>();</span><br><span class="line">        after = <span class="number">0</span>;</span><br><span class="line">        ch = s[<span class="number">0</span>];</span><br><span class="line">        times = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=len &amp;&amp; s[i]!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                after = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=ch)&#123;</span><br><span class="line">                t+=ch;</span><br><span class="line">                t+=binary[times];</span><br><span class="line">                t+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">                times=<span class="number">1</span>;</span><br><span class="line">                ch = s[i];</span><br><span class="line">                after+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                times++;</span><br><span class="line">                <span class="keyword">if</span>(times==<span class="number">7</span>)&#123;</span><br><span class="line">                    t+=ch;</span><br><span class="line">                    t+=binary[<span class="number">7</span>];</span><br><span class="line">                    t+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    times=<span class="number">1</span>;</span><br><span class="line">                    after +=<span class="number">4</span>;</span><br><span class="line">                    ch = s[i+<span class="number">1</span>];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(after==<span class="number">-1</span>)cout&lt;&lt;after&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">0</span>)&lt;&lt;(<span class="keyword">double</span>)after*<span class="number">100</span>/origin&lt;&lt;<span class="string">&quot;%&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a110-棒球遊戲"><a href="#a110-棒球遊戲" class="headerlink" title="a110. 棒球遊戲"></a>a110. 棒球遊戲</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> num_of_out,d[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transfer</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&quot;SO&quot;</span>||a==<span class="string">&quot;FO&quot;</span>||a==<span class="string">&quot;GO&quot;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&quot;1B&quot;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&quot;2B&quot;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&quot;3B&quot;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">win</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c!=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[<span class="number">2</span>-i])s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>-c;i++)&#123;</span><br><span class="line">            d[<span class="number">2</span>-i] = d[<span class="number">2</span>-c-i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)<span class="keyword">if</span>(d[i])s++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> d[c<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c<span class="number">-1</span>;i++)d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">9</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;temp;k++)&#123;</span><br><span class="line">            string a;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            data[i][k] = <span class="built_in">transfer</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;num_of_out;</span><br><span class="line">    <span class="keyword">int</span> now_out = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now_out&gt;=num_of_out)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i][k])&#123;</span><br><span class="line">                ans+=<span class="built_in">win</span>(data[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                now_out++;</span><br><span class="line">                <span class="keyword">if</span>(now_out%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)d[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F-基本資料型態-結構"><a href="#F-基本資料型態-結構" class="headerlink" title="F. [基本資料型態] 結構"></a>F. [基本資料型態] 結構</h2><h3 id="a111-排隊"><a href="#a111-排隊" class="headerlink" title="a111. 排隊"></a>a111. 排隊</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">1005</span>][<span class="number">3</span>],line=<span class="number">0</span>,ans=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;t[<span class="number">0</span>][<span class="number">0</span>]&gt;&gt;t[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    t[<span class="number">0</span>][<span class="number">2</span>] = t[<span class="number">0</span>][<span class="number">0</span>]+t[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;t[i][<span class="number">0</span>]&gt;&gt;t[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t[i][<span class="number">0</span>]&lt;t[i<span class="number">-1</span>][<span class="number">2</span>])t[i][<span class="number">2</span>] = t[i<span class="number">-1</span>][<span class="number">2</span>]+t[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> t[i][<span class="number">2</span>] = t[i][<span class="number">0</span>]+t[i][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t[i][<span class="number">0</span>]&gt;=t[cur][<span class="number">2</span>])&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,line);</span><br><span class="line">            <span class="keyword">while</span>(t[i][<span class="number">0</span>]&gt;=t[cur][<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur==i)<span class="keyword">break</span>;</span><br><span class="line">                line--;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t[i][<span class="number">0</span>]&lt;t[cur][<span class="number">2</span>])line++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,line);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a112-動物數量統計"><a href="#a112-動物數量統計" class="headerlink" title="a112. 動物數量統計"></a>a112. 動物數量統計</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string,queue&lt;pair&lt;string,<span class="keyword">int</span>&gt;&gt;&gt; mp;</span><br><span class="line"><span class="comment">//地點、動物名、數量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        string animal,pos;</span><br><span class="line">        <span class="keyword">int</span> qu,ind;</span><br><span class="line">        cin&gt;&gt;animal&gt;&gt;qu&gt;&gt;pos;</span><br><span class="line">        ind = <span class="built_in">find</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),pos)-p.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(ind==p.<span class="built_in">size</span>())p.<span class="built_in">push_back</span>(pos);</span><br><span class="line">        mp[pos].<span class="built_in">push</span>(&#123;animal,qu&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:p)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        map&lt;string,<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        vector&lt;string&gt; almp;</span><br><span class="line">        <span class="keyword">while</span>(!mp[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string an = mp[i].<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="keyword">int</span> qu = mp[i].<span class="built_in">front</span>().second;</span><br><span class="line">            mp[i].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> ind = <span class="built_in">find</span>(almp.<span class="built_in">begin</span>(),almp.<span class="built_in">end</span>(),an)-almp.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>(ind==almp.<span class="built_in">size</span>())almp.<span class="built_in">push_back</span>(an);</span><br><span class="line">            sta[an]+=qu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:almp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c)cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sta[j];</span><br><span class="line">            c = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a113-99遊戲"><a href="#a113-99遊戲" class="headerlink" title="a113. 99遊戲"></a>a113. 99遊戲</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>,queue&lt;string&gt;&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;cin&gt;&gt;ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">13</span>;j++)&#123;</span><br><span class="line">            string s;cin&gt;&gt;s;</span><br><span class="line">            mp[ch-<span class="string">&#x27;A&#x27;</span>].<span class="built_in">push</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>,dir=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">        string card = mp[id].<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(card==<span class="string">&quot;A&quot;</span>)sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(card==<span class="string">&quot;4&quot;</span>)dir*=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(card==<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(card==<span class="string">&quot;10&quot;</span>)&#123;</span><br><span class="line">            sum+=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">99</span>)sum-=<span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(card==<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(card==<span class="string">&quot;Q&quot;</span>)&#123;</span><br><span class="line">            sum+=<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">99</span>)sum-=<span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(card==<span class="string">&quot;K&quot;</span>)sum=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=(card[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">99</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;A&#x27;</span>+id)&lt;&lt;endl&lt;&lt;mp[id].<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[id].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(mp[id].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;A&#x27;</span>+id)&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        id = (id+dir+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a150-多邊形面積"><a href="#a150-多邊形面積" class="headerlink" title="a150. 多邊形面積"></a>a150. 多邊形面積</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    point p[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>)&#123;</span><br><span class="line">            a+=(p[i].x)*(p[<span class="number">0</span>].y)-(p[<span class="number">0</span>].x)*(p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a+=(p[i].x)*(p[i+<span class="number">1</span>].y)-(p[i+<span class="number">1</span>].x)*(p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">abs</span>(a/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS CLASS PART 2</title>
    <url>/apcs2/</url>
    <content><![CDATA[<p>APCS Class題目第二部分！</p>
<h2 id="G-基礎資料結構-I-堆疊、佇列"><a href="#G-基礎資料結構-I-堆疊、佇列" class="headerlink" title="G. [基礎資料結構 I ] 堆疊、佇列"></a>G. [基礎資料結構 I ] 堆疊、佇列</h2><h3 id="a119-括號問題"><a href="#a119-括號問題" class="headerlink" title="a119. 括號問題"></a>a119. 括號問題</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>(),ans = <span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)stk.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())f= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(f)cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a120-中置式轉後置式"><a href="#a120-中置式轉後置式" class="headerlink" title="a120. 中置式轉後置式"></a>a120. 中置式轉後置式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)st.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                cout&lt;&lt;st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>||s[i]==<span class="string">&#x27;*&#x27;</span>||s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; mp[st.<span class="built_in">top</span>()]&gt;=mp[s[i]])&#123;</span><br><span class="line">                cout&lt;&lt;st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a121-電腦算術運算"><a href="#a121-電腦算術運算" class="headerlink" title="a121. 電腦算術運算"></a>a121. 電腦算術運算</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">bool</span> legal = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>||s[i]==<span class="string">&#x27;,&#x27;</span>||s[i]==<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[++i]))&#123;</span><br><span class="line">                    sum=sum*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(sum);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>||s[i]==<span class="string">&#x27;*&#x27;</span>||s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    legal = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> b = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>)stk.<span class="built_in">push</span>(a+b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>)stk.<span class="built_in">push</span>(b-a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)stk.<span class="built_in">push</span>(a*b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>&amp;&amp; a==<span class="number">0</span>)&#123;</span><br><span class="line">                    legal = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)stk.<span class="built_in">push</span>(b/a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                legal = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(legal==<span class="number">0</span>)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(stk.<span class="built_in">size</span>()==<span class="number">1</span>)cout&lt;&lt;stk.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a151-後序式求值"><a href="#a151-後序式求值" class="headerlink" title="a151. 後序式求值"></a>a151. 後序式求值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))stk.<span class="built_in">push</span>(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> b = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>)stk.<span class="built_in">push</span>(a+b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>)stk.<span class="built_in">push</span>(b-a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)stk.<span class="built_in">push</span>(a*b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)stk.<span class="built_in">push</span>(b/a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;%&#x27;</span>)stk.<span class="built_in">push</span>(b%a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;stk.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a163-印表機佇列"><a href="#a163-印表機佇列" class="headerlink" title="a163. 印表機佇列"></a>a163. 印表機佇列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Can</span><span class="params">(<span class="keyword">int</span> now_priority,<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=now_priority+<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]&gt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,pri[<span class="number">105</span>];cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(pri,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pri));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(i==m)que.<span class="built_in">push</span>(&#123;<span class="number">1</span>,p&#125;);</span><br><span class="line">        <span class="keyword">else</span> que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,p&#125;);</span><br><span class="line">        pri[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Can</span>(cur.second,pri))&#123;</span><br><span class="line">            <span class="comment">//可以印的話</span></span><br><span class="line">            ans++;</span><br><span class="line">            pri[cur.second]--;</span><br><span class="line">            <span class="keyword">if</span>(cur.first==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> que.<span class="built_in">push</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a164-團體佇列"><a href="#a164-團體佇列" class="headerlink" title="a164. 團體佇列"></a>a164. 團體佇列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> t,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;t &amp;&amp; t)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;<span class="comment">//[成員、團體編號]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line">            <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">                <span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">                mp[x] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q,que[<span class="number">1005</span>];<span class="comment">//團體順序、團體內順序</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Scenario #&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">        string temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cin&gt;&gt;temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">                <span class="keyword">if</span>(que[mp[x]].<span class="built_in">empty</span>())Q.<span class="built_in">push</span>(mp[x]);</span><br><span class="line">                que[mp[x]].<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> team = Q.<span class="built_in">front</span>();</span><br><span class="line">                cout&lt;&lt;que[team].<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">                que[team].<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(que[team].<span class="built_in">empty</span>())Q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="H-基礎資料結構-I-樹狀結構"><a href="#H-基礎資料結構-I-樹狀結構" class="headerlink" title="H. [基礎資料結構 I ] 樹狀結構"></a>H. [基礎資料結構 I ] 樹狀結構</h2><h3 id="a076-二元搜尋樹高度"><a href="#a076-二元搜尋樹高度" class="headerlink" title="a076. 二元搜尋樹高度"></a>a076. 二元搜尋樹高度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">3000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(used));</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,temp;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;temp)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>,height = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(used[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;tree[cur])cur = cur*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> cur = cur*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[cur] = temp;</span><br><span class="line">        used[cur] = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,height);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a077-Dropping-Balls"><a href="#a077-Dropping-Balls" class="headerlink" title="a077. Dropping Balls"></a>a077. Dropping Balls</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">3000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drop</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id&gt;=(<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>)))<span class="keyword">return</span> id;</span><br><span class="line">    </span><br><span class="line">    tree[id]=!tree[id];</span><br><span class="line">    <span class="keyword">if</span>(!tree[id])<span class="keyword">return</span> <span class="built_in">drop</span>(<span class="number">2</span>*id+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">drop</span>(<span class="number">2</span>*id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            ans = <span class="built_in">drop</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a122-血緣關係"><a href="#a122-血緣關係" class="headerlink" title="a122. 血緣關係"></a>a122. 血緣關係</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,start,dis[N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> cur_dis)</span></span>&#123;  <span class="comment">//尋找點id的最遠點距離</span></span><br><span class="line">    <span class="keyword">if</span>(visit[id])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    visit[id] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = edge[id].<span class="built_in">size</span>(),max_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> next = edge[id][i];</span><br><span class="line">        <span class="keyword">if</span>(visit[next])<span class="keyword">continue</span>;</span><br><span class="line">        dis[next] = cur_dis+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">dfs</span>(next,cur_dis+<span class="number">1</span>);</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="built_in">dfs</span>(<span class="number">2</span>,<span class="number">0</span>);distance--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i]==distance)&#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(start,<span class="number">0</span>)<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a123-樹狀圖分析"><a href="#a123-樹狀圖分析" class="headerlink" title="a123. 樹狀圖分析"></a>a123. 樹狀圖分析</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,father[N],h[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> next:edge[cur])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(next);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn,h[next]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    h[cur] = maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(father,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(father));</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k;cin&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            edge[i].<span class="built_in">push_back</span>(temp);</span><br><span class="line">            father[temp] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(father[root]!=<span class="number">0</span>)root++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    lld ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans += h[i];</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;root&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//O(N)的作法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">lld n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,ans = <span class="number">1</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        m--;    <span class="comment">//從0開始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;         <span class="comment">//共n-1步要走</span></span><br><span class="line">            <span class="keyword">if</span>(m&amp;<span class="number">1</span>)ans = ans*<span class="number">2</span>+<span class="number">1</span>;     <span class="comment">//往右邊走</span></span><br><span class="line">            <span class="keyword">else</span> ans = ans*<span class="number">2</span>;</span><br><span class="line">            m = m&gt;&gt;<span class="number">1</span>;                 <span class="comment">//由低bit到高bit決定每一步要怎麼走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="I-基礎資料結構-I-圖形結構"><a href="#I-基礎資料結構-I-圖形結構" class="headerlink" title="I. [基礎資料結構 I ] 圖形結構"></a>I. [基礎資料結構 I ] 圖形結構</h2><h3 id="a051-城市旅遊"><a href="#a051-城市旅遊" class="headerlink" title="a051. 城市旅遊"></a>a051. 城市旅遊</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    visit[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">100</span>;i++)edge[i].<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        edge[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> from,to;cin&gt;&gt;from&gt;&gt;to;</span><br><span class="line">    <span class="built_in">dfs</span>(from);</span><br><span class="line">    <span class="keyword">if</span>(visit[to])cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a102-油田"><a href="#a102-油田" class="headerlink" title="a102. 油田"></a>a102. 油田</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[N][N],maze[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    visit[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit[nx][ny])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(maze[nx][ny]==<span class="number">1</span>)<span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&#x27;@&#x27;</span>)maze[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> maze[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j]==<span class="number">1</span> &amp;&amp; visit[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                ans+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n&amp;&amp; m)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a103-小群體"><a href="#a103-小群體" class="headerlink" title="a103. 小群體"></a>a103. 小群體</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[N];cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> used[N];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(used));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = arr[i];</span><br><span class="line">        used[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=i)&#123;</span><br><span class="line">            cur = arr[cur];</span><br><span class="line">            used[cur] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a124-二分圖"><a href="#a124-二分圖" class="headerlink" title="a124. 二分圖"></a>a124. 二分圖</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,ans = <span class="number">0</span>,cnt[<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    color[cur] = c;</span><br><span class="line">    cnt[c]+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i]==color[cur])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="number">-1</span>)flag = (flag &amp;&amp; <span class="built_in">dfs</span>(i,!c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(color));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)color[i] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;a--;b--;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            cnt[<span class="number">0</span>] = <span class="number">0</span>;cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">0</span>))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">min</span>(cnt[<span class="number">0</span>],cnt[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//有可能是非連通圖，用+=</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="J-基礎演算法-I-複雜度分析、排序"><a href="#J-基礎演算法-I-複雜度分析、排序" class="headerlink" title="J. [基礎演算法 I ] 複雜度分析、排序"></a>J. [基礎演算法 I ] 複雜度分析、排序</h2><h3 id="a127-連號或不連號"><a href="#a127-連號或不連號" class="headerlink" title="a127. 連號或不連號"></a>a127. 連號或不連號</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn = *(--s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> minn = *s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==maxn-minn+<span class="number">1</span>)cout&lt;&lt;minn&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxn&lt;&lt;<span class="string">&quot; yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;minn&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxn&lt;&lt;<span class="string">&quot; no&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a128-Agar-io"><a href="#a128-Agar-io" class="headerlink" title="a128. Agar.io"></a>a128. Agar.io</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,full[N];</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">fill</span>(full,full+n+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)s[i].<span class="built_in">insert</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(full[b]&gt;full[a])<span class="built_in">swap</span>(a,b);</span><br><span class="line">        full[a] += full[b];</span><br><span class="line">        full[b] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:s[b])s[a].<span class="built_in">insert</span>(p);</span><br><span class="line">        s[b].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">max_element</span>(full,full+n+<span class="number">1</span>)-full;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:s[ans])cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a129-飛天桑妮"><a href="#a129-飛天桑妮" class="headerlink" title="a129. 飛天桑妮"></a>a129. 飛天桑妮</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pii&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first)<span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y,h;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;h;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(&#123;x*x+y*y,h&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">int</span> ans  = <span class="number">0</span>,maxh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        maxh = <span class="built_in">max</span>(maxh,vec[i].second);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,maxh-vec[i].second);</span><br><span class="line">    &#125;<span class="comment">//維護最高的樹</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a148-字元頻率"><a href="#a148-字元頻率" class="headerlink" title="a148. 字元頻率"></a>a148. 字元頻率</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second)<span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,s))&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;    <span class="comment">//asci、出現次數</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:s)mp[temp]+=<span class="number">1</span>;</span><br><span class="line">        vector&lt;pii&gt;vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:mp)&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)&#123;</span><br><span class="line">            cout&lt;&lt;i.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i.second&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="K-基礎演算法-I-排序與搜尋"><a href="#K-基礎演算法-I-排序與搜尋" class="headerlink" title="K. [基礎演算法 I ] 排序與搜尋"></a>K. [基礎演算法 I ] 排序與搜尋</h2><h3 id="a130-人員調動"><a href="#a130-人員調動" class="headerlink" title="a130. 人員調動"></a>a130. 人員調動</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wait[N][N];<span class="built_in">memset</span>(wait,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wait));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m,ans = <span class="number">0</span>;cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(wait[b][a]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;wait[b][a]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> wait[a][b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a131-大黑馬"><a href="#a131-大黑馬" class="headerlink" title="a131. 大黑馬"></a>a131. 大黑馬</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="keyword">int</span> normal[N][N],lower[N][N],upper[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">win</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> is_normal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_normal==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(normal[a][i]&lt;=normal[b][k+i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(upper[a][i]&lt;=lower[b][k+i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s;cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k+<span class="number">1</span>;j++)cin&gt;&gt;normal[s][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k+<span class="number">1</span>;j++)cin&gt;&gt;upper[s][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k+<span class="number">1</span>;j++)cin&gt;&gt;lower[s][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;=<span class="number">1</span>;p++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)&#123;    <span class="comment">//從種子序較小的開始</span></span><br><span class="line">            <span class="keyword">bool</span> f = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">win</span>(i,j,p))&#123;</span><br><span class="line">                    f = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(f)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a132-主機排程"><a href="#a132-主機排程" class="headerlink" title="a132. 主機排程"></a>a132. 主機排程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_ele(a) max_element(a,a+dh)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> arr[N]=&#123;<span class="number">0</span>&#125;,brr[N]=&#123;<span class="number">0</span>&#125;,crr[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(s--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e,f;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;</span><br><span class="line">        <span class="keyword">int</span> start = (a<span class="number">-1</span>)*<span class="number">24</span>+b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">            arr[(start+j)%dh]+=d;</span><br><span class="line">            brr[(start+j)%dh]+=e;</span><br><span class="line">            crr[(start+j)%dh]+=f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;*<span class="built_in">max_ele</span>(arr)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*<span class="built_in">max_ele</span>(brr)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*<span class="built_in">max_ele</span>(crr)&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;dh;</span><br><span class="line">    dh = dh*<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a152-二分搜尋"><a href="#a152-二分搜尋" class="headerlink" title="a152. 二分搜尋"></a>a152. 二分搜尋</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld  long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[N];cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>,ans = <span class="number">0</span>,find = <span class="number">0</span>,l = <span class="number">0</span>,r = n<span class="number">-1</span>;    <span class="comment">//[l,r]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]==t)&#123;</span><br><span class="line">            pos = mid;find = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;t)r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(find)cout&lt;&lt;pos&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;not found &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a153-二分法求解"><a href="#a153-二分法求解" class="headerlink" title="a153. 二分法求解"></a>a153. 二分法求解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout&lt;&lt;std::fixed&lt;&lt;std::<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;<span class="built_in">log</span>(<span class="number">2</span>)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="L-基礎演算法-I-窮舉法"><a href="#L-基礎演算法-I-窮舉法" class="headerlink" title="L. [基礎演算法 I ] 窮舉法"></a>L. [基礎演算法 I ] 窮舉法</h2><h3 id="a088-最大乘積"><a href="#a088-最大乘積" class="headerlink" title="a088. 最大乘積"></a>a088. 最大乘積</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">int</span> dp[N][N];<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FOR</span>(i,n)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            dp[i][i] = temp;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>]*dp[j][j];</span><br><span class="line">                ans = <span class="built_in">max</span>(dp[i][j],ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot;: The maximum product is &quot;</span>&lt;&lt;<span class="built_in">max</span>(ans,(ll)<span class="number">0</span>)&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a133-採蘑菇攻略問題"><a href="#a133-採蘑菇攻略問題" class="headerlink" title="a133. 採蘑菇攻略問題"></a>a133. 採蘑菇攻略問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,dp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FOR</span>(i,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        dp[i][i] = temp;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i][j<span class="number">-1</span>]+dp[j][j];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a134-回文日期問題"><a href="#a134-回文日期問題" class="headerlink" title="a134. 回文日期問題"></a>a134. 回文日期問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">leap</span><span class="params">(<span class="keyword">int</span> temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((temp%<span class="number">4</span>)==<span class="number">0</span> &amp;&amp;(temp%<span class="number">100</span>)!=<span class="number">0</span>)||(temp%<span class="number">400</span>)==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    string temp = s;</span><br><span class="line">    <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(temp==s)ans.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> month[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    month[<span class="number">2</span>]+=((<span class="built_in">leap</span>(n))?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=month[i];j++)&#123;</span><br><span class="line">            <span class="built_in">check</span>(<span class="built_in">to_string</span>(n)+<span class="built_in">to_string</span>(i)+<span class="built_in">to_string</span>(j));</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">10</span>)<span class="built_in">check</span>(<span class="built_in">to_string</span>(n)+<span class="string">&quot;0&quot;</span>+<span class="built_in">to_string</span>(i)+<span class="built_in">to_string</span>(j));</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">10</span>)<span class="built_in">check</span>(<span class="built_in">to_string</span>(n)+<span class="built_in">to_string</span>(i)+<span class="string">&quot;0&quot;</span>+<span class="built_in">to_string</span>(j));</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">10</span> &amp;&amp; j&lt;<span class="number">10</span>)<span class="built_in">check</span>(<span class="built_in">to_string</span>(n)+<span class="string">&quot;0&quot;</span>+<span class="built_in">to_string</span>(i)+<span class="string">&quot;0&quot;</span>+<span class="built_in">to_string</span>(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a135-巧克力擺盒"><a href="#a135-巧克力擺盒" class="headerlink" title="a135. 巧克力擺盒"></a>a135. 巧克力擺盒</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">9</span>],box[<span class="number">9</span>];;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i+=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r.<span class="built_in">size</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((r[<span class="number">0</span>]&amp;box[i])&amp;&amp;(r[<span class="number">1</span>]&amp;box[i+<span class="number">1</span>])&amp;&amp;(r[<span class="number">2</span>]&amp;box[i+<span class="number">2</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//對於這一行的指定是有滿足的，回傳正確（下一個要求繼續再呼叫一次）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((r[<span class="number">0</span>]&amp;box[i])&amp;&amp;(r[<span class="number">1</span>]&amp;box[i+<span class="number">1</span>]))||((r[<span class="number">0</span>]&amp;box[i+<span class="number">1</span>])&amp;&amp;(r[<span class="number">1</span>]&amp;box[i+<span class="number">2</span>])))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; rule;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; rule_list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>;temp = temp&lt;&lt;i;</span><br><span class="line">        r[i] = temp;</span><br><span class="line">        box[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;string,<span class="keyword">int</span>&gt; mp = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;PS&quot;</span>,r[<span class="number">0</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;PC&quot;</span>,r[<span class="number">1</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;PT&quot;</span>,r[<span class="number">2</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;P?&quot;</span>,r[<span class="number">0</span>]|r[<span class="number">1</span>]|r[<span class="number">2</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;BS&quot;</span>,r[<span class="number">3</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;BC&quot;</span>,r[<span class="number">4</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;BT&quot;</span>,r[<span class="number">5</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;B?&quot;</span>,r[<span class="number">3</span>]|r[<span class="number">4</span>]|r[<span class="number">5</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;YS&quot;</span>,r[<span class="number">6</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;YC&quot;</span>,r[<span class="number">7</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;YT&quot;</span>,r[<span class="number">8</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Y?&quot;</span>,r[<span class="number">6</span>]|r[<span class="number">7</span>]|r[<span class="number">8</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;?S&quot;</span>,r[<span class="number">0</span>]|r[<span class="number">3</span>]|r[<span class="number">6</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;?C&quot;</span>,r[<span class="number">1</span>]|r[<span class="number">4</span>]|r[<span class="number">7</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;?T&quot;</span>,r[<span class="number">2</span>]|r[<span class="number">5</span>]|r[<span class="number">8</span>]&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;??&quot;</span>,<span class="number">511</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        rule.<span class="built_in">resize</span>(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp[<span class="number">3</span>];cin&gt;&gt;temp[<span class="number">0</span>]&gt;&gt;temp[<span class="number">1</span>];</span><br><span class="line">            rule[i] = (mp[temp]);</span><br><span class="line">        &#125;</span><br><span class="line">        rule_list.<span class="built_in">push_back</span>(rule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ans += <span class="built_in">all_of</span>(rule_list.<span class="built_in">begin</span>(),rule_list.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(box,box+<span class="number">9</span>));</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a154-除法"><a href="#a154-除法" class="headerlink" title="a154. 除法"></a>a154. 除法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">10</span>],f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> cur_used[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">10000</span>&amp;&amp;used[<span class="number">0</span>]==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t&lt;<span class="number">10000</span>)cur_used[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = t%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur_used[d])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(used[d])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur_used[d] = <span class="number">1</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first%n!=<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> second = first/n;</span><br><span class="line">        <span class="keyword">if</span>(second&lt;<span class="number">1234</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(second))&#123;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;first&lt;&lt;<span class="string">&quot; / &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(second&lt;<span class="number">10000</span>)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;second&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])<span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(first*<span class="number">10</span>+i,id+<span class="number">1</span>);</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(used));</span><br><span class="line">        f=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;There are no solutions for &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS CLASS PART 3</title>
    <url>/apcs3/</url>
    <content><![CDATA[<p>APCS Class題目第三部分！</p>
<h2 id="M-基礎資料結構-II-及基礎演算法-II-貪婪法"><a href="#M-基礎資料結構-II-及基礎演算法-II-貪婪法" class="headerlink" title="M. [基礎資料結構 II 及基礎演算法 II ] 貪婪法"></a>M. [基礎資料結構 II 及基礎演算法 II ] 貪婪法</h2><h3 id="a071-排隊買飲料"><a href="#a071-排隊買飲料" class="headerlink" title="a071. 排隊買飲料"></a>a071. 排隊買飲料</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;&gt;&gt;pq;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;time;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;m)&#123;</span><br><span class="line">            time+=pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(time);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,time);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a075-醜數"><a href="#a075-醜數" class="headerlink" title="a075. 醜數"></a>a075. 醜數</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> id2 = <span class="number">0</span>,id3 = <span class="number">0</span>,id5 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用前面的醜數推後面的，不會有其他質樹</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="built_in">min</span>(vec[id2]*<span class="number">2</span>,<span class="built_in">min</span>(vec[id3]*<span class="number">3</span>,vec[id5]*<span class="number">5</span>));</span><br><span class="line">        vec.<span class="built_in">push_back</span>(ugly);</span><br><span class="line">        <span class="keyword">if</span>(vec[i]==vec[id2]*<span class="number">2</span>)id2+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]==vec[id3]*<span class="number">3</span>)id3+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]==vec[id5]*<span class="number">5</span>)id5+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;vec[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a091-Add-All"><a href="#a091-Add-All" class="headerlink" title="a091. Add All"></a>a091. Add All</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            pq.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cur += pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans+=cur;</span><br><span class="line">            pq.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a139-背包置物問題"><a href="#a139-背包置物問題" class="headerlink" title="a139. 背包置物問題"></a>a139. 背包置物問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec,p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vec.<span class="built_in">assign</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;temp)vec.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,len = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),vec[i])!=p.<span class="built_in">end</span>())<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.<span class="built_in">size</span>()&lt;k)&#123;</span><br><span class="line">            p.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, dis = <span class="number">0</span>, max_dis=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            dis = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=i+<span class="number">1</span>;q&lt;=len;q++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[q]==p[j])<span class="keyword">break</span>;</span><br><span class="line">                dis += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_dis &lt; dis)&#123;</span><br><span class="line">                max_dis = dis;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;index&lt;&lt;endl;</span></span><br><span class="line">        p[index] = vec[i];</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a141-基地台"><a href="#a141-基地台" class="headerlink" title="a141. 基地台"></a>a141. 基地台</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,arr[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//確認直徑可否覆蓋全部（greedy）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_cover = arr[<span class="number">0</span>]+sum;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_cover &lt; arr[i])&#123;</span><br><span class="line">            max_cover = arr[i]+sum;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cnt&lt;=k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr,arr+n);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="built_in">ceil</span>((arr[n<span class="number">-1</span>]-arr[<span class="number">0</span>])/k);</span><br><span class="line">    <span class="comment">//區間[l,r]二分搜尋直徑</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="N-基礎資料結構-II-及基礎演算法-II-分而治之與回溯法"><a href="#N-基礎資料結構-II-及基礎演算法-II-分而治之與回溯法" class="headerlink" title="N. [基礎資料結構 II 及基礎演算法 II ] 分而治之與回溯法"></a>N. [基礎資料結構 II 及基礎演算法 II ] 分而治之與回溯法</h2><h3 id="a089-蘇丹王位繼承者"><a href="#a089-蘇丹王位繼承者" class="headerlink" title="a089. 蘇丹王位繼承者"></a>a089. 蘇丹王位繼承者</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,chess[N][N],Q[N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(col == Q[i]||<span class="built_in">abs</span>(row-i)==<span class="built_in">abs</span>(col-Q[i]))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queen</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">8</span>)sum += chess[i][Q[i]];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(row,i))&#123;</span><br><span class="line">            Q[row] = i;</span><br><span class="line">            <span class="built_in">Queen</span>(row+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(chess,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(chess));</span><br><span class="line">    <span class="built_in">memset</span>(Q,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Q));</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;chess[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Queen</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;right&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a090-質數環"><a href="#a090-質數環" class="headerlink" title="a090. 質數環"></a>a090. 質數環</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,prime[<span class="number">105</span>],ans[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">100</span>)prime[i] = <span class="number">1</span>;</span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=<span class="number">100</span>;j+=i)&#123;</span><br><span class="line">            prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    ans[id] = val;</span><br><span class="line">    <span class="keyword">if</span>(id&gt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!prime[val+<span class="number">1</span>])<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(prime[val+i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(id+<span class="number">1</span>,i);</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a142-無刻度容器倒水問題"><a href="#a142-無刻度容器倒水問題" class="headerlink" title="a142. 無刻度容器倒水問題"></a>a142. 無刻度容器倒水問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">int</span> a[N][N];<span class="keyword">bool</span> visit[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;pii&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    visit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pii cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> mmin = cur.x,mmax = cur.y;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="built_in">max</span>(<span class="number">0</span>,mmax-(y-mmin)),<span class="built_in">min</span>(mmax+mmin,x),x,mmin,<span class="number">0</span>,mmin&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="built_in">min</span>(y,mmax+mmin),<span class="built_in">max</span>(<span class="number">0</span>,mmax-(x-mmin)),mmax,y,mmax,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = dx[i],ny = dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx==z||ny==z)&#123;</span><br><span class="line">                f = <span class="number">1</span>;</span><br><span class="line">                cout&lt;&lt;a[mmin][mmax]+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visit[nx][ny])<span class="keyword">continue</span>;</span><br><span class="line">            a[nx][ny] = a[mmin][mmax]+<span class="number">1</span>;</span><br><span class="line">            visit[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(&#123;nx,ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a165-最近點對問題"><a href="#a165-最近點對問題" class="headerlink" title="a165. 最近點對問題"></a>a165. 最近點對問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;pii&gt; p,temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>);</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1 = a.x-b.x,y1 = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x1 * x1 + y1 * y1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間[l,r]</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>,mid_pos = p[mid].x;;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="built_in">min</span>(<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r));</span><br><span class="line">    </span><br><span class="line">    temp.<span class="built_in">assign</span>((r-l+<span class="number">1</span>),&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">merge</span>(</span><br><span class="line">        p.<span class="built_in">begin</span>() + l, p.<span class="built_in">begin</span>() + mid + <span class="number">1</span>,</span><br><span class="line">        p.<span class="built_in">begin</span>() + mid + <span class="number">1</span>, p.<span class="built_in">begin</span>() + r + <span class="number">1</span>,</span><br><span class="line">        temp.<span class="built_in">begin</span>(), cmp</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r)p[i] = temp[i-l];</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p[i].x - mid_pos) &lt;= ans)</span><br><span class="line">            temp.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = temp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, i+<span class="number">1</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dis</span>(temp[i],temp[j]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(temp[i].y-temp[j].y) &gt; ans)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">10000</span>)cout&lt;&lt;<span class="string">&quot;INFINITY&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="O-基礎資料結構-II-及基礎演算法-II-動態規劃"><a href="#O-基礎資料結構-II-及基礎演算法-II-動態規劃" class="headerlink" title="O. [基礎資料結構 II 及基礎演算法 II ] 動態規劃"></a>O. [基礎資料結構 II 及基礎演算法 II ] 動態規劃</h2><h3 id="a143-關鍵字搜尋模擬"><a href="#a143-關鍵字搜尋模擬" class="headerlink" title="a143. 關鍵字搜尋模擬"></a>a143. 關鍵字搜尋模擬</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pif pair<span class="meta-string">&lt;int,float&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,num_key = <span class="number">0</span>;</span><br><span class="line">string key[N];</span><br><span class="line">vector&lt;pif&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">com_string</span><span class="params">(string s1, string s2)</span></span>&#123;</span><br><span class="line">    s1 = <span class="string">&quot;0&quot;</span>+s1;s2 = <span class="string">&quot;0&quot;</span>+s2;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,com[N][N];<span class="built_in">memset</span>(com,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(com));</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.<span class="built_in">size</span>(),len2 = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j])&#123;</span><br><span class="line">                com[i][j] = com[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,com[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pif a,pif b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y == b.y)<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">max_num</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num_key;i++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,(<span class="keyword">float</span>)<span class="built_in">com_string</span>(s,key[i])/key[i].<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;key[num_key++]);</span><br><span class="line">    cin&gt;&gt;n;cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> doc_num;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="function">stringstream <span class="title">ss2</span><span class="params">(s)</span></span>;</span><br><span class="line">        ss2&gt;&gt;doc_num;</span><br><span class="line">        <span class="keyword">float</span> score = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss2 &gt;&gt; s)score += <span class="built_in">max_num</span>(s);</span><br><span class="line">        </span><br><span class="line">        score = <span class="built_in">round</span>(score*<span class="number">100</span>)/<span class="number">100</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;doc_num,score&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">if</span>(ans[<span class="number">0</span>].y &lt;= <span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;FALSE&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> i: ans)cout&lt;&lt;i.x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a144-農作物採收問題"><a href="#a144-農作物採收問題" class="headerlink" title="a144. 農作物採收問題"></a>a144. 農作物採收問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,num[N][N],dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)<span class="built_in">rep</span>(j,<span class="number">1</span>,n)cin&gt;&gt;num[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            num[i][j]+=num[i<span class="number">-1</span>][j]+num[i][j<span class="number">-1</span>]-num[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左上(a,b)右下(x,y)</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)<span class="built_in">rep</span>(j,<span class="number">1</span>,n)<span class="built_in">rep</span>(a,<span class="number">1</span>,i)<span class="built_in">rep</span>(b,<span class="number">1</span>,j)</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,num[i][j]-num[a<span class="number">-1</span>][j]-num[i][b<span class="number">-1</span>]+num[a<span class="number">-1</span>][b<span class="number">-1</span>]);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a145-搬家規畫問題"><a href="#a145-搬家規畫問題" class="headerlink" title="a145. 搬家規畫問題"></a>a145. 搬家規畫問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> w[N],v[N],ind=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;w[ind++]);</span><br><span class="line">    ind--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ind;i++)cin&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">int</span> c;cin&gt;&gt;c;</span><br><span class="line">    <span class="keyword">int</span> dp[c+<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ind;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=c;j&gt;=w[i];j--)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[c]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a155-雙子星塔"><a href="#a155-雙子星塔" class="headerlink" title="a155. 雙子星塔"></a>a155. 雙子星塔</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,dp[N][N],a[N],b[N],cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n &amp;&amp; !m)<span class="keyword">break</span>;</span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Twin Towers #&quot;</span>&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,m)cin&gt;&gt;b[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of Tiles : &quot;</span>;</span><br><span class="line">        cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="P-基礎資料結構-II-及基礎演算法-II-樹狀圖形結構演算法"><a href="#P-基礎資料結構-II-及基礎演算法-II-樹狀圖形結構演算法" class="headerlink" title="P. [基礎資料結構 II 及基礎演算法 II ] 樹狀圖形結構演算法"></a>P. [基礎資料結構 II 及基礎演算法 II ] 樹狀圖形結構演算法</h2><h3 id="a136-元件測試排程問題"><a href="#a136-元件測試排程問題" class="headerlink" title="a136. 元件測試排程問題"></a>a136. 元件測試排程問題</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,ans[N];;</span><br><span class="line"><span class="keyword">bool</span> edge[N][N],is_root[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_front</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(edge[u][v])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[u][i] &amp;&amp; <span class="built_in">is_front</span>(i,v))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">togological</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deg[N],sum = <span class="number">0</span>,ind = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(deg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(deg));</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i][j])deg[j] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)<span class="keyword">if</span>(deg[i]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();sum = <span class="number">0</span>;</span><br><span class="line">        ans[ind++] = cur;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[cur][i])&#123;</span><br><span class="line">                deg[i]--;</span><br><span class="line">                <span class="keyword">if</span>(deg[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    sum += <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; n)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(edge));</span><br><span class="line">    <span class="built_in">fill</span>(is_root,is_root+N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> from = a-<span class="string">&#x27;A&#x27;</span>,to = b-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        is_root[to] = <span class="number">0</span>;</span><br><span class="line">        edge[from][to] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_front</span>(to,from))&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Order conflict after getting pair &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">togological</span>())&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Determine the testing sequence after getting pair &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cout&lt;&lt;(<span class="keyword">char</span>)(ans[i]+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;No answer&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a137-勇者冒險"><a href="#a137-勇者冒險" class="headerlink" title="a137. 勇者冒險"></a>a137. 勇者冒險</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,row,col,mp[N][N],dis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">    <span class="keyword">int</span> s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        mp[a][b] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dijkstra</span></span><br><span class="line">    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;</span><br><span class="line">    dis[s1][s2] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,&#123;s1,s2&#125;&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> rr = pq.<span class="built_in">top</span>().y.x,cc = pq.<span class="built_in">top</span>().y.y;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = rr+dx[i],ny = cc+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;=row||ny&gt;=col)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx == e1 &amp;&amp; ny == e2)&#123;</span><br><span class="line">                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp[nx][ny] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[nx][ny])<span class="keyword">continue</span>;</span><br><span class="line">            dis[nx][ny] = <span class="built_in">max</span>(dis[rr][cc],mp[nx][ny]);</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);</span><br><span class="line">            visit[nx][ny] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a138-最小花費的航空之旅"><a href="#a138-最小花費的航空之旅" class="headerlink" title="a138. 最小花費的航空之旅"></a>a138. 最小花費的航空之旅</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pif pair<span class="meta-string">&lt;int,float&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,visit[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ticket</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,cost;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next_city;</span><br><span class="line">    <span class="comment">//陣列ticket[i]存以i為起點</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Ticket&gt; ticket[<span class="number">30</span>];          <span class="comment">//ticket[i] 起點為i的聯票</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cost,cur_pos,visit_pos;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; used_ticket;</span><br><span class="line">    <span class="comment">//cur_pos現在所在位置、visit_pos在行程單上位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//讓priority_queue可以pop出最小的cost的路徑</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,num<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k;cin&gt;&gt;k;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        ticket[s].<span class="built_in">push_back</span>(&#123;i,cost,temp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k)cin&gt;&gt;visit[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : ticket[visit[<span class="number">1</span>]])&#123;         <span class="comment">//行程第一個起點的聯票起點</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i.next_city)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p &lt; k &amp;&amp; j == visit[p+<span class="number">1</span>])p++;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;一開始聯票：&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.visit_pos == k)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Cost = &quot;</span>&lt;&lt;cur.cost&lt;&lt;<span class="string">&quot;, Tickets used: &quot;</span></span><br><span class="line">                &lt;&lt;cur.used_ticket[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cur.used_ticket.<span class="built_in">size</span>();i++)</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;cur.used_ticket[i];</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ticket[cur.cur_pos])&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(cur.used_ticket)</span></span>;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(i.id);                <span class="comment">//將現在使用的第i聯票推入</span></span><br><span class="line">            <span class="keyword">int</span> p = cur.visit_pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : i.next_city)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p &lt; k &amp;&amp; j == visit[p+<span class="number">1</span>])p++;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;cur.cost+i.cost,j,p,vec&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Q-題目解析-APCS-程式開發環境、題目解析"><a href="#Q-題目解析-APCS-程式開發環境、題目解析" class="headerlink" title="Q. [題目解析] APCS 程式開發環境、題目解析"></a>Q. [題目解析] APCS 程式開發環境、題目解析</h2><h3 id="a140-物品堆疊"><a href="#a140-物品堆疊" class="headerlink" title="a140. 物品堆疊"></a>a140. 物品堆疊</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y &lt; a.y*b.x;</span><br><span class="line">    <span class="comment">//p[1~n]變成從上到下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].y;</span><br><span class="line">    <span class="built_in">sort</span>(p,p+n,cmp);</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        weight += p[i].x;</span><br><span class="line">        ans += weight*p[i+<span class="number">1</span>].y;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a160-線段覆蓋長度"><a href="#a160-線段覆蓋長度" class="headerlink" title="a160. 線段覆蓋長度"></a>a160. 線段覆蓋長度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = a[<span class="number">0</span>].y - a[<span class="number">0</span>].x,R = a[<span class="number">0</span>].y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].y &gt; R)&#123;</span><br><span class="line">                sum += (a[i].y-a[i].x)-(R-a[i].x)*((R-a[i].x)&gt;<span class="number">0</span>);</span><br><span class="line">                R = a[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>DP問題-經典題學習</title>
    <url>/dp1/</url>
    <content><![CDATA[<h2 id="動態規劃的要素"><a href="#動態規劃的要素" class="headerlink" title="動態規劃的要素"></a>動態規劃的要素</h2><h3 id="可以動態規劃的問題符合兩個條件"><a href="#可以動態規劃的問題符合兩個條件" class="headerlink" title="可以動態規劃的問題符合兩個條件"></a>可以動態規劃的問題符合兩個條件</h3><ul>
<li>重複子問題</li>
<li>可分治性</li>
</ul>
<h3 id="動態規劃的三要素"><a href="#動態規劃的三要素" class="headerlink" title="動態規劃的三要素"></a>動態規劃的三要素</h3><ul>
<li>0.定義</li>
<li>1.狀態轉移方式</li>
<li>2.初始狀態（邊界條件）</li>
</ul>
<span id="more"></span>
<h3 id="動態規劃應注意的問題"><a href="#動態規劃應注意的問題" class="headerlink" title="動態規劃應注意的問題"></a>動態規劃應注意的問題</h3><ol>
<li>轉移方式：Top-Down or Bottom-up</li>
<li>複雜度=狀態數*轉移時間</li>
<li>轉移順序</li>
</ol>
<h2 id="IOI-1994-三角旅行"><a href="#IOI-1994-三角旅行" class="headerlink" title="[IOI 1994] 三角旅行"></a>[IOI 1994] 三角旅行</h2><p><img src="https://i.imgur.com/O8lT7c9.png" alt=""></p>
<h3 id="0-定義"><a href="#0-定義" class="headerlink" title="0.定義"></a>0.定義</h3><p>定義陣列dp[i][j]為走到第 i 橫排第 j 格的時候可能的最大值。</p>
<h3 id="1-轉移方式"><a href="#1-轉移方式" class="headerlink" title="1.轉移方式"></a>1.轉移方式</h3><p>第 i 橫排第 j 格的解為：「第 i+1 橫排第 j 格」與「第 i+1 橫排第 j+1 格」的最大值，加上原本第 i 橫排第 j 格的值。<br>以範測為例:<br><img src="https://i.imgur.com/JJtfbys.jpg" alt=""><br>轉移程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+arr[i][j];</span><br></pre></td></tr></table></figure>
<h3 id="2-邊界條件"><a href="#2-邊界條件" class="headerlink" title="2.邊界條件"></a>2.邊界條件</h3><p>我是從第 n-1 層開始dp轉移，所以邊界就是第 n 層的所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    dp[n<span class="number">-1</span>][i] = arr[n<span class="number">-1</span>][i];</span><br></pre></td></tr></table></figure>
<p>而答案即為<strong>dp[0][0]</strong>，也就是三角形的頂端</p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;,arr[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)cin&gt;&gt;arr[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[n<span class="number">-1</span>][i] = arr[n<span class="number">-1</span>][i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大子陣列"><a href="#最大子陣列" class="headerlink" title="最大子陣列"></a>最大子陣列</h2><p><a href="https://leetcode.com/problems/maximum-subarray/">leetcode 53</a><br>暴力解（<strong>O(n^2^)</strong>）或是用動態規劃處理（<strong>O(n)</strong>）<br>方法：利用變數 <strong><em>sum</em></strong> 加總a[0],a[1] 到 a[n-1]，在加總過程中，如果出現負數，則代表對最大子陣列沒有幫助（只會越來越少，所以捨棄），則讓sum=0 ，繼續加總，並在每一次相加過程紀錄最大值 <strong><em>max</em></strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,len = nums.<span class="built_in">size</span>(),max = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max)max = sum;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="背包問題"><a href="#背包問題" class="headerlink" title="背包問題"></a>背包問題</h2><p>背包問題總共有以下幾種：</p>
<ol>
<li><strong>分數背包</strong>（一個物品可以切下一部分、只取幾分之幾放進背包）—<em>Greedy</em></li>
<li><strong>01背包問題</strong></li>
<li><strong>無限背包</strong></li>
</ol>
<h3 id="分數背包"><a href="#分數背包" class="headerlink" title="分數背包"></a>分數背包</h3><p>策略：貪心法。每一次取單位價值最高的物品，優先放進背包。<br>總是用當下最好的物品填滿背包空隙，最後沒有留下任何空隙。每一份背包空間，都是最有價值的物品，就算是交換物品也無法增加總價值 ── 顯然是最佳解。<br>時間複雜度：$O(n)$，n為物品數量</p>
<h3 id="01背包問題"><a href="#01背包問題" class="headerlink" title="01背包問題"></a>01背包問題</h3><h4 id="不考慮最佳解路徑"><a href="#不考慮最佳解路徑" class="headerlink" title="不考慮最佳解路徑"></a>不考慮最佳解路徑</h4><p><strong>解一</strong>：暴力法（遞迴求解）。枚舉每一種物品要放或不放進背包，但複雜度會爆掉 $O(2^N)$<br>以zerojudge b184 為例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">105</span>],val[<span class="number">60005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">back_pack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//回傳n樣物品耐重為w的最大價值</span></span><br><span class="line">    <span class="keyword">if</span>(w&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1e9</span>;<span class="comment">//耐重為負，只能不取</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(</span><br><span class="line">       <span class="built_in">back_pack</span>(n<span class="number">-1</span>,w-weight[n])+val[n],<span class="comment">//取第n個物品</span></span><br><span class="line">       <span class="built_in">back_pack</span>(n<span class="number">-1</span>,w));<span class="comment">//不取第n個物品</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">        cout&lt;&lt;<span class="built_in">back_pack</span>(n,<span class="number">100</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(w&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>這兩行程式碼<strong>不能</strong>顛倒放，否則在最末端的計算上會出現問題！<br>（在這邊debug 超久，顛倒放會讓不該放的物品有可能被放進背包 :zany_face:）</p>
          </div>
<p><strong>解二</strong>：因為遞迴的關係，可以透過二維陣列紀錄小問題的解，這樣可以更有效率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">105</span>],val[<span class="number">60005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//dp[][]儲存放n樣物品耐重w的最大利潤</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">back_pack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//回傳n樣物品耐重為w的最大價值</span></span><br><span class="line">    <span class="keyword">if</span>(w&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[n][w])<span class="keyword">return</span> dp[n][w];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][w] = <span class="built_in">max</span>(</span><br><span class="line">       <span class="built_in">back_pack</span>(n<span class="number">-1</span>,w-weight[n])+val[n],</span><br><span class="line">       <span class="built_in">back_pack</span>(n<span class="number">-1</span>,w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">        cout&lt;&lt;<span class="built_in">back_pack</span>(n,<span class="number">100</span>)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">105</span>;k++)dp[i][k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解三</strong>：可以重複利用記憶體，建立一條陣列；不過計算順序要改成由陣列後端開始– 從前端可能會重複使用到同一個物品，而<strong>物品只有一個，不能重複利用</strong>(可以重複利用就變成無限背包)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">105</span>],val[<span class="number">60005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,w;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">    cin&gt;&gt;w;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=w;j&gt;=weight[i];j--)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-weight[i]]+val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[w]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>時間複雜度 <strong><em>O(NW)</em></strong> ，空間複雜度 <strong><em>O(W)</em></strong> 。其中 N 是物品數量， W 是背包重量限制。（上方11-15行）</p>
<p><strong>解四</strong>：用價值作為狀態，dp紀錄重量的最小值，可以看<a href="https://hackmd.io/P28wmXFHQ_-yZuEFQnfVuA">這裡</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,val[<span class="number">105</span>],weight[<span class="number">100005</span>];cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">        <span class="comment">//定義f(n,m)取n樣物品,價值為m,重量總和最小</span></span><br><span class="line">        <span class="comment">//dp[i]：價值為i時,重量最小為dp[i]</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10000</span>;j&gt;=val[i];j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j],dp[j-val[i]]+weight[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>時間複雜度 <strong><em>O(NV)</em></strong> ，空間複雜度 <strong><em>O(V)</em></strong> 。其中 N 是物品數量， V是價值總和。（上方11-15行）</p>
<p>細節注意：<br><div class="note success">
            <p><strong>背包問題是否恰好裝滿</strong></p><p>對於原本初始化dp[0] = 0，代表對於重量限制為0的背包價值最高為0<br>接下來有兩種情況需要討論，第一種是重量限制為w的背包最多的價值</p><p><strong>1. 恰好裝滿</strong><br>此時必須初始化dp[i] = -INF，是因為要恰好裝滿的關係，初始化的dp 數組事實上就是<strong>在沒有任何物品可以放入背包時的合法狀態</strong>，其他除了0之外容量的背包均沒有合法的解，屬於未定義的狀態，所以都應該被賦值為 −∞ 。當前的合法解，一定是從之前的合法狀態推得的</p><p><strong>2. 不需恰好裝滿</strong><br>如果背包並非必須被裝滿，那麼任何容量的背包都有一個合法解“什麼也不裝”，這個解的價值為0,所以初始化時狀態的值也就全部為0了。</p>
          </div></p>
<h4 id="考慮最佳解路徑"><a href="#考慮最佳解路徑" class="headerlink" title="考慮最佳解路徑"></a>考慮最佳解路徑</h4><p>需要二維陣列 <em>p[i][j]</em> 紀錄第 i 個物品在耐重 j 下是否有放入背包<br>由下面的程式碼可以發現，一個物品如果放入背包，則更新p[i][j]為1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">105</span>],val[<span class="number">60005</span>],p[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,w;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">    cin&gt;&gt;w;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=w;j&gt;=weight[i];j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j-weight[i]]+val[i]&gt;dp[j])&#123;</span><br><span class="line">                dp[j] = dp[j-weight[i]]+val[i];</span><br><span class="line">                p[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[w]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>,j = w;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i][j])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;個物品放入背包&quot;</span>&lt;&lt;endl;</span><br><span class="line">            j-=weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>為什麼上方第20行程式碼要從n-1開始跑？<br><div class="note default">
            <p>以下測資：</p><blockquote><p>4<br>3 20<br>4 45<br>9 70<br>12 85<br>12</p></blockquote><p>可以發現第1,3物品放入背包，但如果變成以下測資：</p><blockquote><p>5<br>3 20<br>4 45<br>9 70<br>12 85<br>3 100<br>12</p></blockquote><p>第五個物品可以取代第一個物品，如果從 j=0 開始計算，會把第一個物品也算進去，而這樣是錯的。從 n-1 開始計算可以確保答案正確。</p><p>其實從後面計算才能算到在w耐重下最後一個被加入背包的物品，如果從前面開始計算，前面不是最佳解的物品會被算進去。<br><img src="https://i.imgur.com/j93svqK.png" alt=""><br>以這個p[][]的結果來說，最後一個被加進去的才是最佳解，前面都是被替換掉的（在陣列dp[]中被取代，因為<strong>陣列dp[]被更新的條件就是有價值更高的解</strong>）</p>
          </div></p>
<p>轉移方向的不同：<br><div class="note info">
            <p>01背包問題在壓成一維的過程中必須知道是怎麼來的，從二維壓成一維，dp更新的順序要從前到後或後到前要看是存取到哪一格的內容。<br>這是<strong>01背包問題</strong>轉移式所用到的格子：<br>$f(n,m) = max(f(n-1,m),f(n-1,m-w_n)+v_n)$<br><img src="https://i.imgur.com/zavoNSH.png" alt=""><br>對於每一個f(n,m)只會取用到2個格子$f(n-1,m)$和$f(n-1,m-w_n)$兩個格子，如果從前到後更新格子的話，左上方的藍色格子會先被更新到，所以改成一維陣列之後必須要從後往前更新<br>接下來是<strong>無限背包問題</strong>：<br><img src="https://i.imgur.com/Io9scMn.png" alt=""><br>左邊的藍色格子是被更新後的，因此無限背包問題必須從前到後更新</p>
          </div></p>
<h3 id="無限背包"><a href="#無限背包" class="headerlink" title="無限背包"></a>無限背包</h3><p>物品有許多種類，每一種物品都無限量供應的背包問題。<br>演算法：跟解三差不多，因為物品有<strong>無限多個</strong>，所以第二個迴圈要從 <em>weight[i]</em> 開始執行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">105</span>],val[<span class="number">60005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,w;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];</span><br><span class="line">    cin&gt;&gt;w;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=weight[i];j&lt;=w;j++)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-weight[i]]+val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[w]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找零錢問題"><a href="#找零錢問題" class="headerlink" title="找零錢問題"></a>找零錢問題</h2><p>找零錢問題總共有以下幾種：</p>
<ol>
<li>湊得某價位的最少錢幣用量</li>
<li>湊得某個價位的湊法總共幾種</li>
</ol>
<p>找零錢問題就是弱化版的背包問題！</p>
<h3 id="湊得某價位的最少錢幣用量"><a href="#湊得某價位的最少錢幣用量" class="headerlink" title="湊得某價位的最少錢幣用量"></a>湊得某價位的最少錢幣用量</h3><h4 id="不考慮最佳解路徑-1"><a href="#不考慮最佳解路徑-1" class="headerlink" title="不考慮最佳解路徑"></a>不考慮最佳解路徑</h4><p>定義：<strong>dp(n,m)</strong> 代表用第0種到第n種錢幣湊得價位m的最少硬幣數<br>初始值：dp值設為 $\infty$（求最少），dp[0] = 0<br>轉移方式：$dp[j] = min(dp[j], dp[j-val[i]]+1)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">105</span>],val[<span class="number">100</span>],target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;val[i];</span><br><span class="line">    cin&gt;&gt;target;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x6f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=val[i];j&lt;=target;j++)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j-val[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[target]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="考慮最佳解路徑-1"><a href="#考慮最佳解路徑-1" class="headerlink" title="考慮最佳解路徑"></a>考慮最佳解路徑</h4><p>使用陣列p[i] 代表<strong>達成金額i元最後加入的硬幣面額（即達成最小硬幣數量的面額）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">105</span>],val[<span class="number">100</span>],target,p[<span class="number">105</span>];</span><br><span class="line"><span class="comment">//p[i]達成金額i元最後加入的硬幣面額</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;val[i];</span><br><span class="line">    cin&gt;&gt;target;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x6f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=val[i];j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]&gt;dp[j-val[i]]+<span class="number">1</span>)&#123;<span class="comment">//加入第i種硬幣，使數量更少</span></span><br><span class="line">                dp[j] = dp[j-val[i]]+<span class="number">1</span>;</span><br><span class="line">                p[j] = val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//陣列p留下來的即為達成金額i元最後加入的硬幣面額</span></span><br><span class="line">    cout&lt;&lt;dp[target]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span>  k= target;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        k = k - p[k];<span class="comment">//前往下一個錢幣數目</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="湊得某個價位的湊法總共幾種"><a href="#湊得某個價位的湊法總共幾種" class="headerlink" title="湊得某個價位的湊法總共幾種"></a>湊得某個價位的湊法總共幾種</h3><p>定義：<strong>dp(n,m)</strong> 代表用第0種到第n種錢幣湊得價位m的湊法數目<br>初始值：dp[0]=1(雖然現實中不可能湊到0元)<br>轉移方式：$dp[j] =dp[j] + dp[j-val[i]]$<br><div class="note info">
            <p>程式碼中使用 <strong>+=</strong> 是因為「不加上第n種錢幣的湊法（就是未更新的dp[j]）」加上「加上第n種錢幣的湊法（剩下的就是湊滿 <strong>j-val[i]</strong> 的湊法）」</p>
          </div></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">1005</span>],val[<span class="number">105</span>],target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;val[i];</span><br><span class="line">    cin&gt;&gt;target;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=val[i];j&lt;=target;j++)&#123;</span><br><span class="line">            dp[j] += dp[j-val[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[target]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最長上升子序列（LIS）"><a href="#最長上升子序列（LIS）" class="headerlink" title="最長上升子序列（LIS）"></a>最長上升子序列（LIS）</h2><blockquote>
<p>給你一個正整數序列，問你最多可以從裡面選出幾個元素（不改變順序），使得這些元素嚴格遞增。</p>
</blockquote>
<h3 id="不考慮最佳解路徑-2"><a href="#不考慮最佳解路徑-2" class="headerlink" title="不考慮最佳解路徑"></a>不考慮最佳解路徑</h3><p>解一：複雜度（O(n^2^)）<br>定義：以陣列dp[i] 代表長度為序列長度為 i 時的LIS(讓dp[i]表示取了a[i]為最後一個數字的LIS)<br>初始值：dp中的每一個元素初始值為1<br>轉移方式：將第 i 個元素設為第 0 到 i-1 的元素之最大值加一：<br>$dp[i] = max_{j&lt;i,a[j]&lt;a[i]} (dp[j])+1$</p>
<p>以<a href="https://tioj.ck.tp.edu.tw/problems/1175">tioj 1175 Longest Increasing Subsequence</a>為例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[<span class="number">100005</span>],dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[i])</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = *<span class="built_in">max_element</span>(dp,dp+n);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解二：複雜度（$O(nlogn)$）<br>可以利用<em>vector</em>維護一個嚴格遞增的序列，同時利用lower_bound 來二分搜a[i]該在序列中的哪一個位置<br>以 <a href="https://leetcode.com/problems/longest-increasing-subsequence/">leetcode 300</a>為例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; lis;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        lis.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lis.<span class="built_in">back</span>()&lt;nums[i])lis.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(lis.<span class="built_in">begin</span>(),lis.<span class="built_in">end</span>(),nums[i]) = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lis.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="考慮最佳解路徑-2"><a href="#考慮最佳解路徑-2" class="headerlink" title="考慮最佳解路徑"></a>考慮最佳解路徑</h3><div class="note warning">
            <p>上面方法雖然可以正確求出LIS的長度，卻無法保證vector lis裡面儲存的是正確的序列（當最末端的LIS出現後，後面的元素會因為lower_bound插入的關係出現在序列的中間<br>解決方法：透過dp[]紀錄每一個元素出現的位置，可以求得正確的序列</p>
          </div>
<p>key：下方第30-35行程式碼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,L,dp[<span class="number">100005</span>],temp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec,lis,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    lis.<span class="built_in">push_back</span>(vec[<span class="number">0</span>]);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&gt;lis.<span class="built_in">back</span>())&#123;</span><br><span class="line">            lis.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">            ind = lis.<span class="built_in">size</span>();</span><br><span class="line">            dp[i] = ind;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ind = <span class="built_in">lower_bound</span>(lis.<span class="built_in">begin</span>(), lis.<span class="built_in">end</span>(),vec[i])-lis.<span class="built_in">begin</span>();</span><br><span class="line">            lis[ind] = vec[i];</span><br><span class="line">            dp[i] = ind+<span class="number">1</span>;<span class="comment">//dp以1為起始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L = lis.<span class="built_in">size</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LIS:&quot;</span>&lt;&lt;L&lt;&lt;endl;<span class="comment">//輸出lis長度，但此時vector lis中的序列是錯誤的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == L)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vec[i]);<span class="comment">//利用vec裡的東西產生正確序列ans，捨棄lis</span></span><br><span class="line">            L--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: ans)cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>範例測資：<br>8<br>10 9 2 5 3 7 101 6<br>得到的dp = {1 1 <strong>1</strong> 2 <strong>2</strong> <strong>3</strong> <strong>4</strong> 3}<br>我們要的就是上方粗體對應到的就是正確的LIS：2 3 7 101</p>
          </div>
<h2 id="最長共同子序列（LCS）"><a href="#最長共同子序列（LCS）" class="headerlink" title="最長共同子序列（LCS）"></a>最長共同子序列（LCS）</h2><blockquote>
<p>給定兩個英文字串，找出 LCS。（在兩個字串中各取出字串中字元，使兩者相等的最大長度—字母順序不可以改變）</p>
</blockquote>
<h3 id="不考慮最佳解路徑-3"><a href="#不考慮最佳解路徑-3" class="headerlink" title="不考慮最佳解路徑"></a>不考慮最佳解路徑</h3><p>定義：給定字串 s1,s2，dp[n][m]為s1長度為n、s2長度為m時的LCS<br>初始值：初始陣列dp為0<br>轉移：</p>
<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1]+1, if\ s1[i-1]=s2[j-1]$$$$dp[i][j] = max(dp[i-1][j],dp[i][j-1]), if\ s1[i-1]!=s2[j-1]</script><p>推導過程可以看：<a href="https://www.csie.ntu.edu.tw/~sprout/algo2016/ppt_pdf/dynamic_programming_2.pdf">資芽講義</a></p>
<p>以 leetcode <a href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a>為例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = text1.<span class="built_in">size</span>(), n2 = text2.<span class="built_in">size</span>(),dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="考慮最佳解路徑-3"><a href="#考慮最佳解路徑-3" class="headerlink" title="考慮最佳解路徑"></a>考慮最佳解路徑</h3><p>求出一組LCS的方法，可以利用一個二維陣列p[i][j] 紀錄dp[i][j]從何而來，由求LCS的過程中可以發現，dp[i][j]可以有三個來源(18-32行)，分別是：</p>
<ol>
<li>左上格（此時a[i]=b[j]) — 定義為0</li>
<li>左格（此時 dp[i][j-1]&gt;dp[i-1][j]）— 定義為1</li>
<li>上格（此時 dp[i-1][j]&gt;dp[i][j-1]）— 定義為2</li>
</ol>
<p>紀錄完成後，透過遞迴或迴圈的方式回朔求得答案。從末端開始，如果遇到0 則往左上格移動，1 則往左格，2則往上格。</p>
<p><strong>利用遞迴求解</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)<span class="keyword">return</span>;<span class="comment">//邊界</span></span><br><span class="line">    <span class="keyword">if</span>(p[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p[i][j]==<span class="number">1</span>)<span class="built_in">print</span>(i, j<span class="number">-1</span>);<span class="comment">//左格</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">print</span>(i<span class="number">-1</span>, j);<span class="comment">//上格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用迴圈求解</strong><br>因為是利用回朔法，輸出會是反序，因此新開一個陣列儲存答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!len)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = len;</span><br><span class="line">    <span class="keyword">char</span> lcs[l];</span><br><span class="line">    <span class="keyword">while</span>(l&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            l--;i--;j--;</span><br><span class="line">            lcs[l] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[i][j]==<span class="number">1</span>)j--;<span class="comment">//左格</span></span><br><span class="line">        <span class="keyword">else</span> i--;<span class="comment">//上格</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;lcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整版程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="keyword">int</span> lenA,lenB,p[<span class="number">1005</span>][<span class="number">1005</span>],len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    lenA = a.<span class="built_in">length</span>();</span><br><span class="line">    lenB = b.<span class="built_in">length</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(p));<span class="comment">//紀錄每一個dp元素從何而來</span></span><br><span class="line">    <span class="comment">//定義：0 左上格，1 左格，2上格。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                p[i][j] = <span class="number">0</span>;<span class="comment">//left-top</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]&lt;dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    p[i][j] = <span class="number">1</span>;<span class="comment">//left</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    p[i][j] = <span class="number">2</span>;<span class="comment">//top</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    len = dp[lenA][lenB];</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(lenA, lenB);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遞迴</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(p[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p[i][j]==<span class="number">1</span>)<span class="built_in">print</span>(i, j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">print</span>(i<span class="number">-1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迴圈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!len)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = len;</span><br><span class="line">    <span class="keyword">char</span> lcs[l];</span><br><span class="line">    <span class="keyword">while</span>(l&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            l--;i--;j--;</span><br><span class="line">            lcs[l] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[i][j]==<span class="number">1</span>)j--;</span><br><span class="line">        <span class="keyword">else</span> i--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;lcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="題目＆資源"><a href="#題目＆資源" class="headerlink" title="題目＆資源"></a>題目＆資源</h2><p><a href="https://slides.com/justinlai2003/dq-dp#/6">學長講yee</a><br><a href="https://leetcode.com/tag/dynamic-programming/">https://leetcode.com/tag/dynamic-programming/</a></p>
<ul>
<li>[x] <a href="https://tioj.ck.tp.edu.tw/problems/1354">https://tioj.ck.tp.edu.tw/problems/1354</a></li>
<li>[x] <a href="https://tioj.ck.tp.edu.tw/problems/1019">https://tioj.ck.tp.edu.tw/problems/1019</a></li>
<li>[ ] <a href="https://codeforces.com/problemset/problem/1207/C">https://codeforces.com/problemset/problem/1207/C</a></li>
<li>[x] <a href="https://tioj.ck.tp.edu.tw/problems/1097">https://tioj.ck.tp.edu.tw/problems/1097</a></li>
<li>[ ] <a href="https://codeforces.com/problemset/problem/1398/D">https://codeforces.com/problemset/problem/1398/D</a></li>
<li>[x] <a href="https://tioj.ck.tp.edu.tw/problems/1029">https://tioj.ck.tp.edu.tw/problems/1029</a></li>
<li>[x] <a href="https://zerojudge.tw/ShowProblem?problemid=d038">https://zerojudge.tw/ShowProblem?problemid=d038</a></li>
<li>[x] <a href="https://zerojudge.tw/ShowProblem?problemid=d390">https://zerojudge.tw/ShowProblem?problemid=d390</a></li>
<li>[x] <a href="https://zerojudge.tw/ShowProblem?problemid=d133">https://zerojudge.tw/ShowProblem?problemid=d133</a></li>
<li>[x] <a href="https://zerojudge.tw/ShowProblem?problemid=a133">https://zerojudge.tw/ShowProblem?problemid=a133</a></li>
<li>[x] <a href="https://zerojudge.tw/ShowProblem?problemid=d674">https://zerojudge.tw/ShowProblem?problemid=d674</a></li>
</ul>
]]></content>
      <categories>
        <category>C++基礎主題</category>
        <category>動態規劃</category>
      </categories>
      <tags>
        <tag>演算法</tag>
        <tag>動態規劃</tag>
      </tags>
  </entry>
  <entry>
    <title>Geometry in Leetcode &amp; CSES</title>
    <url>/geo3/</url>
    <content><![CDATA[<h2 id="CSES-Geometry"><a href="#CSES-Geometry" class="headerlink" title="CSES Geometry"></a>CSES Geometry</h2><ul>
<li>Point Location Test</li>
<li>Line Segment Intersection</li>
<li>Polygon Area</li>
<li>Point in Polygon</li>
<li>Polygon Lattice Points</li>
<li>Minimum Euclidean Distance</li>
<li>Convex Hull</li>
</ul>
<span id="more"></span>
<h3 id="Point-Location-Test"><a href="#Point-Location-Test" class="headerlink" title="Point Location Test"></a>Point Location Test</h3><p><a href="https://cses.fi/paste/3a495a0f4bdec8af2df7b4/">CODE</a></p>
<p>給你三個點 $P_1,P_2,P_3$ ，判斷出向量 $(P_1,P_2)$ 之於 $P_3$ 的方向為何？<br>關係共有相交、位於左側以及位於右側。</p>
<h3 id="Line-Segment-Intersection"><a href="#Line-Segment-Intersection" class="headerlink" title="Line Segment Intersection"></a>Line Segment Intersection</h3><p><a href="https://cses.fi/paste/854258b8f67b255c2df828/">CODE</a></p>
<p>給你兩條線段，判斷他們是否相交。線段相交裸題。</p>
<h3 id="Polygon-Area"><a href="#Polygon-Area" class="headerlink" title="Polygon Area"></a>Polygon Area</h3><p><a href="https://cses.fi/paste/49f2a020a47797b42df861/">CODE</a></p>
<p>給你N個點，計算出此多邊形圍成的面積為何。帶入行列式公式可解。</p>
<h3 id="Point-in-Polygon"><a href="#Point-in-Polygon" class="headerlink" title="Point in Polygon"></a>Point in Polygon</h3><p><a href="https://cses.fi/paste/d0edfaf7380124852e075e/">CODE</a></p>
<p>給你N個點構成的一個簡單多邊形，判斷一個點是否在多邊形內部。</p>
<p>參考資料：<a href="https://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon/">greekforgreek</a></p>
<p><img src="https://i.imgur.com/q3bqqWZ.png" alt=""></p>
<p>凸多邊形的情況，我們可以利用內角和是360度轉一圈的的方法，判斷一點是否在多邊形內部。但本題是簡單多邊形，因此用這種方法是不可行的。</p>
<p><img src="https://i.imgur.com/FbcWiwl.png" alt=""></p>
<p>這張圖是作法，我們做出一個由x點出發向x軸正向的射線，計算這一條射線跟多邊形共有幾個交點。如果是奇數，表示在內部；反之則是在外部。交在多邊形上的點要特別注意，因為他可能會被統計到兩次，因此我們特別處理當點相交一點時，只計算那條邊的兩端點中，y座標比較大的那一點是否相交的情況。</p>
<p>最後，我們發現遇上如圖中g點的狀況直接就被處理好了！他會被算到零次，因為在看兩條邊加上去之後，又因為頂點是y座標比較大的，會被剪掉兩次。</p>
<h3 id="Polygon-Lattice-Points"><a href="#Polygon-Lattice-Points" class="headerlink" title="Polygon Lattice Points"></a>Polygon Lattice Points</h3><p><a href="https://cses.fi/paste/7fa78ccd60f7877f2e07dc/">CODE</a></p>
<p>給定頂點座標均是整點（或正方形格子點）的簡單多邊形，皮克定理說明了其面積 $A$ 和內部格點數目 $i$、邊上格點數目 $b$ 的關係：</p>
<script type="math/tex; mode=display">A = i + \frac{b}{2} - 1</script><p><a href="http://episte.math.ntu.edu.tw/articles/sm/sm_25_10_1/index.html">PROOF</a></p>
<h3 id="Minimum-Euclidean-Distance"><a href="#Minimum-Euclidean-Distance" class="headerlink" title="Minimum Euclidean Distance"></a>Minimum Euclidean Distance</h3><p><a href="https://cses.fi/paste/a728ec171111ce792e091f/">CODE</a></p>
<p><a href="https://hackmd.io/@peienwu/closest_pair">最近點對問題</a>。不過，既然是計算幾何，我們就用掃描線做最近點對。掃描線有兩個做法（可以參考那個連結），至於搭配set輔助步驟就是：</p>
<ol>
<li>將點輸入並且排序，X座標為主，Y座標為輔。</li>
<li>使用set，並以Y座標為排序基準（pair的首項），以儲存第 $i$ 點的左方、水平距離小於等於d的點。</li>
<li>右掃描線依序窮舉各點作為右端點。<br>　(1) Erase與右端點水平距離大於d的點們（左掃描線右移）<br>　(2) 用二分搜找出與第 $i$ 點垂直距離小於d的點，並嘗試更新<br>　(3) 將第 $i$ 點加入set中。</li>
</ol>
<p><img src="https://i.imgur.com/yMs369S.png" alt=""></p>
<h3 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h3><p><a href="https://cses.fi/paste/ac97fa8545e467692e09aa/">CODE</a></p>
<p>凸包裸題。</p>
<h2 id="Leetcode：Geography"><a href="#Leetcode：Geography" class="headerlink" title="Leetcode：Geography"></a>Leetcode：Geography</h2><p>Leetcode 總共有27題的tag是計算幾何的，<a href="https://leetcode.com/tag/geometry/">題單在這裡</a>。有三題被鎖起來不能看，所以總共有24題。</p>
<h3 id="149-Max-Points-on-a-Line"><a href="#149-Max-Points-on-a-Line" class="headerlink" title="149 Max Points on a Line"></a>149 Max Points on a Line</h3><p><a href="https://leetcode.com/problems/max-points-on-a-line">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)<span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b % a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">int</span> same = <span class="number">0</span>,hori = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dx = points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> dy = points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>)&#123;same++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(dx == <span class="number">0</span> &amp;&amp; dy != <span class="number">0</span>)&#123;hori++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">int</span> g = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(dx),<span class="built_in">abs</span>(dy));</span><br><span class="line">                <span class="keyword">if</span>(dy &lt; <span class="number">0</span> || (dy == <span class="number">0</span> &amp;&amp; dx &lt; <span class="number">0</span>))&#123;dx = -dx;dy = -dy;&#125;</span><br><span class="line">                mp[&#123;dx/g,dy/g&#125;]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = hori + same + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : mp)sum = <span class="built_in">max</span>(sum,it.second + <span class="number">1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="223-Rectangle-Area"><a href="#223-Rectangle-Area" class="headerlink" title="223 Rectangle Area"></a>223 Rectangle Area</h3><p><a href="https://leetcode.com/problems/rectangle-area">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> ax1, <span class="keyword">int</span> ay1, <span class="keyword">int</span> ax2, <span class="keyword">int</span> ay2, <span class="keyword">int</span> bx1, <span class="keyword">int</span> by1, <span class="keyword">int</span> bx2, <span class="keyword">int</span> by2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">max</span>(<span class="built_in">min</span>(ax2,bx2) - <span class="built_in">max</span>(ax1,bx1),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">max</span>(<span class="built_in">min</span>(ay2,by2) - <span class="built_in">max</span>(ay1,by1),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = (ax2 - ax1)*(ay2 - ay1)+(bx2 - bx1)*(by2 - by1)-x * y;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="335-Self-Crossing"><a href="#335-Self-Crossing" class="headerlink" title="335 Self Crossing"></a>335 Self Crossing</h3><p><a href="https://leetcode.com/problems/self-crossing">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfCrossing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="comment">//第四條、第五條、第六條交第一條</span></span><br><span class="line">            <span class="keyword">if</span>(d[i] &gt;= d[i<span class="number">-2</span>] &amp;&amp; d[i<span class="number">-1</span>] &lt;= d[i<span class="number">-3</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">4</span> &amp;&amp; d[i<span class="number">-1</span>] == d[i<span class="number">-3</span>] &amp;&amp; d[i] + d[i<span class="number">-4</span>] &gt;= d[i<span class="number">-2</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">5</span> &amp;&amp; d[i<span class="number">-2</span>] &gt;= d[i<span class="number">-4</span>] &amp;&amp; d[i] &gt;= d[i<span class="number">-2</span>] - d[i<span class="number">-4</span>]</span><br><span class="line">              &amp;&amp; d[i<span class="number">-1</span>] &gt;= d[i<span class="number">-3</span>]-d[i<span class="number">-5</span>] &amp;&amp; d[i<span class="number">-1</span>] &lt;= d[i<span class="number">-3</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="587-Erect-the-Fence"><a href="#587-Erect-the-Fence" class="headerlink" title="587 Erect the Fence"></a>587 Erect the Fence</h3><p><a href="https://leetcode.com/problems/erect-the-fence">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ff first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pii a,pii b,pii o)</span></span>&#123;</span><br><span class="line">        pii aa = &#123;a.ff - o.ff,a.ss - o.ss&#125;;</span><br><span class="line">        pii bb = &#123;b.ff - o.ff,b.ss - o.ss&#125;;</span><br><span class="line">        <span class="keyword">int</span> cross = aa.ff * bb.ss - aa.ss * bb.ff;</span><br><span class="line">        <span class="keyword">return</span> cross &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">outerTrees</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; point) &#123;</span><br><span class="line">        vector&lt;pii&gt; h;</span><br><span class="line">        <span class="keyword">int</span> n = point.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;pii&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)p[i] = &#123;point[i][<span class="number">0</span>],point[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(h.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">                h.<span class="built_in">pop_back</span>();</span><br><span class="line">            h.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> down = h.<span class="built_in">size</span>();</span><br><span class="line">        h.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(h.<span class="built_in">size</span>() &gt; down &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">                h.<span class="built_in">pop_back</span>();</span><br><span class="line">            h.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;pii&gt; s;<span class="keyword">for</span>(<span class="keyword">auto</span> i : h)s.<span class="built_in">insert</span>(i);</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;ans.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)ans[i].<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)&#123;ans[id][<span class="number">0</span>] = i.ff;ans[id][<span class="number">1</span>] = i.ss;id++;&#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="593-Valid-Square"><a href="#593-Valid-Square" class="headerlink" title="593 Valid Square"></a>593 Valid Square</h3><p><a href="https://leetcode.com/problems/valid-square">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; p1, vector&lt;<span class="keyword">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = p1[<span class="number">0</span>] - p2[<span class="number">0</span>],y = p1[<span class="number">1</span>] - p2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validSquare</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; p1, vector&lt;<span class="keyword">int</span>&gt;&amp; p2, vector&lt;<span class="keyword">int</span>&gt;&amp; p3, vector&lt;<span class="keyword">int</span>&gt;&amp; p4)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;     <span class="comment">//長度、個數</span></span><br><span class="line">        mp[<span class="built_in">dis</span>(p1,p2)]++;</span><br><span class="line">        mp[<span class="built_in">dis</span>(p1,p3)]++;</span><br><span class="line">        mp[<span class="built_in">dis</span>(p1,p4)]++;</span><br><span class="line">        mp[<span class="built_in">dis</span>(p2,p3)]++;</span><br><span class="line">        mp[<span class="built_in">dis</span>(p2,p4)]++;</span><br><span class="line">        mp[<span class="built_in">dis</span>(p3,p4)]++;</span><br><span class="line">        <span class="keyword">return</span> mp.<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; mp.<span class="built_in">begin</span>()-&gt;second == <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="812-Largest-Triangle-Area"><a href="#812-Largest-Triangle-Area" class="headerlink" title="812    Largest Triangle Area"></a>812    Largest Triangle Area</h3><p><a href="https://leetcode.com/problems/largest-triangle-area">題目連結</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cross</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x1 * y2 - x2 * y1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> e,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        sum += <span class="built_in">cross</span>(a,b,c,d);</span><br><span class="line">        sum += <span class="built_in">cross</span>(c,d,e,f);</span><br><span class="line">        sum += <span class="built_in">cross</span>(e,f,a,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sum / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestTriangleArea</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = j + <span class="number">1</span>;p &lt; n;p++)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,<span class="built_in">area</span>(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>]</span><br><span class="line">                                      ,points[j][<span class="number">0</span>],points[j][<span class="number">1</span>]</span><br><span class="line">                                      ,points[p][<span class="number">0</span>],points[p][<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="836-Rectangle-Overlap"><a href="#836-Rectangle-Overlap" class="headerlink" title="836 Rectangle Overlap"></a>836 Rectangle Overlap</h3><p><a href="https://leetcode.com/problems/rectangle-overlap">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rec1, vector&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小的右端點 - 最大的左端點</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">min</span>(rec1[<span class="number">2</span>],rec2[<span class="number">2</span>]) - <span class="built_in">max</span>(rec1[<span class="number">0</span>],rec2[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//最小的上端點 - 最大的下端點</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">min</span>(rec1[<span class="number">3</span>],rec2[<span class="number">3</span>]) - <span class="built_in">max</span>(rec1[<span class="number">1</span>],rec2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="858-Mirror-Reflection"><a href="#858-Mirror-Reflection" class="headerlink" title="858 Mirror Reflection"></a>858 Mirror Reflection</h3><p><a href="https://leetcode.com/problems/mirror-reflection">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)<span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b % a,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mirrorReflection</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = p * q / <span class="built_in">gcd</span>(q,p);</span><br><span class="line">        <span class="keyword">int</span> a = (len / p) % <span class="number">2</span>,b = (len / q) % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="478-Generate-Random-Point-in-a-Circle"><a href="#478-Generate-Random-Point-in-a-Circle" class="headerlink" title="478 Generate Random Point in a Circle"></a>478 Generate Random Point in a Circle</h3><p><a href="https://leetcode.com/problems/generate-random-point-in-a-circle">題目連結</a></p>
<p>直接Random半徑會出事（可能不夠亂，或是半徑太小），如果random面積之後算半徑才OK。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> R,X,Y;</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        R = radius;X = x_center;Y = y_center;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> Area = <span class="built_in">rand</span>() * R * R * M_PI / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(Area / M_PI);</span><br><span class="line">        <span class="keyword">double</span> theta = <span class="number">2.0</span> * M_PI * <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(X + r * <span class="built_in">cos</span>(theta));</span><br><span class="line">        ans.<span class="built_in">push_back</span>(Y + r * <span class="built_in">sin</span>(theta));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * vector&lt;double&gt; param_1 = obj-&gt;randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="883-Projection-Area-of-3D-Shapes"><a href="#883-Projection-Area-of-3D-Shapes" class="headerlink" title="883 Projection Area of 3D Shapes"></a>883 Projection Area of 3D Shapes</h3><p><a href="https://leetcode.com/problems/projection-area-of-3d-shapes">題目連結</a></p>
<p>三種不同的投影對應到三種不同的角度看圖形。x-y的面積即為由上而下看有方格的個數。x-z是從前方看，因此對應到的是每一行的最大方塊個數。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">projectionArea</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxR = <span class="number">0</span>,maxC = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">0</span>)ans++;        <span class="comment">//由上往下看</span></span><br><span class="line">                maxR = <span class="built_in">max</span>(maxR,grid[i][j]);    <span class="comment">//由側邊看</span></span><br><span class="line">                maxC = <span class="built_in">max</span>(maxC,grid[j][i]);    <span class="comment">//由前面看</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += maxR + maxC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="892-Surface-Area-of-3D-Shapes"><a href="#892-Surface-Area-of-3D-Shapes" class="headerlink" title="892 Surface Area of 3D Shapes"></a>892 Surface Area of 3D Shapes</h3><p><a href="https://leetcode.com/problems/surface-area-of-3d-shapes">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">0</span>)ans += <span class="number">4</span> * grid[i][j] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">                    ans -= <span class="built_in">min</span>(grid[i][j],grid[i+<span class="number">1</span>][j])*<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">                    ans -= <span class="built_in">min</span>(grid[i][j],grid[i][j+<span class="number">1</span>])*<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="939-Minimum-Area-Rectangle"><a href="#939-Minimum-Area-Rectangle" class="headerlink" title="939 Minimum Area Rectangle"></a>939 Minimum Area Rectangle</h3><p><a href="https://leetcode.com/problems/minimum-area-rectangle">題目連結</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;p = points;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)s.<span class="built_in">insert</span>(&#123;p[i][<span class="number">0</span>],p[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">find</span>(&#123;p[i][<span class="number">0</span>],p[j][<span class="number">1</span>]&#125;)!=s.<span class="built_in">end</span>() </span><br><span class="line">                   &amp;&amp; s.<span class="built_in">find</span>(&#123;p[j][<span class="number">0</span>],p[i][<span class="number">1</span>]&#125;)!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p[i][<span class="number">0</span>] == p[j][<span class="number">0</span>] || p[i][<span class="number">1</span>] == p[j][<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans,<span class="built_in">abs</span>(p[i][<span class="number">0</span>]-p[j][<span class="number">0</span>])*<span class="built_in">abs</span>(p[i][<span class="number">1</span>]-p[j][<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="963-Minimum-Area-Rectangle-II"><a href="#963-Minimum-Area-Rectangle-II" class="headerlink" title="963 Minimum Area Rectangle II"></a>963 Minimum Area Rectangle II</h3><p><a href="https://leetcode.com/problems/minimum-area-rectangle-ii">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">minAreaFreeRect</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span></span>&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)s.<span class="built_in">insert</span>(&#123;p[i][<span class="number">0</span>],p[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = p[j][<span class="number">0</span>] - p[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y1 = p[j][<span class="number">1</span>] - p[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>;k &lt; n;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x2 = p[k][<span class="number">0</span>] - p[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y2 = p[k][<span class="number">1</span>] - p[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x1 * x2 + y1 * y2 != <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> nx = p[k][<span class="number">0</span>] + x1,ny = p[k][<span class="number">1</span>] + y1;</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">find</span>(&#123;nx,ny&#125;) != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        ans = <span class="built_in">min</span>(ans,<span class="built_in">sqrt</span>(x1*x1+y1*y1) * <span class="built_in">sqrt</span>(x2*x2+y2*y2));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">1e9</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="973-K-Closest-Points-to-Origin"><a href="#973-K-Closest-Points-to-Origin" class="headerlink" title="973 K Closest Points to Origin"></a>973 K Closest Points to Origin</h3><p><a href="https://leetcode.com/problems/k-closest-points-to-origin">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = points[i][<span class="number">1</span>];</span><br><span class="line">            mp.<span class="built_in">insert</span>(&#123;x * x + y * y,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = it-&gt;second;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(points[id]);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1030-Matrix-Cells-in-Distance-Order"><a href="#1030-Matrix-Cells-in-Distance-Order" class="headerlink" title="1030 Matrix Cells in Distance Order"></a>1030 Matrix Cells in Distance Order</h3><p><a href="https://leetcode.com/problems/matrix-cells-in-distance-order">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allCellsDistOrder</span>(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rCenter, <span class="keyword">int</span> cCenter) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = rows,m = cols;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dis = <span class="built_in">abs</span>(i - rCenter) + <span class="built_in">abs</span>(j - cCenter);</span><br><span class="line">                mp.<span class="built_in">insert</span>(&#123;dis,&#123;i,j&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;ans.<span class="built_in">resize</span>(n*m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*m;i++)ans[i].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : mp)&#123;</span><br><span class="line">            ans[id][<span class="number">0</span>] = (it.second.first);</span><br><span class="line">            ans[id][<span class="number">1</span>] = (it.second.second);</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1037-Valid-Boomerang"><a href="#1037-Valid-Boomerang" class="headerlink" title="1037 Valid Boomerang"></a>1037 Valid Boomerang</h3><p><a href="https://leetcode.com/problems/valid-boomerang">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = points[<span class="number">1</span>][<span class="number">0</span>]-points[<span class="number">0</span>][<span class="number">0</span>],y1 = points[<span class="number">1</span>][<span class="number">1</span>]-points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = points[<span class="number">2</span>][<span class="number">0</span>]-points[<span class="number">1</span>][<span class="number">0</span>],y2 = points[<span class="number">2</span>][<span class="number">1</span>]-points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cross = x1 * y2 - x2 * y1;</span><br><span class="line">        <span class="keyword">if</span>(cross == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1232-Check-If-It-Is-a-Straight-Line"><a href="#1232-Check-If-It-Is-a-Straight-Line" class="headerlink" title="1232 Check If It Is a Straight Line"></a>1232 Check If It Is a Straight Line</h3><p><a href="https://leetcode.com/problems/check-if-it-is-a-straight-line">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; p = coordinates;</span><br><span class="line">        <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = p[i+<span class="number">1</span>][<span class="number">0</span>] - p[i][<span class="number">0</span>],y1 = p[i+<span class="number">1</span>][<span class="number">1</span>] - p[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x2 = p[i+<span class="number">2</span>][<span class="number">0</span>] - p[i+<span class="number">1</span>][<span class="number">0</span>],y2 = p[i+<span class="number">2</span>][<span class="number">1</span>] - p[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x1 * y2 != x2 * y1)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1266-Minimum-Time-Visiting-All-Points"><a href="#1266-Minimum-Time-Visiting-All-Points" class="headerlink" title="1266 Minimum Time Visiting All Points"></a>1266 Minimum Time Visiting All Points</h3><p><a href="https://leetcode.com/problems/minimum-time-visiting-all-points">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; p = points;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">abs</span>(p[i+<span class="number">1</span>][<span class="number">0</span>] - p[i][<span class="number">0</span>]),<span class="built_in">abs</span>(p[i+<span class="number">1</span>][<span class="number">1</span>] - p[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1401-Circle-and-Rectangle-Overlapping"><a href="#1401-Circle-and-Rectangle-Overlapping" class="headerlink" title="1401 Circle and Rectangle Overlapping"></a>1401 Circle and Rectangle Overlapping</h3><p><a href="https://leetcode.com/problems/circle-and-rectangle-overlapping">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">clamp</span>(x_center,x1,x2) - x_center;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">clamp</span>(y_center,y1,y2) - y_center;</span><br><span class="line">        <span class="keyword">return</span> x*x + y*y &lt;= radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="1453 Maximum Number of Darts Inside of a Circular Dartboard"></a>1453 Maximum Number of Darts Inside of a Circular Dartboard</h3><p><a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;ld,ld&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> exp 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(pdd a,pdd b)</span></span>&#123;</span><br><span class="line">        ld x = a.x - b.x,y = a.y - b.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">pair&lt;pdd,pdd&gt; <span class="title">get_center</span><span class="params">(pdd a,pdd b,ld R)</span></span>&#123;</span><br><span class="line">        pdd mid = &#123;(a.x + b.x) / <span class="number">2</span>,(a.y + b.y) / <span class="number">2</span>&#125;;</span><br><span class="line">        ld theta = <span class="built_in">atan2</span>(a.y - b.y, b.x - a.x);</span><br><span class="line">        ld tmp = <span class="built_in">dis</span>(a,b) / <span class="number">2</span>, d = <span class="built_in">sqrt</span>(R * R - tmp * tmp);</span><br><span class="line">        </span><br><span class="line">        pair&lt;pdd,pdd&gt; ans;</span><br><span class="line">        ans.x = &#123;mid.x - d * <span class="built_in">sin</span>(theta),mid.y - d * <span class="built_in">cos</span>(theta)&#125;;</span><br><span class="line">        ans.y = &#123;mid.x + d * <span class="built_in">sin</span>(theta),mid.y + d * <span class="built_in">cos</span>(theta)&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; point, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = point.<span class="built_in">size</span>(),ans = <span class="number">1</span>;</span><br><span class="line">        pdd p[n];<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;p[i] = &#123;point[i][<span class="number">0</span>],point[i][<span class="number">1</span>]&#125;;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dis</span>(p[i],p[j]) - <span class="number">2.0</span> * R &gt;= exp)<span class="keyword">continue</span>;</span><br><span class="line">                pair&lt;pdd,pdd&gt; cur = <span class="built_in">get_center</span>(p[i],p[j],R);</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dis</span>(p[k], cur.x) - R&lt;= exp)cnt ++;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt);cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dis</span>(p[k], cur.y) - R &lt;= exp)cnt ++;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1515-Best-Position-for-a-Service-Centre"><a href="#1515-Best-Position-for-a-Service-Centre" class="headerlink" title="1515 Best Position for a Service Centre"></a>1515 Best Position for a Service Centre</h3><p><a href="https://leetcode.com/problems/best-position-for-a-service-centre">題目連結</a></p>
<p>這一題是模擬退火，非常酷，之前沒有寫過的東西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;ld,ld&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pdd p[<span class="number">105</span>];<span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ld <span class="title">dis_all</span><span class="params">(pdd mid)</span></span>&#123;</span><br><span class="line">        ld sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ld x = p[i].x - mid.x,y = p[i].y - mid.y;</span><br><span class="line">            sum += <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinDistSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)p[i] = &#123;pos[i][<span class="number">0</span>],pos[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        pdd cur = p[<span class="number">0</span>];ld mid_dis = <span class="built_in">dis_all</span>(p[<span class="number">0</span>]);</span><br><span class="line">        ld test_size = <span class="number">100</span>;</span><br><span class="line">        ld dx[<span class="number">4</span>] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(test_size &gt; eps)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">                pdd newp = cur;</span><br><span class="line">                newp.x += dx[i] * test_size;</span><br><span class="line">                newp.y += dy[i] * test_size;</span><br><span class="line">                ld new_dis = <span class="built_in">dis_all</span>(newp);</span><br><span class="line">                <span class="keyword">if</span>(new_dis &lt; mid_dis)&#123;</span><br><span class="line">                    mid_dis = new_dis;</span><br><span class="line">                    cur = newp;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)test_size /= <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid_dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>換另外一種迭代方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;ld,ld&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pdd p[<span class="number">105</span>];<span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ld <span class="title">dis_all</span><span class="params">(pdd mid)</span></span>&#123;</span><br><span class="line">        ld sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ld x = p[i].x - mid.x,y = p[i].y - mid.y;</span><br><span class="line">            sum += <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinDistSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)p[i] = &#123;pos[i][<span class="number">0</span>],pos[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        pdd cur = p[<span class="number">0</span>];ld mid_dis = <span class="built_in">dis_all</span>(p[<span class="number">0</span>]);</span><br><span class="line">        ld test_size = <span class="number">150.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(test_size &gt; eps)&#123;</span><br><span class="line">            pdd newp = cur;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">rand</span>();</span><br><span class="line">            newp.x += <span class="built_in">cos</span>(temp) * test_size;</span><br><span class="line">            newp.y += <span class="built_in">sin</span>(temp) * test_size;</span><br><span class="line">            ld new_dis = <span class="built_in">dis_all</span>(newp);</span><br><span class="line">            <span class="keyword">if</span>(new_dis &lt; mid_dis)&#123;</span><br><span class="line">                mid_dis = new_dis;</span><br><span class="line">                cur = newp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> test_size *= <span class="number">0.99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid_dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1610-Maximum-Number-of-Visible-Points"><a href="#1610-Maximum-Number-of-Visible-Points" class="headerlink" title="1610 Maximum Number of Visible Points"></a>1610 Maximum Number of Visible Points</h3><p><a href="https://leetcode.com/problems/maximum-number-of-visible-points">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">visiblePoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> angle, vector&lt;<span class="keyword">int</span>&gt;&amp; loc)</span> </span>&#123;</span><br><span class="line">        vector&lt;ld&gt; ang;</span><br><span class="line">        <span class="keyword">int</span> overlap = <span class="number">0</span>,n = points.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : points)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>] == loc[<span class="number">0</span>] &amp;&amp; p[<span class="number">1</span>] == loc[<span class="number">1</span>])overlap++;</span><br><span class="line">            <span class="keyword">else</span> ang.<span class="built_in">push_back</span>(<span class="built_in">atan2l</span>(p[<span class="number">1</span>]-loc[<span class="number">1</span>],p[<span class="number">0</span>]-loc[<span class="number">0</span>]) * <span class="number">180</span> / (ld)M_PI);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sz = ang.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sz;i++)ang.<span class="built_in">push_back</span>(ang[i] + <span class="number">360</span>);</span><br><span class="line">        <span class="built_in">sort</span>(ang.<span class="built_in">begin</span>(),ang.<span class="built_in">end</span>());</span><br><span class="line">        sz = ang.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,it2 = <span class="number">0</span>;i &lt; sz;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(it2 &lt; sz &amp;&amp; ang[it2] - ang[i] &lt;= angle)it2++;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,it2 - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + overlap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1828-Queries-on-Number-of-Points-Inside-a-Circle"><a href="#1828-Queries-on-Number-of-Points-Inside-a-Circle" class="headerlink" title="1828 Queries on Number of Points Inside a Circle"></a>1828 Queries on Number of Points Inside a Circle</h3><p><a href="https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle">題目連結</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.<span class="built_in">size</span>(),m = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;ans.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> rx = queries[i][<span class="number">0</span>],ry = queries[i][<span class="number">1</span>],sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = points[j][<span class="number">0</span>] - rx,y = points[j][<span class="number">1</span>] - ry;</span><br><span class="line">                <span class="keyword">if</span>(x * x + y * y &lt;= queries[i][<span class="number">2</span>] * queries[i][<span class="number">2</span>])sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2101-Detonate-the-Maximum-Bombs"><a href="#2101-Detonate-the-Maximum-Bombs" class="headerlink" title="2101. Detonate the Maximum Bombs"></a>2101. Detonate the Maximum Bombs</h3><p><a href="https://leetcode.com/problems/detonate-the-maximum-bombs/">題目連結</a></p>
<p>把圖形考慮成一張圖，符合條件的就增加一條有向邊，接著對每一個點做一次DFS即可。時間 $O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; E[<span class="number">105</span>];</span><br><span class="line">    <span class="function">ld <span class="title">dis</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a.first - b.first,y = a.second - b.second;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">long</span>)x * x + (<span class="keyword">long</span> <span class="keyword">long</span>)y * y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : E[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">            sum++;vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumDetonation</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bomb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bomb.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                pii a = &#123;bomb[i][<span class="number">0</span>],bomb[i][<span class="number">1</span>]&#125;,b = &#123;bomb[j][<span class="number">0</span>],bomb[j][<span class="number">1</span>]&#125;;</span><br><span class="line">                <span class="keyword">int</span> r1 = bomb[i][<span class="number">2</span>],r2 = bomb[j][<span class="number">2</span>];</span><br><span class="line">                ld d = <span class="built_in">dis</span>(a,b);</span><br><span class="line">                <span class="keyword">if</span>(r1 &gt;= d)E[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">if</span>(r2 &gt;= d)E[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">fill</span>(vis,vis+<span class="number">105</span>,<span class="number">0</span>);</span><br><span class="line">            sum = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="延伸問題"><a href="#延伸問題" class="headerlink" title="延伸問題"></a>延伸問題</h2><ul>
<li>給定平面上N個點，問一條直線最多能穿越幾個點</li>
<li>線段相交座標</li>
<li>給你一個線段及一個圓，判斷圓跟線段的最短距離</li>
<li>給你一個三角形（其中一頂點為圓心）和圓形，求出兩者的交集面積</li>
<li>兩圓交點</li>
<li>圓跟多邊形交集面積</li>
<li>最小包覆圓</li>
<li>半平面交</li>
<li>Bentley–Ottmann Algorithm</li>
<li>Voronoi Diagram</li>
<li>Delaunay Triangulation</li>
</ul>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>計算幾何</category>
      </categories>
      <tags>
        <tag>計算幾何</tag>
      </tags>
  </entry>
  <entry>
    <title>萬有引力與四星運動之探討</title>
    <url>/gravity1/</url>
    <content><![CDATA[<p>此文將從萬有引力定律開始，在只考慮萬有引力的狀況下，探討衛星運動、雙星運動、三星運動、四星系統甚至是N體問題的軌跡與運動模式並進行模擬，並進行理論的驗證。</p>
<p>模擬連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/">點這裡</a></p>
<h2 id="理論與數學"><a href="#理論與數學" class="headerlink" title="理論與數學"></a>理論與數學</h2><h3 id="萬有引力定律"><a href="#萬有引力定律" class="headerlink" title="萬有引力定律"></a>萬有引力定律</h3><p>牛頓於1687年提出：「<strong>任何兩個質點之間必有一吸引力F，其量值和兩質量的乘積成正比，和它們之間的距離平方成反比，其方向在連心線上。</strong>」</p>
<p><img src="https://i.imgur.com/NsxdP20.png" alt=""></p>
<script type="math/tex; mode=display">F = \frac{GMm}{r^2}</script><span id="more"></span>
<h3 id="圓周運動公式"><a href="#圓周運動公式" class="headerlink" title="圓周運動公式"></a>圓周運動公式</h3><p>高中選修物理提到，一個質量為$m$的物體以半徑$R$繞著圓心旋轉，角速度為$\omega$，其速度$v$、加速度$a$與週期$T$有以下公式，在分析衛星運動及多體運動中會常常用到。在行星運動當中，就是以彼此間的萬有引力當作向心力，進行圓周運動。</p>
<p><img src="https://i.imgur.com/mDnymhI.png" alt=""></p>
<script type="math/tex; mode=display">\begin{align}\omega &= \frac{\Delta\theta}{\Delta t} = \frac{2\pi}{T}
\\v &= R\omega = \frac{2\pi R}{T}
\\a &= R\omega^2 =\frac{v^2}{R} =\frac{4\pi^2 R}{T^2}\end{align}</script><h3 id="橢圓性質"><a href="#橢圓性質" class="headerlink" title="橢圓性質"></a>橢圓性質</h3><p>一個橢圓具有兩個焦點分別是下圖的$F_1,F_2$，其定義就是橢圓上任一點$P$到兩焦點的距離和固定，也就是$\overline{PF_1}+\overline{PF_1} = K$，$K$為定值。下圖中，$a$為半長軸，$b$為半短軸，滿足 $a^2 = b^2+c^2$，面積為 $\pi ab$。我們定義了一個決定橢圓扁平程度偏心率 $e = \frac{c}{a}&lt;1$，偏心率愈大，橢圓愈扁平。</p>
<p><img src="https://i.imgur.com/EHX9hdW.png" alt=""></p>
<p>也可以說，圓就是一個橢圓的特例，當$F_1,F_2$重合在一點的時候就變成了一個正圓。同時，橢圓軌跡能用以下方程式說明（可用距離公式證明）：</p>
<script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2} = 1</script><p>平方相加容易聯想到三角函數的平方關係，因此我們可以假設 $x = a\cos\theta,y = b\sin\theta$，如此一來平方相加可得證。<br>由此可知，對於一個中心點為$(h,k)$的橢圓而言，其參數式為：</p>
<script type="math/tex; mode=display">\left\{\begin{aligned} x &= h+a\cos\theta
\\y &= k+b\cos\theta\end{aligned}\right.</script><script type="math/tex; mode=display">-\pi≤\theta≤\pi</script><h3 id="克普勒三大行星運動定律"><a href="#克普勒三大行星運動定律" class="headerlink" title="克普勒三大行星運動定律"></a>克普勒三大行星運動定律</h3><p>克普勒提出了行星三大運動定律，分別為：</p>
<ol>
<li><strong>軌道定律</strong>：所有行星各以太陽為焦點的橢圓形軌道上運動。</li>
<li><strong>面積定律</strong>：太陽與行星的連線在相同時間間隔內掃過相等的面積。</li>
<li><strong>週期定律</strong>：各行星繞行同一恆星，其公轉週期的平方與行星到太陽平均距離的三次方成正比。</li>
</ol>
<p>下面主要會用到的是第一和第二定律，以及公式 $r_Av_A = r_Bv_B$進行證明。</p>
<p><img src="https://i.imgur.com/c8iBRbi.png" alt=""></p>
<h3 id="力學能守恆定律"><a href="#力學能守恆定律" class="headerlink" title="力學能守恆定律"></a>力學能守恆定律</h3><p>一個質量為$m$的物體以速度$v$前進，與地心相距$r$，則該物體的動能與該處的重力位能為：</p>
<script type="math/tex; mode=display">\begin{align}E_k &= \frac{1}{2}mv^2\\U &= -\frac{GMm}{r}\end{align}</script><p>在系統只有保守力做功下，其力學能保持不變。在分析以半徑$r$的等速率圓周運動的過程中，其力學能可以表示為：</p>
<script type="math/tex; mode=display">E = U+E_k = \frac{-GMm}{r}+\frac{1}{2}m\frac{GM}{r} = \frac{-GMm}{2r}</script><p>由此我們可以得到：</p>
<script type="math/tex; mode=display">E_k = \frac{-1}{2}U</script><h2 id="行星與人造衛星運動"><a href="#行星與人造衛星運動" class="headerlink" title="行星與人造衛星運動"></a>行星與人造衛星運動</h2><h3 id="理論與數學-1"><a href="#理論與數學-1" class="headerlink" title="理論與數學"></a>理論與數學</h3><p>衛星質量$m$以軌道半徑$r$繞質量為$M$的行星行等速率圓周運動，其萬有引力恆指向$M$球心，作為圓周運動所需要的向心力。</p>
<script type="math/tex; mode=display">F = \frac{GMm}{r^2} = ma_c = m\frac{v^2}{r}</script><p>由此可知，當有一個物體質量$m$在距離行星$r$處行等速率圓周運動，其速度大小$v = \sqrt{\frac{GM}{r}}$，速度方向與向心力方向垂直。在模擬過程中，有兩個很重要的要素，分別是初始的速度大小、以及速度的方向，有了這兩個東西以後，就能讓電腦以彼此之間的萬有引力進行模擬。</p>
<h3 id="橢圓軌道與運動軌跡方程式"><a href="#橢圓軌道與運動軌跡方程式" class="headerlink" title="橢圓軌道與運動軌跡方程式"></a>橢圓軌道與運動軌跡方程式</h3><p>在實作的過程中，我發現到當速度 $v$ 比$\sqrt{\frac{GM}{r}}$大一點或小一點時，跑出來的軌跡就不會是正圓而是橢圓，讓我十分好奇能否在給定一個速度的情況下，計算出<strong>橢圓軌跡方程式</strong>。</p>
<p>下圖是初始狀態的設定，白球質量$M$、位置為原點、紅球質量$m$，紅球距離白球$H$、初始速度$v=k\sqrt{\frac{GM}{H}}$垂直向上，透過調整$k$的大小，預測其運動軌跡。顯然，當$k = 1$時軌跡會是正圓形，$k<1,k>1$則是分別以H為近日點、遠日點半徑的橢圓。</p>
<p><img src="https://i.imgur.com/3LG2sic.png" alt=""></p>
<p>若近日點距為$r_1$、遠日點距為$r_2$，半軸長$a = \frac{r_1+r_2}{2}$，根據遠日點以及近日點的力學能守恆以及克卜勒第二定律，可以列出以下兩式：</p>
<script type="math/tex; mode=display">\begin{aligned}\frac{1}{2}mv_1^2 - \frac{GMm}{r_1} &= \frac{1}{2}mv_2^2 - \frac{GMm}{r_2}\\\\
\frac{\pi ab}{T} = r_1v_1 &= r_2v_2\end{aligned}</script><p>將二式帶入一式可得：</p>
<script type="math/tex; mode=display">(r_1v_1)^2 = \frac{GMr_1r_2}{\frac{1}{2}(r_1+r_2)} =
\frac{GM(a+c)(a-c)}{a} = \frac{GMb^2}{a}</script><p>帶入我們的初始速度與近、遠日點距：</p>
<script type="math/tex; mode=display">(H\cdot k\sqrt{\frac{GM}{H}})^2 = k^2GMH=\frac{GMb^2}{a}</script><p>上面是第一式，還有兩條比較顯而易見的兩條方程式，總共用三條方程式解三個未知數：</p>
<script type="math/tex; mode=display">\left\{\begin{aligned} \frac{b^2}{a} &= k^2H
\\a^2 &= b^2+c^2
\\a &= H-c\end{aligned}\right.</script><p>將三式帶入二式消去$c$，得到：</p>
<script type="math/tex; mode=display">\left\{\begin{aligned} a &= \frac{H}{2-k^2}
\\b &= \sqrt{aHk^2}\end{aligned}\right.</script><p>有了$a,b$之後，就可以回推週期：</p>
<script type="math/tex; mode=display">\begin{aligned}\frac{\pi ab}{T} &= \frac{1}{2}r_1v_1
\\\\\Longrightarrow \ T &= \frac{2\pi ab}{r_1v_1}\end{aligned}</script><p>最後，就可以用橢圓參數式畫出軌跡，並且完全吻合紅球的運動軌跡！</p>
<h3 id="程式實作"><a href="#程式實作" class="headerlink" title="程式實作"></a>程式實作</h3><p>程式連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/program/%E8%A1%8C%E6%98%9F%E9%81%8B%E5%8B%95%EF%BC%BF%E6%A9%A2%E5%9C%93%E8%BB%8C%E9%81%93">點這裡</a></p>
<p>分別將$k$帶入不同數值，觀察軌跡的變化。左邊為模擬的狀況，右邊則是紅球動能（黑線）、位能（綠線）以及力學能（紅線）大小，由於只有保守力做功，其力學能總和保持不變。初始狀態如下：$M = 10,m = 1,H = 5$。</p>
<h4 id="K-0-6代入"><a href="#K-0-6代入" class="headerlink" title="K = 0.6代入"></a>K = 0.6代入</h4><p><img src="https://i.imgur.com/8M7jZIW.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
a &= 3.0488
\\b &= 2.3426
\\c &= 1.9512\
\\T &= 4.0955\end{aligned}\right.</script><h4 id="K-1代入"><a href="#K-1代入" class="headerlink" title="K = 1代入"></a>K = 1代入</h4><p><img src="https://i.imgur.com/vyLsudD.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
a &= 5.0000
\\b &= 5.0000
\\c &= 0.0000
\\T &= 8.6015\end{aligned}\right.</script><h4 id="K-1-3代入"><a href="#K-1-3代入" class="headerlink" title="K = 1.3代入"></a>K = 1.3代入</h4><p><img src="https://i.imgur.com/dIZdlCU.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
a &= 16.1290
\\b &= 11.6743
\\c &= 11.1290
\\T &= 49.8344\end{aligned}\right.</script><h4 id="K-2代入"><a href="#K-2代入" class="headerlink" title="K = 2代入"></a>K = 2代入</h4><p><img src="https://i.imgur.com/6RO0Svz.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
a &= -2.5000
\\b &= nan
\\c &= nan
\\T &= nan\end{aligned}\right.</script><p>這種情況是紅球脫離了黑球的重力束縛，一去不復返。可以看到，動能與位能呈現對稱縮小的狀況，動能逐漸趨近於總力學能，而重力位能逐漸趨近於零。</p>
<p>這裡發生了一個有趣的現象，當我把$k$繼續調小到足夠小，紅球會繞行一個非常扁平的橢圓軌跡，在現實世界中也就是紅球撞上白球的感覺。</p>
<p>反之，當我把$k$繼續往上調大時，會發現紅球脫離了白球的重力場而一去不復返，我試著找出這個臨界值，從我們上面的推導可知$a = H/(2-k^2),b = \sqrt{aHk^2}$，當$k&gt;\sqrt{2}$時，$b$無解，也就代表這樣的橢圓形軌跡是不存在的。換句話說，當$v&gt;\sqrt 2\cdot\sqrt{\frac{GM}{H}}$時，紅球會擺脫白球重力的影響，也就是<strong>第二宇宙速度</strong>或<strong>脫離速度</strong>。</p>
<p>由此可知，$|k|&lt;\sqrt 2$。</p>
<div class="note success">
            <p><strong>第二宇宙速度</strong>或<strong>脫離速度</strong>是指在地球上發射的物體擺脫地球重力束縛，飛離地球所需的最小初始速度。假設質量$m$的物體速度為$v$，則如果要擺脫地球重力的束縛，其動能要大於其重力位能，取最小值就是兩者相等，因此：</p><script type="math/tex; mode=display">\frac{1}{2}mv^2 =\frac{GMm}{r}</script><p>得到脫離速度：</p><script type="math/tex; mode=display">v = \sqrt{\frac{2GM}{r}}</script>
          </div>
<p>很巧的是，我們可以從橢圓半短軸長的無解推出脫離速度，也能從力學能的方向角度切入，得到一樣的結果，可謂殊途同歸！</p>
<h2 id="雙星運動"><a href="#雙星運動" class="headerlink" title="雙星運動"></a>雙星運動</h2><p>觀察兩個質量分別為$m1,m2$的物體，繞著彼此的質心進行週期運動。</p>
<p><img src="https://i.imgur.com/qpkSshS.png" alt=""></p>
<h3 id="理論與數學-2"><a href="#理論與數學-2" class="headerlink" title="理論與數學"></a>理論與數學</h3><p>令兩物體彼此間距離為$d$，則有以下的數學關係式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><script type="math/tex">m_1</script></th>
<th style="text-align:center"><script type="math/tex">m_2</script></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">軌道半徑</td>
<td style="text-align:center"><script type="math/tex">r_1 = \frac{m_2}{m_1+m_2}\cdot d</script></td>
<td style="text-align:center"><script type="math/tex">r_2 = \frac{m_1}{m_1+m_2}\cdot d</script></td>
</tr>
<tr>
<td style="text-align:center">向心加速度</td>
<td style="text-align:center"><script type="math/tex">a_1 = \frac{Gm_2}{d^2}</script></td>
<td style="text-align:center"><script type="math/tex">a_2 = \frac{Gm_1}{d^2}</script></td>
</tr>
<tr>
<td style="text-align:center">軌道速率</td>
<td style="text-align:center"><script type="math/tex">v_1 = m_2\sqrt{\frac{G}{d(m_1+m_2)}}</script></td>
<td style="text-align:center"><script type="math/tex">v_2 = m_1\sqrt{\frac{G}{d(m_1+m_2)}}</script></td>
</tr>
</tbody>
</table>
</div>
<h3 id="模擬實作"><a href="#模擬實作" class="headerlink" title="模擬實作"></a>模擬實作</h3><p>模擬連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/program/%E7%90%86%E6%83%B3%E9%9B%99%E6%98%9F%EF%BC%BF%E5%90%8C%E5%BF%83%E5%9C%93%E8%BB%8C%E9%81%93">點這裡</a></p>
<h4 id="正圓雙星運動"><a href="#正圓雙星運動" class="headerlink" title="正圓雙星運動"></a>正圓雙星運動</h4><p>正圓形的軌道中，軌道半徑與其質量呈反比。</p>
<p><img src="https://i.imgur.com/48i6Oel.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
m1 &= 3.0000\\
m2 &= 1.0000\\
v1 &= 0.7455\\
v2 &= 2.2366\\\end{aligned}\right.</script><h4 id="橢圓雙星運動（質量不同）"><a href="#橢圓雙星運動（質量不同）" class="headerlink" title="橢圓雙星運動（質量不同）"></a>橢圓雙星運動（質量不同）</h4><p>橢圓形的軌道中，軌道半徑也會與其質量呈反比（此軌道半徑可以定義為半軸長，由微積分可得證）。</p>
<p><img src="https://i.imgur.com/qcVlBQD.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
m1 &= 3.0000\\
m2 &= 1.0000\\
v1 &= 0.3728\\
v2 &= 1.1183\\\end{aligned}\right.</script><h4 id="橢圓雙星運動（質量相同）"><a href="#橢圓雙星運動（質量相同）" class="headerlink" title="橢圓雙星運動（質量相同）"></a>橢圓雙星運動（質量相同）</h4><p><img src="https://i.imgur.com/6G4Djws.png" alt=""></p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
m1 &= 1.0000\\
m2 &= 1.0000\\
v1 &= 0.5272\\
v2 &= 0.5272\\\end{aligned}\right.</script><h2 id="三星運動"><a href="#三星運動" class="headerlink" title="三星運動"></a>三星運動</h2><p>再研究天體力學上，<strong>雙星問題</strong>（Two-Body Problem）是已經被證明有精確解，但對於<strong>三體問題</strong>（Three-body problem）甚至是<strong>多體問題</strong>（N-body problem）問題就變得特別複雜，除特別案例以外，並沒有辦法能精確描述各物體運動的行為。儘管如此，此系統還是會遵守動量守恆，其質心不會移動。</p>
<p>三星問題困難的地方在於，往往初始非常微小的誤差，就有可能造成之後完全不同的結果，變得混亂而不可預測，也就是<a href="https://en.wikipedia.org/wiki/Chaos_theory">混沌狀態</a>。</p>
<h3 id="理論與數學-3"><a href="#理論與數學-3" class="headerlink" title="理論與數學"></a>理論與數學</h3><p>由於三體問題過於複雜，我們簡化成將三個物體的質量都設為$m$，放在邊長為$L$的正三角形三個頂點上，與質心距離$r = \frac{\sqrt3}{3}L$，則彼此間的萬有引力取餘弦將作為繞質心旋轉所需要的向心力：</p>
<script type="math/tex; mode=display">\sqrt 3\frac{Gm^2}{L^2} = ma_c = m\frac{v^2}{r} = m\frac{4\pi^2r}{T}</script><p>可得到以下：</p>
<script type="math/tex; mode=display">\left\{\begin{aligned}
v &= \sqrt{\frac{Gm}{L}}\\
T &= 2\pi\sqrt{\frac{L^3}{G(3m)}}
\end{aligned}\right.</script><h3 id="正圓軌跡三星運動模擬"><a href="#正圓軌跡三星運動模擬" class="headerlink" title="正圓軌跡三星運動模擬"></a>正圓軌跡三星運動模擬</h3><p>模擬連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/program/%E7%90%86%E6%83%B3%E4%B8%89%E6%98%9F%EF%BC%BF%E6%AD%A3%E5%9C%93%E8%BB%8C%E9%81%93">點這裡</a></p>
<p>正三角形的三個頂點以相對位置固定、共同質心為旋轉中心進行旋轉。透過彼此的萬有引力餘弦結果當作向心力，設定好初始速度大小與方向（分別在90度、210度、300度），就能讓電腦完成剩下的工作！</p>
<p><img src="https://i.imgur.com/fltbWQf.png" alt=""></p>
<h3 id="橢圓軌跡三星運動模擬"><a href="#橢圓軌跡三星運動模擬" class="headerlink" title="橢圓軌跡三星運動模擬"></a>橢圓軌跡三星運動模擬</h3><p>模擬連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/program/%E4%B8%89%E6%98%9F%E9%81%8B%E5%8B%95%EF%BC%BF%E6%A9%A2%E5%9C%93%E8%BB%8C%E9%81%93">點這裡</a><br>影片連結：<a href="https://youtu.be/fJpKcJ9cGFI">點這裡</a></p>
<p>此為不穩定的模擬，也就是說在一段時間過後，整個系統會失序，呈現混亂的狀態。</p>
<p><img src="https://i.imgur.com/bOGPPVW.png" alt=""></p>
<h3 id="其他軌跡的三星運動"><a href="#其他軌跡的三星運動" class="headerlink" title="其他軌跡的三星運動"></a>其他軌跡的三星運動</h3><p>其他三體互繞的軌跡如八字型，就被證明出來是一個穩定的運動模式。</p>
<p><img src="https://i.imgur.com/33rrTPs.gif" alt=""></p>
<p>以及衛星的五個拉格朗日點，可以在下圖五個位置放入第三個不考慮其質量的物體，使其與其他星體的相對位置不變。</p>
<p><img src="https://i.imgur.com/kQhIG3Q.png" alt=""></p>
<h2 id="四星運動"><a href="#四星運動" class="headerlink" title="四星運動"></a>四星運動</h2><p>在一堂物理課，老師教到三星系統時，順便提及了四星運動應該以什麼樣的性狀、什麼方式運動。若要保持四個物體等距，唯一的方式就是把他們放在正四面體上的四個頂點上，以正四面體之外心為旋轉中心進行旋轉</p>
<h3 id="理論與數學-4"><a href="#理論與數學-4" class="headerlink" title="理論與數學"></a>理論與數學</h3><p>假設四個質量均為$m$的物體，分別落在正四面體的四個頂點上，若以正六面體思考正四面體，正四個頂點分別是$(0,0,0),(1,1,0),(1,0,1),(0,1,1)$</p>
<p><img src="https://i.imgur.com/xpaRkjF.png" alt=""></p>
<p>如下圖，假設$A,B,C,D$上均有一個質量為$m$的物體，我們針對$B$分析其受力狀況（其他點其實是一樣的）。可以看到，$B$受到了分別指向$A,B,D$三點、大小為$\frac{Gm^2}{L^2}$的力，將這些力在指向質心$M$方向做分力。</p>
<p><img src="https://i.imgur.com/NpWDJas.png" alt=""></p>
<ol>
<li><strong>水平方向（ABC平面）</strong>：</li>
</ol>
<script type="math/tex; mode=display">2\times\frac{Gm^2}{L^2}\cdot\cos30^{\circ}+\frac{Gm^2}{L^2}\cdot\cos\theta</script><ol>
<li><strong>垂直方向：</strong></li>
</ol>
<script type="math/tex; mode=display">\frac{Gm^2}{L^2}\cdot\sin\theta</script><p>分析正四邊形的長度性質，由於四面體高度是$h = \frac{\sqrt6}{3}$、正三角形外接圓$\frac{\sqrt3}{3}$，我們可以得到$\sin\theta = \frac{\sqrt3}{3},\cos\theta = \frac{\sqrt 6}{3}$，代入上式可得並做畢氏定理可得：</p>
<script type="math/tex; mode=display">\begin{align}F_B &= \frac{Gm^2}{L^2}\sqrt{(\sqrt3+\frac{\sqrt3}{3})^2 + (\frac{\sqrt6}{3})^2}\\
&=\sqrt6\cdot\frac{Gm^2}{L^2}\end{align}</script><p>正四面體的外接圓半徑$R = \frac{\sqrt6}{4}L$，因此可得：</p>
<script type="math/tex; mode=display">\frac{mv^2}{R} = \sqrt6\cdot\frac{Gm^2}{L^2}</script><p>最後得到軌道速度與旋轉週期：</p>
<script type="math/tex; mode=display">\begin{align}v &= \sqrt{\frac{3Gm}{2L}}\\
T &= 2\pi\sqrt{\frac{L^3}{G\cdot(4m)}}
\end{align}</script><h3 id="程式實作-1"><a href="#程式實作-1" class="headerlink" title="程式實作"></a>程式實作</h3><p>模擬連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/program/%E5%9B%9B%E6%98%9F%E9%81%8B%E5%8B%95">點這裡</a><br>影片連結：<a href="https://youtu.be/fNabqv4BYKg">點這裡</a></p>
<p>有了速度大小以後，接下來就是初始速度方向的設定。這一部分特別困難，以正四面體的四星在立體空間的運動，旋轉的角度若沒有抓好，很有可能整個結構會崩塌。例如下圖情況，前後兩個物體會因為萬有引力作用而不斷吸引：</p>
<p><img src="https://i.imgur.com/oSjvetd.png" alt=""></p>
<p>嘗試解決的方法是，將正四面體的四個頂點座標投影到$xy$平面，因為四個頂點是$z$座標極大或極小，如此一來就能讓所有速度方向的$z$分量為零。接著，只要將速度方向依照下圖分解即可：</p>
<p><img src="https://i.imgur.com/2xo2a8N.png" alt=""></p>
<p>可以看到下圖左方有兩張圖，上圖是四顆球的總動能、位能與力學能的圖、下圖是黃球與其他球的距離（黑線是與質心距離）。在理想的狀況下，我們預期所有球的相對位置應該保持不變，但在模擬中卻是呈現週期性的變化，並且可以觀察球與質心的距離並不是固定的，而是有上下起伏的變化。</p>
<p><img src="https://i.imgur.com/xAtoSH5.png" alt=""></p>
<p>轉了差不多十圈後，會發現四星系統呈現混沌狀態，分析原因可能有以下兩個：</p>
<ol>
<li><strong>精度問題</strong>：初始狀態速度方向向量精度不足，初始的些許差別導致後續的混亂。</li>
<li><strong>模擬本身限制</strong>：我們採用的是對時間微分進行每一個瞬間的力學分析，時間間隔大小也會影響到整個模擬的結果。</li>
</ol>
<p><img src="https://i.imgur.com/hHWFWIf.png" alt=""></p>
<p>這也讓我們思考一個蠻有趣問題，是否真的存在一個穩定的四星系統彼此能在相對位置固定的狀況下進行運動？</p>
<h2 id="N體問題運動模擬"><a href="#N體問題運動模擬" class="headerlink" title="N體問題運動模擬"></a>N體問題運動模擬</h2><p>模擬連結：<a href="https://glowscript.org/#/user/ck1090758/folder/N-BodyProblem/program/N%E9%AB%94%E5%95%8F%E9%A1%8C">點這裡</a></p>
<p>最後就是N體問題的模擬，將50個質量為$m$的物體在隨機生成的位置上，彼此受到萬有引力運動。右圖的黑線為50個物體的總動能、綠線為彼此的位能，紅線為兩者相加，也就是總力學能。在沒有外力作用的狀況下，能由右圖看出來力學能是守恆的！</p>
<p><img src="https://i.imgur.com/dVP3ywW.png" alt=""></p>
<h2 id="總結與延伸問題"><a href="#總結與延伸問題" class="headerlink" title="總結與延伸問題"></a>總結與延伸問題</h2><p>從萬有引力的理論與數學出發，整理行星的運動軌跡、雙星、三星、四星甚至到N星的運動模式以及模擬，讓我們能從不一樣的角度切入物理問題。這邊還有一個十分有趣的問題尚未解決，也就是<strong>是否存在一個穩定的四星系統</strong>？在大部分的N體問體的情況中，都沒有辦法得到一個穩定的運動模式，總會因為起始狀態的小小誤差導致截然不同的結果，穩定的四星系統也就變成蠻難解決的問題。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Two-body_problem">Wiki:Two-body problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Three-body_problem">Wiki:Three-body problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/N-body_problem">Wiki:N-body problem</a></li>
<li><a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=47998">科學online：力學能(Mechanical energy)
</a></li>
<li>物理講義：第八、九章</li>
</ul>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>數學</tag>
        <tag>物理筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>線段樹例題（Segment Tree）</title>
    <url>/seg2/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>NEOJ 80 RMQ練習</li>
<li>NEOJ 249 最大連續和？</li>
<li>ZJ d799 區間求和</li>
<li>NEOJ 367 RMQ˙改</li>
<li>TIOJ 1224 矩形覆蓋面積計算<span id="more"></span>
</li>
</ul>
<h3 id="RMQ練習"><a href="#RMQ練習" class="headerlink" title="RMQ練習"></a>RMQ練習</h3><p><a href="https://neoj.sprout.tw/problem/80/">題目連結</a><br>RMQ = Range minimun query，也就是詢問一個區間的最小值。分析一下兩種不同作法的複雜度：<br><div class="note default">
            <p>對於數列 $a_n$ 共n項，k筆詢問，每一次詢問區間$[l,r]$的最大、最小值</p><p><strong>1. 暴力做</strong><br>時間複雜度：<font color="#f00">詢問$O(n)$</font><br>對於每一筆詢問都暴力搜索，最多掃過n個數字，時間複雜度$O(kn)$，對於數字大一點的情況就會TLE<br><br></p><p><strong>2. 分塊算法</strong><br>可以參見 <a href="https://hackmd.io/@peienwu/rkCDKEcjd">這篇文章</a></p><p><strong>3. 線段樹</strong><br>時間複雜度：<font color="#f00">預處理 $O(n)$、詢問$O(logn)$</font><br>首先是預處理建立線段樹，線段樹上約有$2n$個節點，因此空間複雜度是$O(n)$，也就表示預處理是$O(n)$，之後便可$O(logn)$查詢每一筆詢問。以下是各種操作複雜度：</p><ul><li><strong>初始建構</strong>：所有節點恰會建構一次，每個節點 $O(1)$，配合節點樹可得為 $O(𝑛)$</li><li><strong>單點修改</strong>：該點的所有祖先節點都會被修改到，其他都不會被修改到，$𝑂(logn)$</li><li><strong>區間查詢</strong>：每筆詢問最多詢問到深度為 $O(logn)$ 的節點。在一次詢問中，每一層不會有超過2個節點被詢問，總複雜度為$𝑂(log𝑛)$<br><br></li></ul><p><strong>4. 稀疏表(Sparse Table)</strong><br>時間複雜度：<font color="#f00">預處理 $O(nlogn)$、詢問$O(1)$</font><br>參考 <a href="https://hackmd.io/@peienwu/H1W1Y18Gt">這篇文章</a></p>
          </div></p>
<p>這一題就是基礎的要有支援區間查詢、單點修改的線段樹，也是最簡單的一種！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> seg[<span class="number">4</span> * N],arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;</span><br><span class="line">        seg[cur] = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur] = <span class="built_in">min</span>(seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//單點修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ind,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span> &amp;&amp; l==ind)&#123;</span><br><span class="line">        seg[cur]=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind&lt;mid)<span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ind,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ind,val);</span><br><span class="line">    seg[cur] = <span class="built_in">min</span>(seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr),<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x+<span class="number">1</span>,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">2</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大連續和？"><a href="#最大連續和？" class="headerlink" title="最大連續和？"></a>最大連續和？</h3><p><a href="https://neoj.sprout.tw/problem/249/">題目連結</a><br>這題題結果我是WA在INF太大可能會溢位的問題，把INF調整成 $5\times 10^{14}$ 是差不多的</p>
<p>這一題要維護區間最大連續和，跟dp的最大連續和差了「區間」兩字，整個實作的方式跟複雜度就不一樣了。DP的作法如果直接套用在這一題的話，複雜度約為：$O(QN)$，絕對會炸裂，因此只能用線段樹維護這個東西。</p>
<div class="note primary">
            <p><strong>區間最大連續和</strong><br>在分治法的單元有提到分治法最重要的是假定左右兩側（對應過來就是兩子樹）是維護好的，也就是符合定義，要想的是要如何處理橫跨左右子樹的情況。<br>要如何知道橫跨中間的最大值呢？這時候我們可以維護4個數值，來更新每一個線段樹上的節點的數值。</p><ol><li><strong>總和(sum)</strong><br>$cur.sum = left.sum+right.sum$</li><li><strong>最大前綴和(lmax)</strong><br>$cur.lmax = max(left.lmax,left.sum+right.lmax)$</li><li><strong>最大後綴和(rmax)</strong><br>$cur.rmax = max(right.rmax,right.sum+left.rmax)$</li><li><strong>區間最大連續和(tmax)</strong><br>$cur.tmax = max(left.tmax,right.tmax,left.rmax+right.lmax)$</li></ol>
          </div>
<p>維護最大後綴跟最大前綴和（首跟末有被取到的情況），就可以$O(1)$ 維護每一個節點的區間最大連續和，複雜度：詢問$O(logn)$，因此總時間$O(Qlogn)$就可以AC了!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 500000000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;    <span class="comment">//區間總和</span></span><br><span class="line">    <span class="keyword">int</span> lmax;   <span class="comment">//最大前綴和</span></span><br><span class="line">    <span class="keyword">int</span> rmax;   <span class="comment">//最大後綴和</span></span><br><span class="line">    <span class="keyword">int</span> tmax;   <span class="comment">//區間連續最大和</span></span><br><span class="line">&#125;seg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//求當下的區間連續最大和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node &amp;cur,Node &amp;left,Node &amp;right)</span></span>&#123;</span><br><span class="line">    cur.sum = left.sum+right.sum;</span><br><span class="line">    cur.lmax = <span class="built_in">max</span>(left.lmax,left.sum+right.lmax);</span><br><span class="line">    cur.rmax = <span class="built_in">max</span>(right.rmax,right.sum+left.rmax);</span><br><span class="line">    cur.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(left.tmax,right.tmax),left.rmax+right.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立線段樹：[l,r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;</span><br><span class="line">        seg[cur] = &#123;arr[l],arr[l],arr[l],arr[l]&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(mid,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">modify</span>(seg[cur],seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問：[l,r)</span></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> &#123;-INF,-INF,-INF,-INF&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">2</span>*cur,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">query</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">    Node temp;</span><br><span class="line">    <span class="built_in">modify</span>(temp,left,right);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,l,r+<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(ans.tmax,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="d799區間求和"><a href="#d799區間求和" class="headerlink" title="d799區間求和"></a>d799區間求和</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d799">題目連結</a><br>這一題要求兩個操作，區間加值跟區間查詢，這時候就必須用到<strong>懶標(lazy tags)</strong> 輔助求和。</p>
<blockquote>
<p>範例測資：<br>10<br>1 2 3 4 5 6 7 8 9 10<br>3<br>2 2 4<br>1 3 6 3<br>2 2 4</p>
</blockquote>
<p><img src="https://i.imgur.com/MJMDQE9.jpg" alt=""><br>左邊是整棵線段樹，右邊則是懶標，可以看到3要往下推，但學長的程式碼中並沒有執行這個步驟，這樣會導致query的時候發生錯誤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>            <span class="comment">//線段樹每一個節點</span></span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>,tag=<span class="number">0</span>,sz; <span class="comment">//val原本的值、tag懶標、sz區間大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rv</span><span class="params">()</span></span>&#123;           <span class="comment">//回傳實際節點的值</span></span><br><span class="line">        <span class="keyword">return</span> val+tag*sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;    <span class="comment">//建立線段樹</span></span><br><span class="line">    seg[cur].sz = r-l;              <span class="comment">//更新節點的大小</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;                 <span class="comment">//空區間回傳</span></span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;                     <span class="comment">//設定當前節點的值</span></span><br><span class="line">        seg[cur].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;                <span class="comment">//分別遞迴建立左右子樹</span></span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].val+seg[<span class="number">2</span>*cur+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把id的懶標在query的時候往下推</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    seg[<span class="number">2</span>*id].tag += seg[id].tag;   <span class="comment">//左子樹懶標更新</span></span><br><span class="line">    seg[<span class="number">2</span>*id+<span class="number">1</span>].tag += seg[id].tag; <span class="comment">//右子樹懶標更新</span></span><br><span class="line">    seg[id].val = seg[id].<span class="built_in">rv</span>();     <span class="comment">//更新實際值</span></span><br><span class="line">    seg[id].tag = <span class="number">0</span>;                <span class="comment">//往下推完之後設定為預設</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=l||ql&gt;=r||qr&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;</span><br><span class="line">        seg[cur].tag += val;               <span class="comment">//將被完整包含的區間的懶標加上修改值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ql,qr,val);          <span class="comment">//修改左右子樹</span></span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);        <span class="comment">//遞迴完拉上來的過程中把上面的數值更新成有懶標</span></span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].<span class="built_in">rv</span>()+seg[<span class="number">2</span>*cur+<span class="number">1</span>].<span class="built_in">rv</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">//空集合直接回傳</span></span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur].<span class="built_in">rv</span>();     <span class="comment">//包含在要詢問的範圍中，回傳實際值</span></span><br><span class="line">    <span class="built_in">push</span>(cur);                                  <span class="comment">//將懶標在遞迴下去的過程中下推</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;                          <span class="comment">//遞迴查詢左右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr)+<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RMQ˙改"><a href="#RMQ˙改" class="headerlink" title="RMQ˙改"></a>RMQ˙改</h3><p><a href="https://neoj.sprout.tw/problem/367/">題目連結</a><br>這一題是Range Maximum Query搭配區間加值，如果直接套用前面RMQ或是區間和的模板就輕鬆許多。這一題主要跟前面題目的不同在於它的sz要維護成1，有別於求區間和要乘上區間大小，每一個值不需要乘上區間大小，因此設成0。</p>
<p>這題第二筆測資明顯就是要卡暴力解法。<br><img src="https://i.imgur.com/tC2Wucw.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e14</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>            <span class="comment">//線段樹每一個節點</span></span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>,tag=<span class="number">0</span>,sz=<span class="number">0</span>; <span class="comment">//val原本的值、tag懶標、sz區間大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rv</span><span class="params">()</span></span>&#123;           <span class="comment">//回傳實際節點的值</span></span><br><span class="line">        <span class="keyword">return</span> val+tag*sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;    <span class="comment">//建立線段樹</span></span><br><span class="line">    seg[cur].sz = <span class="number">1</span>;                <span class="comment">//更新節點的大小</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;                 <span class="comment">//空區間回傳</span></span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;                     <span class="comment">//設定當前節點的值</span></span><br><span class="line">        seg[cur].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;                <span class="comment">//分別遞迴建立左右子樹</span></span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur].val = <span class="built_in">max</span>(seg[<span class="number">2</span>*cur].val,seg[<span class="number">2</span>*cur+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把id的懶標在query的時候往下推</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    seg[<span class="number">2</span>*id].tag += seg[id].tag;   <span class="comment">//左子樹懶標更新</span></span><br><span class="line">    seg[<span class="number">2</span>*id+<span class="number">1</span>].tag += seg[id].tag; <span class="comment">//右子樹懶標更新</span></span><br><span class="line">    seg[id].val = seg[id].<span class="built_in">rv</span>();     <span class="comment">//更新實際值</span></span><br><span class="line">    seg[id].tag = <span class="number">0</span>;                <span class="comment">//往下推完之後設定為預設</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=l||ql&gt;=r||qr&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;</span><br><span class="line">        seg[cur].tag += val;               <span class="comment">//將被完整包含的區間的懶標加上修改值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ql,qr,val);          <span class="comment">//修改左右子樹</span></span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);        <span class="comment">//遞迴完拉上來的過程中把上面的數值更新成有懶標</span></span><br><span class="line">    seg[cur].val = <span class="built_in">max</span>(seg[<span class="number">2</span>*cur].<span class="built_in">rv</span>(),seg[<span class="number">2</span>*cur+<span class="number">1</span>].<span class="built_in">rv</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> -INF;      <span class="comment">//空集合直接回傳</span></span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur].<span class="built_in">rv</span>();     <span class="comment">//包含在要詢問的範圍中，回傳實際值</span></span><br><span class="line">    <span class="built_in">push</span>(cur);                                  <span class="comment">//將懶標在遞迴下去的過程中下推</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;                          <span class="comment">//遞迴查詢左右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr),<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1224-矩形覆蓋面積計算"><a href="#1224-矩形覆蓋面積計算" class="headerlink" title="1224 . 矩形覆蓋面積計算"></a>1224 . 矩形覆蓋面積計算</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1224">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/261541">Submission2:AC</a></p>
<blockquote>
<p>題意：給你平面上n個矩形，請求出它們覆蓋的總表面積。</p>
</blockquote>
<p>這一題所使用的技巧是<font color="#f00">掃描線</font>以及<font color="#f00">線段樹</font>，下圖中的水平藍色線即為掃描線，由y=0開始往上掃描，當遇到了矩形的邊，利用線段樹查詢區間內當前的矩形寬度，乘上兩掃描線的高度差即為面積。當然，掃描線也可以使用垂直方向的線段由左而右的掃描，實作細節是一樣的。</p>
<p><img src="https://i.imgur.com/pAsHmXd.jpg" alt=""></p>
<h4 id="線段樹維護"><a href="#線段樹維護" class="headerlink" title="線段樹維護"></a>線段樹維護</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>我們可以定義線段樹$seg[cur]$為區間$[l,r]$中有被<strong>矩形覆蓋的大小</strong>有多大，也就是圖中當前掃描線對應到的區域的寬度。這樣子維護有一個問題，當我們直接用$seg[cur]$儲存答案，我們在修改的時候沒有辦法確切知道這段區間被覆蓋的情況。</p>
<p>下圖為一種模擬的情況，每一個區間的數字代表著非0的數字個數，也就是它的寬度。今天我們要對區間$[4,6]$加減值，將區間拆成$[4,4]$跟$[5,6]$，這時候區間$[3,4]$的數值是1，我們卻不知道到底是3還是4是有被覆蓋到的，必須要遞迴下去到葉節點才能得到完整的覆蓋情況，這時候每一次加減值的複雜就會提升到$O(n)$，因此不能以這種方式維護。</p>
<p><img src="https://i.imgur.com/DOeuFyx.png" alt=""></p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>有別於第一種方法對$seg[id]$進行維護，我們可以多開一個區間 $tag$ 來紀錄被矩形覆蓋的情況。下圖有3個矩形，其中的數字代表每一塊區域被覆蓋的情況，這邊使用了$tag$來紀錄（他是附在區間上的，不會像圖中一樣的方式呈現）。tag的數值為非負整數，紀錄當前區間有多少矩形覆蓋在上面，用$tag$來輔助維護$seg[id]$可以在$O(logn)$的時間進行修改與查詢。</p>
<p><img src="https://i.imgur.com/xGuEmB4.jpg" alt=""></p>
<p>以下程式碼是是 $tag$ 的轉移，當大的區間的tag值不為0，代表有一個矩形曾完整覆蓋這個區間，這時候可以直接回傳區間大小，否則即回傳左右節點的$sed[left],seg[right]$的數值。</p>
<p>這邊定義$seg[id]$為：「考慮 id 的子孫們（不含 id 本身）的所有 tag 值，假設這些子孫只有被tag值作用過，共有多少非0的數字」。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">seg[cur].val = (seg[<span class="number">2</span>*cur].tag?mid-l:seg[<span class="number">2</span>*cur].val)</span><br><span class="line">              +(seg[<span class="number">2</span>*cur+<span class="number">1</span>].tag?r-mid:seg[<span class="number">2</span>*cur+<span class="number">1</span>].val);</span><br></pre></td></tr></table></figure>
<h4 id="實作方法"><a href="#實作方法" class="headerlink" title="實作方法"></a>實作方法</h4><h5 id="矩形維護"><a href="#矩形維護" class="headerlink" title="矩形維護"></a>矩形維護</h5><p>首先是維護矩形的方法。我們一個矩形總共要維護四個東西：矩形左界x1、矩形右界x2、矩形上下界的y座標（分上下兩條），這兩條邊是下界或是上界val。為什麼要水平方向要分兩條討論？是因為下界代表進入，當掃描線掃到這一條邊的時候表示我們要新增區間 $[x1,x2)$ 進入線段樹；反之如果掃到了上界，則表示離開這個矩形，在線段樹中扣掉區間 $[x1,x2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>    <span class="comment">//每一個矩陣分成上下兩條邊</span></span><br><span class="line">    <span class="keyword">int</span> x1;     <span class="comment">//矩形左界x1</span></span><br><span class="line">    <span class="keyword">int</span> x2;     <span class="comment">//矩形右界x2</span></span><br><span class="line">    <span class="keyword">int</span> y;      <span class="comment">//矩形y座標（分上下兩邊）</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//val = ±1(進入代表1、離開代表-1)</span></span><br><span class="line">    </span><br><span class="line">&#125;arr[<span class="number">2</span>*N];</span><br></pre></td></tr></table></figure>
<p>上下界我們利用val維護，當 $val=1$ 時表示是矩形的下界； $val=-1$ 則是矩形上界，這兩個搭配在一起剛好就可以用線段樹區間加值的方式進行操作！總共有 $n$ 個矩形，因此我們要掃描線總共掃描 $2n$ 條線段。</p>
<h5 id="線段樹"><a href="#線段樹" class="headerlink" title="線段樹"></a>線段樹</h5><p>一樣對值域（這題是1000000）的4倍開了線段樹，同時維護一個非負整數 $tag$ 表示區間被覆蓋的情況。當每一次修改完成之後，我們可以直接取用根節點 $seg[1]$ 的數值表示寬度（非0的個數）！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//seg[i]表示i的左右兩子樹的區間非0的個數</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>    <span class="comment">//建立線段樹</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//維護非0個數</span></span><br><span class="line">    <span class="keyword">int</span> tag;    <span class="comment">//使用tag紀錄區間被覆蓋次數</span></span><br><span class="line">&#125;seg[<span class="number">4</span>*M];</span><br></pre></td></tr></table></figure>
<p>接下來就是在程式執行的過程中將 $2n$ 條邊依照y座標進行排序 $O(nlogn)$，接著依序使用掃描線搭配線段樹的修改，計算矩形的面積。最後就是輸出加起來的答案。</p>
<div class="note info">
            <p><strong>Debug 小錯誤</strong><br><a href="https://tioj.ck.tp.edu.tw/submissions/261512">Submission1:WA</a><br>可以看到有一筆測資過不了，95分QQQ</p><p><img src="https://i.imgur.com/1UNrejV.png" alt=""></p><p>後來debug之後發現到，因為我是對每一個矩形先輸入下界之後才是上界，當我在排序的過程中，上界有可能有機會跑到下界之前，造成 $tag$ 被扣到負的情況，但在定義中可以清楚知道 $tag$ 是非負整數造成錯誤。因此只要把排序的過程改成 stable_sort() 即可！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(arr,arr+(n&lt;&lt;<span class="number">1</span>),cmp);</span><br></pre></td></tr></table></figure>
          </div>
<p>最後終於是程式碼的部分，以下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>    <span class="comment">//每一個矩陣分成上下兩條邊</span></span><br><span class="line">    <span class="keyword">int</span> x1;     <span class="comment">//矩形左界x1</span></span><br><span class="line">    <span class="keyword">int</span> x2;     <span class="comment">//矩形右界x2</span></span><br><span class="line">    <span class="keyword">int</span> y;      <span class="comment">//矩形y座標（分上下兩邊）</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//val = ±1(進入代表1、離開代表-1)</span></span><br><span class="line">    </span><br><span class="line">&#125;arr[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//seg[i]表示i的左右兩子樹的區間非0的個數</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>    <span class="comment">//建立線段樹</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//維護非0個數</span></span><br><span class="line">    <span class="keyword">int</span> tag;    <span class="comment">//使用tag紀錄區間被覆蓋次數</span></span><br><span class="line">    </span><br><span class="line">&#125;seg[<span class="number">4</span>*M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//對區間[ql,qr)進行加值val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l || ql &gt;= r || qr &lt;= l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        seg[cur].tag += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">2</span>*cur,l,mid,ql,qr,val);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r,ql,qr,val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左右節點如有tag表示被完全覆蓋，直接加上區間大小，否則加上seg[左右子樹]</span></span><br><span class="line">    seg[cur].val = (seg[<span class="number">2</span>*cur].tag?mid-l:seg[<span class="number">2</span>*cur].val)</span><br><span class="line">                  +(seg[<span class="number">2</span>*cur+<span class="number">1</span>].tag?r-mid:seg[<span class="number">2</span>*cur+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="built_in">memset</span>(seg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(seg));</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;                                   <span class="comment">//依序輸入左右下上：x1,x2,y1,y2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;y1&gt;&gt;y2;</span><br><span class="line">        arr[i] = (Node)&#123;x1,x2,y1,<span class="number">1</span>&#125;;          <span class="comment">//插入矩形下邊，帶入val = 1</span></span><br><span class="line">        arr[i+<span class="number">1</span>] = (Node)&#123;x1,x2,y2,<span class="number">-1</span>&#125;;       <span class="comment">//上邊要val = -1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stable_sort</span>(arr,arr+(n&lt;&lt;<span class="number">1</span>),cmp);          <span class="comment">//依照y座標由小到大排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> y0 = <span class="number">0</span>,val = <span class="number">0</span>;                       <span class="comment">//有下而上的枚舉所有水平邊</span></span><br><span class="line">    lld ans = <span class="number">0LL</span>;                            <span class="comment">//上一條y的座標，計算高，val為矩形結合起來的寬</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i++)&#123;                <span class="comment">//枚舉2n條y的邊</span></span><br><span class="line">        ans += (lld)(arr[i].y-y0)*val;        <span class="comment">//計算面積（寬*高）</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">0</span>,M,arr[i].x1,arr[i].x2,arr[i].val);</span><br><span class="line">        y0 = arr[i].y;</span><br><span class="line">        val = seg[<span class="number">1</span>].val;                     <span class="comment">//修改後（下一輪）的矩陣寬度</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>線段樹</category>
      </categories>
      <tags>
        <tag>2021暑假筆記</tag>
        <tag>2020資訊之芽</tag>
      </tags>
  </entry>
  <entry>
    <title>資芽第九週：動態規劃（三）</title>
    <url>/sprout9/</url>
    <content><![CDATA[<h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>首先是影片的重點整理，主題是DP優化：</p>
<p>DP優化</p>
<ul>
<li>矩陣快速冪優化<ul>
<li>費氏數列：O(n)-&gt;O(logN)</li>
<li>DC</li>
<li>把很大的n做矩陣快速冪降到logN<span id="more"></span></li>
</ul>
</li>
<li><p>狀態壓縮</p>
<ul>
<li>TSP旅行銷售員問題</li>
<li>權重最小的漢米頓迴路</li>
<li>暴力做：n個點、n-1點、…、1個點</li>
<li>暴力複雜度：O(N!)</li>
<li>使用位元紀錄</li>
<li>DP[n][s]用s的二進位第i位表示是否去過該城市</li>
<li>複雜度：轉移$O(N)\times O(N\times 2^N)=O(n^2\times 2^n)$</li>
</ul>
</li>
<li><p>資料結構優化（單調隊列優化）</p>
<ul>
<li>開一個新的dpMAX，O(n^2)-&gt;O(n)</li>
<li>不大於K，用heap來O(nlogn)維護遞增的固定區間最大值</li>
<li>方法三：用Deque實作，O(n)</li>
<li>I<j，dp[i]>dp[j] 具有單調性（單調遞減）</li>
</ul>
</li>
<li><p>円円開店</p>
<ul>
<li>dp[n] = val[n]+max(dp[i]-c(n-i)),n-k≤i≤n-1</li>
<li>O(NK)-&gt;O(N)使用單調隊列優化</li>
<li>令t[I] = dp[i]+c*i</li>
</ul>
</li>
<li><p>有限背包問題優化</p>
<ul>
<li>分推湊出每一種重量</li>
<li>如何分推：二進位 ${1,2,4,8,…,2^p,q}$，使 $2^{p+1}-1$ 不大於k[i]的最大整數</li>
<li>原O(NWK) -&gt; O(NW*logK)</li>
<li>利用單調隊列優化：O(NW)!!!</li>
</ul>
</li>
</ul>
<h2 id="上機作業"><a href="#上機作業" class="headerlink" title="上機作業"></a>上機作業</h2><h3 id="円円賣漢堡"><a href="#円円賣漢堡" class="headerlink" title="円円賣漢堡"></a>円円賣漢堡</h3><p><a href="https://neoj.sprout.tw/problem/188/">題目連結</a><br>首先在做任何優化之前，都必須先列出定義與轉移式。</p>
<h4 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h4><p>定義$dp[i]$為在第1到i個點開店，且第i個點有開店時的最大盈利</p>
<h4 id="轉移式"><a href="#轉移式" class="headerlink" title="轉移式"></a>轉移式</h4><p>$dp[i] = val[i]+max(dp[j]-c(i-j)),i-k≤j≤i-1$</p>
<h4 id="邊界"><a href="#邊界" class="headerlink" title="邊界"></a>邊界</h4><p>$dp[i] = 0, 1≤i≤n$</p>
<p>做完以上的定義與轉移式之後，可以得到複雜度：$O(NK)$就可以得到以下的結果：<br><img src="https://i.imgur.com/Z4OaqJJ.png" alt=""><br>試著利用<strong>單調隊列優化</strong>，把複雜度降到$O(N)$<br>利用單調隊列可以確保所有的數字都只會被push與pop一次，因此總複雜度為$O(n)$<br><img src="https://i.imgur.com/hn2Px6s.png" alt=""><br>差一個K時間就差很多！</p>
<p>具體的作法如下，因為我們要維護的單調隊列的dp後面有一些東西，因此我們要做一些調整，把有i的提出來（不然當i不一樣的時候就很難處理）</p>
<script type="math/tex; mode=display">\begin{split}dp[i] &= val[i]+max(dp[j]-c(i-j)),i-k≤j≤i-1\\&=val[i]-ci+max(dp[j]+cj)\end{split}</script><p>這時候令 $t[j] = dp[j]+cj$，可以把加上 $cj$ 想像成跟頭的距離（跟當前的 $-ci$ 合在一起就是我們要的距離），則 $max(t[j]),i-k≤j≤i-1$ 就可以使用單調隊列優化！</p>
<div class="note info">
            <p><strong>單調隊列優化</strong></p><p>單調隊列優化名稱的由來是因為維護的容器具有單調性（在這裡用到的是單調遞減），這一次嘗試的是用deque<pair<int,int>&gt;來實作，第一維是裝t[i]，第二維是裝i。以下是具體的實作步驟：</p><ol><li>將單調隊列中<font color="#f00">過時的</font>（也就是距離大於K的）pop出來，讓容器中的元素都是可以被取到的狀態</li><li>更新 $dp[n]$ 的值，利用容器最前面的元素（就是最大的by單調性）來更新。要注意到，元素最前面固然是最大，但也可能會比什麼都不取還差，要特別注意！</li><li>從容器的後面更新，把小於接下來要放入的值的元素都pop出來，以維持單調遞減的特性！</li><li>將當前的 $t[n]$ 給push進去！結束！</li></ol><p>如果要維護dp[n]的單調性，會保證若 $i<j$，則 $dp[i]>dp[j]$；因為如果$dp[i]≤dp[j]$，那第i個永遠不會被取到（因為要求的區間是不斷往後的，若一個數字在前面又比後面的數字小，永遠就不會被取到！）</p>
          </div>
<p>以下是程式碼的部分，其中第21到24行為單調隊列優化的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k,c,val[<span class="number">100005</span>];cin&gt;&gt;n&gt;&gt;k&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;val[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    deque&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; deq;</span><br><span class="line">    </span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(val[<span class="number">1</span>]+c,<span class="number">1</span>));    <span class="comment">//這個小細節差點沒有注意到，要加上c</span></span><br><span class="line">    dp[<span class="number">1</span>] = val[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">front</span>().second &lt; i-k)deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        dp[i] = val[i]-c*i+<span class="built_in">max</span>(c*i,deq.<span class="built_in">front</span>().first);</span><br><span class="line">        <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">back</span>().first &lt;= dp[i]+c*i)deq.<span class="built_in">pop_back</span>();</span><br><span class="line">        deq.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dp[i]+c*i,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高棕櫚觀光農場：旅行銷售員問題TSP"><a href="#高棕櫚觀光農場：旅行銷售員問題TSP" class="headerlink" title="高棕櫚觀光農場：旅行銷售員問題TSP"></a>高棕櫚觀光農場：旅行銷售員問題TSP</h3><p><a href="https://neoj.sprout.tw/problem/187/">題目連結</a><br>第一次寫<strong>TSP</strong>(Traveling Salesman Problem)，題目敘述如下：</p>
<blockquote>
<p>給定一系列城市和每對城市之間的距離，求解存取每一座城市一次並回到起始城市的最短迴路。</p>
</blockquote>
<p>這是一個已經被證明$NP-Hard$ 的問題，暴力作法是要檢查所有路徑的情況，因為共有n個點，每一個點又連接n-1個點，繼續下去總共會有N!種情況，因此複雜度為$O(n!)$。<br>總共的點數共有n個，根據多邊形的邊數公式可以知道一共有$\frac{n^2-n}{2}$條邊，每一條邊都有各自的距離。<br>如果改用DP做，時間複雜度可以壓到時間複雜度$O(n^2\cdot2^n)$，比$O(n!)$還優秀！這一題用到的是DP優化中的<font color="#f00">狀態壓縮</font>，具體的實作細節如下：</p>
<div class="note success">
            <p><strong>位元運算</strong><br>在這一題需要用到位元運算，用16個bit表示每一個點有沒有被走訪過。用這樣的表示方法可以讓code更為節儉，也就是狀態壓縮的概念。</p><p><strong>左移運算子(&lt;&lt;)</strong><br>這一題會一直反覆被用到，1&lt;&lt;t代表把1往左移動t單位，用10進位表示就是$2^t$。每往左移動一格，數字就會變成原來的兩倍！</p><p><strong>狀態壓縮</strong><br>將十進位整數s以二進位表示，會得到一串01字串，假設s=10，則 $s = 1010_{(2)}$。以這題來說，這樣的字串我們可以用來表示第4和第2個點已經被拜訪，而第3跟第1個點還沒有被拜訪。</p>
          </div>
<h4 id="定義-1"><a href="#定義-1" class="headerlink" title="定義"></a>定義</h4><p>定義 $dp[n][s]$ 表示目前在第n點上，s為走過的點（狀態壓縮）的最短距離</p>
<h4 id="轉移式-1"><a href="#轉移式-1" class="headerlink" title="轉移式"></a>轉移式</h4><p>$dp[n][s] = min(dp[i][s-(1&lt;&lt;n)]+dis[i][n])$, for all i such that s&amp;(1&lt;&lt;i)!=0</p>
<p>這個轉移式很有意思，因為s代表了每一個點是否有被走過，當我要更新dp[n][s]時，我要確保此時的狀態s中的點n必須為1。同時，因為1&lt;&lt;i用二進位表示只有第i位會是1其他都是0，做and運算就看s的第i位決定結果。</p>
<p>對於每一個i必須確保第i點在狀態s中有被造訪，因此有了後面的條件。另外轉移式中的s-(1&lt;&lt;N)是把第n個點從未造訪的狀態轉移。</p>
<h4 id="邊界-1"><a href="#邊界-1" class="headerlink" title="邊界"></a>邊界</h4><p>$dp[0][1] = 0,\quad dp[i][j]= \infty$</p>
<p>距離的預設狀態為無限大，第一個點的初始狀態是最短距離0</p>
<h4 id="實作小細節"><a href="#實作小細節" class="headerlink" title="實作小細節"></a>實作小細節</h4><p><strong>迴圈順序</strong><br>在轉移的過程中，迴圈的第一層必須是狀態，第二層才是城市。如果顛倒過來的話，會導致前面的城市在狀態還沒有被更新的時候就已經失去了之後被更新的機會，因此城市的迴圈必須放在第二層！</p>
<p><strong>求答案</strong><br>因為我們要求的是回到原點的最短距離，因此在全部轉移完成之後，利用一個迴圈把回去原點的路的距離加上去，求得最小值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,dis[<span class="number">20</span>][<span class="number">20</span>];cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;dis[i][j];</span><br><span class="line">            dis[j][i] = dis[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[N][<span class="number">66000</span>],m = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//將0點到自己的距離設為1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(n^2 2^n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;            <span class="comment">//i表示2^n每一種狀態</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;        <span class="comment">//j表示城市</span></span><br><span class="line">            <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))<span class="keyword">continue</span>; <span class="comment">//j城市要是被造訪過的狀態</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;    <span class="comment">//可以到的所有點中的狀態</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp; <span class="number">1</span>&lt;&lt;k)&#123;        <span class="comment">//確保轉移過去的有被造訪過</span></span><br><span class="line">                    dp[j][i] = <span class="built_in">min</span>(dp[j][i],dp[k][i-(<span class="number">1</span>&lt;&lt;j)]+dis[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)ans = <span class="built_in">min</span>(ans,dp[i][m<span class="number">-1</span>]+dis[i][<span class="number">0</span>]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="憤怒的小鳥"><a href="#憤怒的小鳥" class="headerlink" title="憤怒的小鳥"></a>憤怒的小鳥</h3><p><a href="https://neoj.sprout.tw/problem/255/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/177536/">Submission</a><br>玩憤怒鳥遊戲的概念，給定二維平面上n個點代表n個豬（皆在第一象限），這時候可以從原點(0,0)的位置發射軌跡為拋物線的小鳥，打到豬豬後並不會改變飛行的軌跡，題目想要問最少要發射幾個小鳥才能射下所有的豬豬？</p>
<blockquote>
<p>範例測資<br>7<br>1 3<br>2 4<br>3 3<br>2 6<br>4 8<br>1 1<br>1 2</p>
</blockquote>
<p>如果畫在圖上就長這樣：<br><img src="https://i.imgur.com/cCEHouc.png" alt=""></p>
<p>如果把拋物線畫出來就像這樣：<br><img src="https://i.imgur.com/u63WTC6.png" alt=""></p>
<p>因為$n\le24$，所以可以知道這一題可能只能把所有情況都掃一遍（<del>才不是因為剛好講狀態壓縮XD</del>）</p>
<p><strong>作法1：</strong> 時間複雜度$O(n^2\cdot 2^n)$<br>我們可以利用一個二維陣列g[i][j]表示經過i豬和j豬與原點所形成的拋物線所能經過的所有點的狀態。這樣我們可以利用$O(n^3)$的時間完成預處理，知道一條由i豬和j豬形成的拋物線能經過的點的狀態（用二進位表示），在dp轉移的時候則需枚舉所有的i和j，所需時間是$n^2$。<br>轉移式的話一開始是寫用推的：$dp[s|g[i][j]] = min(dp[s]+1)$，比較直覺一點。</p>
<p><strong>作法2：</strong> 時間複雜度$O(n\cdot 2^n)$<br>當我們在做狀態s的時候，如果是上面的方法就是$n^2$掃過所有的點的組合，其實我們可以只要找到s其中一位第k位是1的，因為那一位所對應到的豬豬一定會經過，所以就可以針對那一位做轉移，如此一來跟k同在一個拋物線的最多只會有n個，複雜度就降到了$O(n\cdot 2^n)$。這裡可以搭配一個vector<int>line[N]裝每一位有經過的可能的狀態。</p>
<h4 id="定義-2"><a href="#定義-2" class="headerlink" title="定義"></a>定義</h4><p>$dp[s]$為狀態為s的時候的最小拋物線數量</p>
<h4 id="轉移式-2"><a href="#轉移式-2" class="headerlink" title="轉移式"></a>轉移式</h4><p>$dp[s]=min(dp[s\&amp;(\sim mask)]+1)$</p>
<p>這個轉移式挺有趣的，我們知道如果要從狀態p得到狀態s，對於s是0的bit，p也應該是0；對於s是1的bit，若mask是1，則p的bit要是0，反之則是1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: for each bit p in s</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: if p=1</span><br><span class="line">e=&gt;operation: set dp[i] to 0</span><br><span class="line">io=&gt;condition: if mask[i]=1</span><br><span class="line">ss=&gt;operation: set dp[i] to 1</span><br><span class="line">sp1=&gt;operation: set dp[i] to 0</span><br><span class="line">sp2=&gt;operation: set dp[i] to 1</span><br><span class="line"></span><br><span class="line">st-&gt;cond-&gt;io</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;e</span><br><span class="line"></span><br><span class="line">io(yes)-&gt;sp1</span><br><span class="line">io(no)-&gt;sp2</span><br></pre></td></tr></table></figure>
<p>這個轉移式可以有另外一個表示的方式，可以達到同樣的效果：<br>$dp[s]=min(dp[s\&amp;(i\oplus mask)]+1)$</p>
<h4 id="邊界-2"><a href="#邊界-2" class="headerlink" title="邊界"></a>邊界</h4><p>$for\ each\ dp[i]=0$</p>
<p>以下程式碼是以$O(n^3)$的預處理，$O(n\cdot 2^n)$的轉移，因此總時間複雜度是$O(2^n)$，在時限內是可以過的！<br><img src="https://i.imgur.com/j8uRDfj.png" alt=""></p>
<blockquote>
<p>[time=Thu, Sep 16, 2021 3:03 PM]更新</p>
</blockquote>
<p>結果呢，有人問了我這一題，我回去看我的code，結果發現明明應該是 $O(n\cdot 2^n)$ 轉移，但每一個line_mask中在worst case卻有 $n^2$ 個狀態，這樣子下來一樣還是 $O(n^2\cdot 2^n)$ 沒有進步。發現問題在於，當全部的點都在同一條拋物線上的時候，會有重複的狀態被push很多次的問題，所以只要用visit去紀錄這種狀態是否出現過，讓最多被推入一次就好!</p>
<p><img src="https://i.imgur.com/V2ubK6i.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> long long ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n,x[N],y[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;line_mask[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>&lt;&lt;n,dp[m];</span><br><span class="line">    <span class="keyword">bool</span> visit[m];<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="comment">//calculate all lines O(n^3)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        line_mask[i].<span class="built_in">push_back</span>(<span class="number">1</span>&lt;&lt;i);       <span class="comment">//有可能此點孤立一人，要確保也在裡面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = x[i],y1 = y[i];</span><br><span class="line">            <span class="keyword">int</span> x2 = x[j],y2 = y[j];</span><br><span class="line">            <span class="keyword">if</span>(x1==x2)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> a = (<span class="keyword">double</span>)((x1*y2)-(x2*y1))/(x1*x2*(x2-x1));</span><br><span class="line">            <span class="keyword">double</span> b = (<span class="keyword">double</span>)(y1-a*x1*x1)/x1;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mask1 = <span class="number">1</span>&lt;&lt;i|<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>((<span class="keyword">double</span>)a*x[k]*x[k]+b*x[k]-y[k])&lt;=<span class="number">1e-6</span>)mask1|=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visit[mask1])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((mask1&gt;&gt;k) &amp; <span class="number">1</span>)line_mask[k].<span class="built_in">push_back</span>(mask1);</span><br><span class="line">            &#125;</span><br><span class="line">            visit[mask1] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//過k點的所有經過的點的狀態</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n 2^n轉移)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>;s &lt; m;s++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = __lg(s),len = line_mask[cur].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mk = line_mask[cur][i];</span><br><span class="line">            dp[s] = <span class="built_in">min</span>(dp[s], dp[(s&amp;(~mk))] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(dp[s] == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[m<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="硬幣問題"><a href="#硬幣問題" class="headerlink" title="硬幣問題"></a>硬幣問題</h3><p><a href="https://neoj.sprout.tw/problem/159/">題目連結</a></p>
<p>有點訝異，原本想說把code丟上去測一下，看看能過前面幾筆測資，結果卻直接全部過了！我也沒有做什麼特別的DP優化，丟上去卻直接Accept了！這題跟原本的硬幣問題有些許的不同，在於他有限制每一種硬幣的數量，面額為 $C_i$ 的硬幣共有 $K_i$ 個，也就是要問你能否用這些固定數量的硬幣湊出特定的面額。</p>
<p>我們可以討論不同的面額的餘數，時間複雜度分析估計約為：$O(N\times C_i\times \frac{M}{C_i})=O(NM)$，照理來說因為要執行t次，算下來有可能會TLE，不過這一題沒有卡就是了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,val[N],num[N];cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;val[i]&gt;&gt;num[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">20005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;val[i];k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = num[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k+val[i];j&lt;=m;j+=val[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]!=<span class="number">0</span>)left = num[i];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(left&gt;<span class="number">0</span> &amp;&amp; dp[j-val[i]])&#123;</span><br><span class="line">                    left--;</span><br><span class="line">                    dp[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m]==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="烏龜疊疊樂—-易"><a href="#烏龜疊疊樂—-易" class="headerlink" title="烏龜疊疊樂—-易"></a>烏龜疊疊樂—-易</h3><p><a href="https://neoj.sprout.tw/problem/185/">題目連結</a><br>這題簡單來說，是給定一個數列，要嘗試分配成好幾堆，每一堆的數量不超過k個。其中第i堆的總和乘上(i-1)，算出來的總和要最小。由題目敘述可以知道，每一堆到後面乘上的數字是越來越大，也就是被加上的次數會越來越多，如果我們將數列倒過來dp會比正面做來得容易維護。</p>
<div class="note success">
            <p><strong>轉移式</strong><br>dp[i] = max(dp[j]+pref[j]),for i-k≤j≤i-1，pref是維護已經反序過後的數列之前綴和。以範測為例，當k=2時，dp[i]可以選擇的就是從dp[i-1]跟dp[i-2]轉移，如果選擇dp[i-2]就表示第i項會和第i-1項合併成一堆，加上pref[i-2]也就是把前面的每一堆的數量乘上的數字都加一，也就是加上一個前綴和（由於每一個數字只會被合併一次）</p><p><strong>小證明：每一個數字只會被合併一次</strong><br>在轉移的過程中，有沒有可能會發生dp[i]要轉移的對象是dp[i-2]，但dp[i-1]卻已經被融合過了，造成三個烏龜融合在一起的情況？</p><p>也就是下圖這一種情況，dp[i-1]、dp[i-2]合併，dp[i]、dp[i-1]合併，變成三個融合超過k的情況（dp[i-2],dp[i-1],dp[i]合併）。<br><img src="https://i.imgur.com/3NufpZ9.png" alt=""><br>答案：不會</p><p>首先先從dp[i-3]轉移的dp[i-1]表示第i-2跟i-1是合併成一堆，接下來的dp[i]從dp[i-2]轉移，加上了pref[i-2]，也就是把i-2獨立出去，i跟i-1合併成一堆，因此不會有大於k個烏龜合併在一起的情況。</p>
          </div>
<p>這一題的轉移式不好想，要把東西反序之後比較好dp，轉移式也比較好寫出來！觀察到越後面的數字被重複加的機會比較大（高度越高），因此將數列的順續顛倒搭配前綴和就能比較方便的轉移！</p>
<h4 id="定義-3"><a href="#定義-3" class="headerlink" title="定義"></a>定義</h4><p>$dp[i]$定義為使用1到i個烏龜，違和度的最大值</p>
<h4 id="轉移式-3"><a href="#轉移式-3" class="headerlink" title="轉移式"></a>轉移式</h4><p>$dp[i] = max(dp[j]+pref[j]),for\ i-k≤j≤i-1$<br>這個轉移式是建立在順序顛倒的情況，在輸入的時候順便把逆序。</p>
<h4 id="邊界-3"><a href="#邊界-3" class="headerlink" title="邊界"></a>邊界</h4><p>$for\ each\ dp[i] = 0$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,arr[N],pref[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pref[i] = pref[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[N];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    </span><br><span class="line">    deque&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; deq;</span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">front</span>().second&lt;i-k)deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        dp[i] = deq.<span class="built_in">front</span>().first;</span><br><span class="line">        <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">back</span>().first &lt;= dp[i]+pref[i])deq.<span class="built_in">pop_back</span>();</span><br><span class="line">        deq.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dp[i]+pref[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手寫作業"><a href="#手寫作業" class="headerlink" title="手寫作業"></a>手寫作業</h2><p>這一週的主題是NP問題以及SAT，證明好難、數學好難！</p>
]]></content>
      <categories>
        <category>資訊之芽筆記</category>
      </categories>
      <tags>
        <tag>動態規劃</tag>
        <tag>DP</tag>
        <tag>資芽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>字串演算法 (String)</title>
    <url>/string1/</url>
    <content><![CDATA[<p>這個暑假看了動態規劃(1),(2)，線段樹、最短路徑、計算幾何、字串演算法，這一篇的完成算是暑假的一個里程吧！接下來繼續學習不同的主題，再把筆記更新到部落格中！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><ul>
<li>定義<ul>
<li>大寫 $\Sigma$ 表示字元集</li>
<li>字串：有限個字元集組成</li>
<li>$|\Sigma|$ 字元集大小、|S|字串長度</li>
<li>S[a:b]表示連續從字元a到b<span id="more"></span></li>
</ul>
</li>
<li>子字串：S[a:b]</li>
<li>前綴：S[0:b]</li>
<li>後綴：S[a:|S|-1]</li>
</ul>
<h3 id="字典樹Trie"><a href="#字典樹Trie" class="headerlink" title="字典樹Trie"></a>字典樹Trie</h3><ul>
<li>定義<ul>
<li>例題：字串出現次數</li>
<li>一顆由根、邊一綠往下指的有向樹</li>
<li>每個邊為字元、每一點代表字串</li>
<li>每經過一條邊，字串加上邊的字元</li>
<li>根節點為空字串！</li>
</ul>
</li>
<li>操作<ul>
<li>查詢字串：$O(L)$，由根順著邊往下找</li>
<li>插入字串：$O(L)$，不斷往下走直到空節點，在Trie加入一個節點</li>
<li>節點必須記錄當前是否為有效字串</li>
<li>Trie結構中包含：字串、紀錄字串出現次數</li>
</ul>
</li>
</ul>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><ul>
<li>功能：進行字串匹配</li>
<li>例題：字串S在字串T哪些位置出現<ul>
<li>暴力匹配：時間 $O(|S|\times|T|)$</li>
</ul>
</li>
<li>F[i]表示當配對成功A[0:i]後即配對失敗，將A[F[i]]對齊原本A[i]的位置</li>
<li>搭配F[i]調整在串移動的長度</li>
<li>匹配：複雜度 $O(|T|)$，建立F函數：$O(|S|)$</li>
</ul>
<h3 id="漢明距離-Hamming-distance"><a href="#漢明距離-Hamming-distance" class="headerlink" title="漢明距離(Hamming distance)"></a>漢明距離(Hamming distance)</h3><ul>
<li>兩個等長字符串對應位置的不同字符的個數</li>
</ul>
<h3 id="Z-value"><a href="#Z-value" class="headerlink" title="Z-value"></a>Z-value</h3><ul>
<li>z[i] 是指由 s[i] 開始的字串，與 s[0] 開始的字串可以匹配到多長</li>
<li>S[0:k-1] = S[i:i+k-1]</li>
<li>z[0] = 0</li>
</ul>
<h3 id="Rolling-Hash"><a href="#Rolling-Hash" class="headerlink" title="Rolling Hash"></a>Rolling Hash</h3><ul>
<li>之前隨機講過</li>
</ul>
<h3 id="後綴數組（Suffix-Array）"><a href="#後綴數組（Suffix-Array）" class="headerlink" title="後綴數組（Suffix Array）"></a>後綴數組（Suffix Array）</h3><ul>
<li>將一個字串的所有後綴進行排序</li>
<li>基數排序（Radix Sort）</li>
</ul>
<h3 id="最長共同前綴（LCP-Longest-Common-Prefix）"><a href="#最長共同前綴（LCP-Longest-Common-Prefix）" class="headerlink" title="最長共同前綴（LCP,Longest Common Prefix）"></a>最長共同前綴（LCP,Longest Common Prefix）</h3><ul>
<li>兩字串的最長共同前綴</li>
<li>將最長共同前綴轉換成區間最小值問題</li>
</ul>
<h2 id="字串演算法主題"><a href="#字串演算法主題" class="headerlink" title="字串演算法主題"></a>字串演算法主題</h2><h3 id="字典樹Trie-1"><a href="#字典樹Trie-1" class="headerlink" title="字典樹Trie"></a>字典樹Trie</h3><p>字典樹是以指標型態建立的一棵樹，邊代表一個字元、節點代表從根一路走來的邊形成的字串，從根節點開始（根節點為空），每經過一條邊，就把字串加上那一條邊對應的字元，直到找出要匹配的字串。如果有多筆獨立的詢問，只要加上Delete函數就可以了！</p>
<h4 id="Trie結構"><a href="#Trie結構" class="headerlink" title="Trie結構"></a>Trie結構</h4><p>實作上的陣列c指向個別的字元，不一定要用cnt，根據題目的所求調整不同的變數設定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span>        <span class="comment">//利用指標建立一棵樹</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];    <span class="comment">//對應a-z每一條邊</span></span><br><span class="line">    <span class="keyword">int</span> cnt;        <span class="comment">//字串出現次數</span></span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">cnt</span>(<span class="number">0</span>)&#123; <span class="comment">//初始設定</span></span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie* root;</span><br></pre></td></tr></table></figure>
<h4 id="Insert函數"><a href="#Insert函數" class="headerlink" title="Insert函數"></a>Insert函數</h4><p>在插入的過程中言錄新增路徑，一樣嘢可以根據題目要求在過程中進行變數紀錄等。如<strong>NEOJ 267 自動完成系統</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;           <span class="comment">//從根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])     <span class="comment">//如果樹上無此字元則new</span></span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*s)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];   <span class="comment">//繼續造訪Trie</span></span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;cnt += <span class="number">1</span>;              <span class="comment">//字串出現次數(字串對應唯一葉節點)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查詢函數"><a href="#查詢函數" class="headerlink" title="查詢函數"></a>查詢函數</h4><p>一個字串對應到唯一的路徑，從根節點根據每一個字元決定路徑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;              <span class="comment">//查找字串s</span></span><br><span class="line">    Trie *ptr = root;           <span class="comment">//根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;                  <span class="comment">//無此字串，回傳次數0</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];</span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;cnt;            <span class="comment">//回傳字串出現次數</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Delete函數"><a href="#Delete函數" class="headerlink" title="Delete函數"></a>Delete函數</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Trie *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;c[i])&#123;</span><br><span class="line">            <span class="built_in">clear</span>(s-&gt;c[i]);</span><br><span class="line">            <span class="keyword">delete</span> s-&gt;c[i];</span><br><span class="line">            s-&gt;c[i] = <span class="literal">nullptr</span>;    <span class="comment">//很重要</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h3><p>首先要求出Failure Function，它可以在 $O(|S|)$ 建立。失敗函數的定義是：</p>
<blockquote>
<p>$F[i]$ 表示當成功配對 $A[0:i]$ 之後，配對失敗時，我們會將 $A[ F[i]]$ 對齊原本 $A[i]$ 的位置</p>
</blockquote>
<p>如果寫成數學式的定義：</p>
<script type="math/tex; mode=display">F_A(J)=\left\{
\begin{array}{l}
-1,&&\text{if j = 0}\\
max\{p:A_{0...p} = A_{j-p...j} \text{ and 0≤p<j}\},&&\text{otherwise}\\
\end{array} \right.</script><p>這個函式以中文來說就是「<strong>最大前綴後綴</strong>」！</p>
<p>這個函數可以讓我們知道，當配對在較短字串 $S$ 在第 $i$ 位配對失敗時，要找到第 $F[i]$ 去繼續比對。從比較直觀的角度去理解，就是把字串要往右移幾格才能正確匹配上，如果配對失敗，則尋找更前面更短的子字串試試看。</p>
<p>以比較數學的角度看到底要怎麼建立Failure Function，可以從以下推導得知：</p>
<div class="note info">
            <p>假設 $F[i] = x, x≠-1$，根據上面的定義有這樣的等式：$A[0:x] = A[i-x:i]$<br>分成以下兩種情況做討論：</p><ul><li><p>$A[x+1] = A[i+1]$<br>這種情況就是兩邊的下一個字串都相同，直接將繼承前面的長度為x的子字串，因此有關係式$F[i+1] = x+1$</p></li><li><p>$A[x+1] ≠ A[i+1]$<br>這種情況比較棘手，我們無法繼續使用之前長度為x的子字串，因此我們要尋找前面更短的字串進行匹配。假設我們找到 $K$ 滿足 k&lt;x，同時 $A[0:k] = A[i-k:i]$ ，這時候我們只需確認 $A[k+1]=A[i+1]$ 是否成立即可，如果不成立則繼續尋找比 $K$ 更短的子字串。</p></li></ul><p><br></p><p>從剛剛的關係式，我們可以繼續寫下去： $A[0:k] = A[i-k:i]=A[x-k:x]$，理由是i的後綴與x後綴相同，因此 k的後綴就會和x的後綴相同。由失敗函式的定義推斷，我們要找的 $k$ 就會是 x 的失敗函式，$K = F[x]$。</p><p>如果找到的k不滿足 $A[k+1]=A[i+1]$ ，則會繼續尋找下一個更小的 $k$ 值直到滿足條件或是 $k=-1$ 為止。</p>
          </div>
<p>再來則是KMP MATCH，能在時間複雜度 $O(|T|)$ 內將匹配出來的位置找出來。具體的方法與建立Failure Function 相近，如果 $A[p+1]≠A[i+1]$，則尋找更小的字串長度 $k&lt;F[i]$ 看能否繼續匹配。當匹配成功，記得把p設為F[p]，因為匹配完成其實也可以看作是下一個字元匹配失敗（$S$ 的空字元對上 $T$ 的下一個）。</p>
<p>至於時間複雜度的部分，分析一下while迴圈總共會執行的次數，當每執行一次，p的值一定會遞減，而p只會在每一個迴圈最多加上一，因此p的增加會是字串長度 $|T|$ 的常數倍，使總複雜度為 $O(|T|)$。</p>
<h4 id="Build-Function"><a href="#Build-Function" class="headerlink" title="Build Function"></a>Build Function</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(|S|)要配對的字串以及Fail Function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_build</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = F[<span class="number">0</span>] = <span class="number">-1</span>;              <span class="comment">//初始設定為-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;          <span class="comment">//1到接下來字元</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=S[i])</span><br><span class="line">            p = F[p];               <span class="comment">//無法繼續配對，尋找更短字串</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == S[i])          <span class="comment">//配對成功(如都沒有一樣的就-1)</span></span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        F[i] = p;                   <span class="comment">//設定F[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Match-Function"><a href="#Match-Function" class="headerlink" title="Match Function"></a>Match Function</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">KMP_match</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F,<span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;            <span class="comment">//回傳匹配相同地方</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;                 <span class="comment">//紀錄短字串有多少被匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)&#123;      <span class="comment">//每一迴圈都讓T[i]被匹配到</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=T[i])</span><br><span class="line">            p = F[p];           <span class="comment">//使T[i]一定可以被匹配到</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == T[i])</span><br><span class="line">            p += <span class="number">1</span>;             <span class="comment">//T的第i個與S的p+1可以匹配</span></span><br><span class="line">        <span class="keyword">if</span>(!S[p+<span class="number">1</span>])&#123;            <span class="comment">//S[p]已經匹配完成</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-p); <span class="comment">//回推匹配開頭</span></span><br><span class="line">            p = F[p];           <span class="comment">//繼續下一輪匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hash-Robin-Karp-Algorithm"><a href="#Hash-Robin-Karp-Algorithm" class="headerlink" title="Hash (Robin-Karp Algorithm)"></a>Hash (Robin-Karp Algorithm)</h3><p>雜湊算法的核心概念就是以下公式，可以透過它進行字串比對等等。</p>
<script type="math/tex; mode=display">H(s[1:n]) = \sum_{i=0}^n S_i\times C^{n-i}</script><p>詳細內容可以參閱這一篇：<a href="https://hackmd.io/@peienwu/random">隨機演算法</a></p>
<h3 id="Z-Algorithm-Gusfield’s-Algorithm"><a href="#Z-Algorithm-Gusfield’s-Algorithm" class="headerlink" title="Z Algorithm (Gusfield’s Algorithm)"></a>Z Algorithm (Gusfield’s Algorithm)</h3><p>Z函數的定義是對於字串長度 $n$ 的字串 $S$ ，$z[i]$ 函數代表 $S[0:n-1]$ 和 $S[i:n-1]$ 的<strong>最長共同前綴</strong>，也就是LCP長度。定義 $z[0] = 0$。</p>
<p>有講義上面寫Z Function很簡單，但我覺得有夠難，難度跟KMP的理解差不多。根據Z函數的定義，我們可以$O(N^2)$建立z函數，顯然時間有些太多了。如果我們算 $Z[i]$ 的值可以用 $Z[0:i-1]$ 轉移過來，會省下許多時間，把時間降成 $O(N)$。</p>
<h4 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h4><p>整個算法的核心概念就是利用前面已經算好的Z Function去推現在的值，有點像動態規劃的概念。在整個過程中我們會維護右端點最大的匹配段（與前綴匹配），其表示為 $[l:l+Z[l]]$，也可以寫作 $[l:r]$，保證 $l ≤ r$。在計算 $Z[i]$ 的過程中，分別討論以下三種情形：</p>
<ol>
<li><p>$i ≤ r$<br>根據定義，因為區間 $[l:r]$ 本身是前綴，因此當 $i$ 在區間中間時會將區間分成左右兩半邊，將正個區間往前平移會讓 $i$ 對應到 $i-l$ 的位置，又此時區間為 $[0:r-l]$ ，因此$z[i] = min(z[i-l],r-i)$。</p>
<ul>
<li>$z[i-l] ≤ r-i$<br>已經知道 $z[i-l] &lt; r-i$ 表示在前後兩區間（分別從0,i開始）在一樣的情況下做多不超過 $z[i-l]$ 長度的匹配，因此第 $z[i-l]$ 的下一個字元必定無法繼續匹配成前綴。</li>
<li>$z[i-l] &gt; r-i$<br>在這種情況下已知 $s[0:r-l] = s[l:r]$，根據定義 $s[i-l:r-l] = s[i:r]$。因為 $z[i-l] &gt; r-i$，$z[i-l]$ 右端的範圍會超過 $r$ ，也就是說超過 $r$ 之後這個性質 $s[i-l:r-l] = s[i:r]$ 就不會成立，但可以確定 $z[i]$ 至少為 $r-i$。接著就暴力枚舉即可！</li>
</ul>
</li>
</ol>
<p>上面的內容可以用下圖解釋，兩條紅線段是一樣的，$x=i-l$ ，接著討論$Z[x]$ 的長度就可以知道該如何更新。<br><img src="https://i.imgur.com/6WU1JWG.png" alt=""></p>
<ol>
<li>$i &gt; r$<br>這種情況我們可以直接暴力跟前綴匹配。</li>
</ol>
<h4 id="程式實作1"><a href="#程式實作1" class="headerlink" title="程式實作1"></a>程式實作1</h4><p>程式碼中 $bst$ 表示的是左界 $l$，右界則是 $bst+Z[bst]$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo1</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *Z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bst = <span class="number">0</span>;                            <span class="comment">//相當於左界，大小為z[bst]</span></span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[bst]+bst &lt; i)Z[i] = <span class="number">0</span>;         <span class="comment">//直接暴力枚舉</span></span><br><span class="line">        <span class="keyword">else</span> Z[i] = <span class="built_in">min</span>(Z[i-bst],bst+Z[bst]-i);</span><br><span class="line">        <span class="keyword">while</span>(S[Z[i]]==S[i+Z[i]])Z[i]++;    <span class="comment">//依序暴力枚舉</span></span><br><span class="line">        <span class="keyword">if</span>(Z[i]+i &gt; bst+Z[bst])bst = i;     <span class="comment">//更新更遠的右界</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="程式實作2"><a href="#程式實作2" class="headerlink" title="程式實作2"></a>程式實作2</h4><p>這個實作超級短，沒有幾行就解決了，但他的效果卻是一樣的！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo2</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *Z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;                       <span class="comment">//左右界</span></span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[i-l],r-i),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(S[i+Z[i]] &amp;&amp; S[Z[i]] == S[i+Z[i]])&#123;</span><br><span class="line">            r = i+Z[i];               <span class="comment">//更新右界</span></span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;<span class="comment">//保證當Z[i]從Z[i-l]轉移時不會被更新！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>根據以上兩個程式碼可以發現，右界 $r$ 或是 $bst+Z[bst]$ 在過程中是不斷增大的，且r必定不會超過n，因此迴圈跑下來複雜度會是 $O(N)$。</p>
<h3 id="LPS-Manacher’s-Algorithm"><a href="#LPS-Manacher’s-Algorithm" class="headerlink" title="LPS (Manacher’s Algorithm)"></a>LPS (Manacher’s Algorithm)</h3><p>LPS (Longest Palindromic Substring)就是最長回文子字串，Naive的作法是每次 $O(n)$ 向兩側擴展，時間是 $O(n^2)$。</p>
<p>Manacher’s Algorithm這個演算法的概念和Z Alogorithm相近，可以在 $O(n)$ 的時間內找出以每一個點為中心之最長回文長度。回文的定義是無論從正序或是逆序看一個字串都是一樣的，分為兩種：一種是奇數的對稱，也就是以一個字元為對稱中心往兩側擴展；另一種則是以字元間的空格為對稱中心向兩側對稱。</p>
<p>這兩個的性質很不同，在處理的時候我們也不知道到底是呈現怎麼樣對稱的狀況，因此可以使用一種手法：將每一個字元中間插入同樣沒有出現過的字元，如此一來不論是偶數或是奇數長度的字串，在加入這個沒有出現過的字元之後，都會變成奇數長度的回文了！</p>
<p>定義 $z[i]$ 為以 $s[i]$ 為中心，最長的回文長度LPS（如果字元i是自己回文，定義Z[i] = 0]）。以字串abba來說就是以下情況：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>編號</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>原字串</td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>變更後</td>
<td>.</td>
<td>a</td>
<td>.</td>
<td>b</td>
<td>.</td>
<td>b</td>
<td>.</td>
<td>a</td>
<td>.</td>
</tr>
<tr>
<td>Z函數</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>跟Z Alogrithm 一樣，維護一個右界最遠的區間 $[l,r]$，作為在算 $z[i]$ 時能使用到的 $z[0:i-1]$ 的最大值，令他為 $r$。取j滿足 $j+z[j]$ 有最大值，分成以下兩個條件做討論：</p>
<p><strong>1. r &lt; i</strong><br>這種情況就表示不能用之前算的東西去更新現在的值，因此只能暴力枚舉 $s[i]$ 的左右兩側，看最長回文的長度為何。</p>
<p><strong>2. r &gt; i</strong><br>分成三種情況討論（比z algorithm多了一個），首先因為 $r &gt; i$，右界覆蓋了 $i$，表示我們可以從 $j$ 的另外一端映射出與 $s[i]$ 相同的 $s[i’]$（以 $j$ 為中心回文呈現兩側對稱），映射的索引值為 $2j-i$，如下圖：</p>
<p><img src="https://i.imgur.com/Pf1S21i.png" alt=""></p>
<p>因為 $z[i’]$ 已經計算過了，因此可以將 $r-i$ 以及 $z[i’]$ 的大小分成三種情況討論：</p>
<ul>
<li><p>$z[i’] &lt; r-i$<br>這種情況表示 $z[i’]$ 無法繼續往右邊更新，因為 $i$ 與 $i’$ 都是在以 $j$ 為中心的回文中，兩邊是一樣的，代表 $z[i] = z[i’]$ 且不可能再被更新成更大的範圍。</p>
</li>
<li><p>$z[i’] = r-i$<br>這種情況下是要枚舉的，從兩側映射的關係知道 $z[i]$ 的長度至少為 $r-i-1$，因此將 $z[i]$ 設為 $r-i$ 繼續枚舉就可以了！</p>
</li>
<li><p>$z[i’] &gt; r-i$<br>由下圖觀察發現，$z[i]$ 不可能比 $r-i$ 還要大，直接將值設為 $r-i$ 即可。<br><img src="https://i.imgur.com/zsb6blx.png" alt=""></p>
</li>
</ul>
<h4 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>觀察到while迴圈執行的狀況，只有當 $r &lt; i$ 以及 $z[i’] = r-i$ 時右界才有被更新的可能，兩種情況都會讓右界 $r$ 遞增，範圍最大到 $n$ ，因為不會減小的關係，總時間複雜度為線性的 $O(n)$！</p>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Longest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(T);m = <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(S,<span class="string">&#x27;.&#x27;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)S[<span class="number">2</span>*i+<span class="number">1</span>] = T[i];    <span class="comment">//間隔插入沒出現過字元</span></span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">1</span>;                               <span class="comment">//計算時使用右開區間</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;                        <span class="comment">//維護最大右界左右界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[<span class="number">2</span>*l-i],r-i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i-Z[i]&gt;=<span class="number">0</span> &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="後綴數組"><a href="#後綴數組" class="headerlink" title="後綴數組"></a>後綴數組</h3><p>一些基本定義，我們定義 $suf[i]$ 是字串 $S$ 從 $i$ 開始的後綴，也就是 $S[i:n-1]$。將一個字串所有的後綴取出來按照字典序進行排序，就是<strong>後綴數組</strong>。總共有三個複雜度：$O(n^2\log n)$、$O(n\log^2 n)$、$O(n\log n)$ 分別是使用暴力、倍增、基數排序的優化。</p>
<h4 id="暴力解-O-N-2-log-n"><a href="#暴力解-O-N-2-log-n" class="headerlink" title="暴力解 $O(N^2\log n)$"></a>暴力解 $O(N^2\log n)$</h4><p>$O(n)$ 的字串比對，排序 $O(n\log n)$，因此時間複雜度為 $O(n^2\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">10</span>] = <span class="string">&quot;algorithm&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(S+a,S+b) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> SA[<span class="number">10</span>];</span><br><span class="line">    n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)SA[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(SA,SA+n,cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cout&lt;&lt;SA[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="倍增-Quick-Sort"><a href="#倍增-Quick-Sort" class="headerlink" title="倍增+Quick Sort"></a>倍增+Quick Sort</h4><p>使用倍增可以讓複雜度做到 $O(n\log^2 n)$，其原理主要是讓比較的時間併入排序，同時多做 $O(\log n)$ 層的排序。定義 $sa[i]$ 為將後綴排序後第 $i$ 小的後綴編號；$rk[i]$ 表示後綴 $i$ 的排名。</p>
<p>倍增顧名思義，跟將數量乘上兩倍有關，因此會帶一個log。下圖就是一個排序的示例，首先按這字典序初始每一個字元的排名 $rk[i]$，進行 $O(\log n)$ 層，每一層用 $O(n\log n)$ 的時間進行排序。倍增讓原本的字串比較 $O(n)$ 降到 $O(\log n)$ 。</p>
<p>接下來的每一層的每一個字元 $s[i]$，在比較大小的時候，將 $rk[i]$ 以及 $rk[i+k]$ 組成一個 $pair$ 進行排序，從第一層開始，每一層的 $k$ 都會增加為2倍（倍增的概念）。pair的first就好比倍增時前 $s[i:i+k]$ 的排名、second就是 $s[i+k+1:i+2k]$ 的排名，搭配字典序是按照由前到後進行排名，比完fisrt才會比second，如此一來我們可以利用倍增的性質，也就是已經排名好的較短長度的字串，直接利用排好的名次進行下一輪的排序，這就導致我們不需要對每一個字元都看過一遍！</p>
<p><img src="https://i.imgur.com/l1aGK8f.png" alt=""><br><a href="https://oi-wiki.org/string/sa/">圖片出處</a>圖中的黑線岔開距離都會因為每一層而越岔越開（乘上2倍），也就是「倍增」所代表的意義！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);<span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;                <span class="comment">//進行O(lgn)次</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)            <span class="comment">//倍增pair的second</span></span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搭配-Radix-Sort"><a href="#搭配-Radix-Sort" class="headerlink" title="搭配 Radix Sort"></a>搭配 Radix Sort</h4><p>基數排序 (Raddix sort) 以及計數排序 (Counting sort) 兩者是有點從屬的關係，計數排序是基數排序的子程序，也就是說基數排序是透過對每一位進行計數排序完成的！</p>
<p>首先，我們需要 $O(n)$ 的空間進行每一輪的計數排序，對每一個元素進行排名（從1到n-1），如此一來才能確保不會有溢位的問題。先對第二個關鍵字進行排序，排完之後再按照第一個關鍵字排序。Raddix Sort 是穩定的，相同元素為在前面在排序之後一定會在前面。</p>
<p>有幾個地方有實作上進行基數排序的限制，首先第一輪會按照個別字母的字典序進行排序，用快排等基於比較的排序方法可以順利完成，但可惜基數排序不行，一定要乖乖的按照 1 到 n-1 順序進行排名。因此在第一輪會先使用 $std::sort$ 排名，之後進行raddix_sort！</p>
<p>最後一個小小的地方，就是當第二個 key 的值為 -1的情況（倍增超出範圍），在比較時可以直接push進去答案裡面，因為並沒有一個box的index 是-1，同時他們也是最小，丟進去即可。</p>
<p><strong>時間複雜度：</strong> 每一層進行 $O(n)$ 排序，因為倍增共有 $O(\log n)$ 層，因此總時間複雜度為 $O(n)\times O(\log n) = O(n\log n)$！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raddix_sort</span><span class="params">(vector&lt;pt&gt; &amp;cur)</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i].y == <span class="number">-1</span>)temp.<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">        <span class="keyword">else</span> box[cur[i].y].<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)box[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        box[temp[i].x].<span class="built_in">push_back</span>(temp[i]);</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])cur.<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最長共同前綴-LCP-Kasai’s-Algorithm"><a href="#最長共同前綴-LCP-Kasai’s-Algorithm" class="headerlink" title="最長共同前綴 LCP (Kasai’s Algorithm)"></a>最長共同前綴 LCP (Kasai’s Algorithm)</h3><p>最長共同前綴，以現在字串演算法中，假設 $lcp(i,j)$ 為後綴 $i$ 與 $j$ 的最長共同前綴。在<a href="https://www.geeksforgeeks.org/%C2%AD%C2%ADkasais-algorithm-for-construction-of-lcp-array-from-suffix-array/">這篇文章</a>中給出這個定義：</p>
<blockquote>
<p>A value lcp[i] indicates length of the longest common prefix of the suffixes inexed by suffix[i] and suffix[i+1]</p>
</blockquote>
<p>定義 $lcp[i]$ 為後綴 $i$ 與後綴 $i+1$ 的最長共同前綴，其中 $lcp[n-1]$ 沒有定義。再複習一下，$rk[i]$ 為第 $i$ 個後綴數組的排名$rk[i]$、$sa[i]$ 為排名為 $i$ 的字串所對應到的從 $sa[i]$ 開始的後綴數組。</p>
<p>到底我們要求的LCP是什麼？如果只是給兩個字串要求出共同最長前綴，那我們只要 $O(min(L_A,L_B))$ 就好，是可以接受的複雜度。但Kasai’s Algorithm不是要求這個。一般都在講到後綴字串之後講到LCP，為的就是要求出所有的後綴數組中，任兩個字串的共同最長前綴為何。以一個字串長度為 $l$ 來說，後綴的配對數量共有 $O(l^2)$ 組，暴力肯定會TLE。</p>
<p>求出 $lcs$ 需要有兩個引理：</p>
<ul>
<li><strong>第一個引理</strong><script type="math/tex; mode=display">lcp[rk[i]] ≥ lcp[rk[i-1]]-1</script>其中 $i$ 為<strong>尚未經過排序</strong>的從 $i$ 開始的後綴字串。</li>
</ul>
<p><strong>說明：</strong> 將後綴數組排序之後有點像將相似的字串排在一起（按字典序由小排到大），鄰近的字串其實代表著一個意義，兩者相似程度越高。因此 $lcp[rk[i-1]]$ 某種意義代表著與 $i-1$ 開始的後綴數組（簡稱後綴 $i-1$）跟其他字串最大的共同前綴長度。</p>
<p>接著我們看 $lcp[rk[i]]$ ，後綴 $i$ 就是後綴 $i-1$ 刪掉一個前綴字元的結果。我們假設跟後綴 $i-1$ 相近的那個字串叫做 $T$ （其實就是後綴 $rk[i-1]+1$），把 $T$ 刪除一個前綴字元之後所形成的字串（也就是比 $T$ 再短一字元的後綴）也就可以跟後綴 $i$ 進行匹配，其長度因為被刪掉一個前綴字元所以少一，因此得到了以上式子。</p>
<p>聽說很難證明，不過至少可以情感上的接受這件事是對的！</p>
<ul>
<li><strong>第二個引理</strong><script type="math/tex; mode=display">lcp(S_i,S-j) = min_{i≤k<j}(S_k,S_{k+1})</script></li>
</ul>
<p>為什麼可以算出最近的排名的LCP即可得到最長的LCP？從這個定理可以看出來，對於後綴 $i$ 以及後綴 $j$ ，取 $min$ 的原因是要確保所有的中間後綴 $k$ 都包含了下界 $k$ ，也就是說每個在 $i$ 與 $j$ 中間的人都至少跟前一個人相同個字元。</p>
<hr>
<p>以下以字串 $aabaabc$ 作為範例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>後綴</th>
<th>RK</th>
<th style="text-align:left">String</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td style="text-align:left">aabaabc</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td style="text-align:left">abaabc</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td style="text-align:left">baabc</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td style="text-align:left">aabc</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td style="text-align:left">abc</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td style="text-align:left">bc</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td style="text-align:left">c</td>
</tr>
</tbody>
</table>
</div>
<p>以下是SA與對應的String</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>RK</th>
<th>SA</th>
<th>String</th>
<th>LCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>aabaabc</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>aabc</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>abaabc</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>abc</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>baabc</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>bc</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>c</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>以下是找LCP流程：</p>
<ul>
<li>首先從後綴0開始，找到對應的下一個rk，也就是後綴3，得到LCP為3</li>
<li>接下來看後綴1，查表得到RK為2，找到RK為3的找LCP，得到2</li>
<li>看後綴2，與RK為4,5名找LCA，得到1</li>
<li>後綴3，看RK 1,2，LCA為1</li>
<li>接下來以此推累</li>
</ul>
<p>接下來有兩種不同設定方法，端看要採用的是上表還是下表的字串排序方法。我以上表為例，程式執行時印出順序：$3211000$；也可以採用後綴數組排序後的結果（一般都採用此方法），直接對應出順序（對照的是下表）：$3120100$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">LCP</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n,<span class="number">0</span>)</span>,<span class="title">lcp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)rk[sa[i]] = i;      <span class="comment">//利用sa反函數得到rk</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        <span class="keyword">if</span>(rk[i] == n<span class="number">-1</span>)<span class="keyword">continue</span>;   <span class="comment">//rk[n-1]未定義</span></span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]+<span class="number">1</span>];        <span class="comment">//下一名後綴從何開始</span></span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;</span><br><span class="line">        lcp[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>時間複雜度：</strong> 主要觀察 $k$ 的變化，$k$ 最多就是n，最少是0，最差的情況是 $k$ 被減掉 $n$ 次，加上 $2n$ 次，因此複雜度是線性 $O(n)$！</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>字串演算法</category>
      </categories>
      <tags>
        <tag>演算法</tag>
        <tag>字串</tag>
      </tags>
  </entry>
  <entry>
    <title>字串演算法例題 (String)</title>
    <url>/string2/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>NEOJ 266 溫力的故事</li>
<li>NEOJ 265 欸迪的字串</li>
<li>NEOJ 267 自動完成系統</li>
<li>NEOJ 264 欸迪的字串</li>
<li>ZJ d518: 文字抄寫 II</li>
<li>TIOJ 1306 字串中的字串</li>
<li>TIOJ 1321 好多回文 ndromePali</li>
<li>ZJ d978: 最长回文字串</li>
<li>TIOJ 1725 Massacre at Camp Happy</li>
<li>TIOJ 1497 喝醉的宿主 The drunk host</li>
<li>TIOJ 1515 Problem E. 似曾相識<span id="more"></span>
</li>
</ul>
<h3 id="NEOJ-266-溫力的故事"><a href="#NEOJ-266-溫力的故事" class="headerlink" title="NEOJ 266 溫力的故事"></a>NEOJ 266 溫力的故事</h3><p><a href="https://neoj.sprout.tw/problem/266/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179031/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你n個字串m筆詢問一個字串，對每一筆詢問輸出詢問在n個字串中出現的次數。</p>
</blockquote>
<p>這一題在<strong>隨機算法</strong>做過，今天用字典樹Trie做一次。在隨機算法中，透過Rolling Hash的公式，對每一個字串生成一個值，利用這個值查詢出現的次數。如果我們用Trie的話，則是建立一棵指標樹，透過走法這一棵字典樹得知詢問字串出現的次數！</p>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span>        <span class="comment">//利用指標建立一棵樹</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];    <span class="comment">//對應a-z每一條邊</span></span><br><span class="line">    <span class="keyword">int</span> cnt;        <span class="comment">//字串出現次數</span></span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">cnt</span>(<span class="number">0</span>)&#123; <span class="comment">//初始設定</span></span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie* root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">char</span> temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;           <span class="comment">//從根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])     <span class="comment">//如果樹上無此字元則new</span></span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*s)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];   <span class="comment">//繼續造訪Trie</span></span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;cnt += <span class="number">1</span>;              <span class="comment">//字串出現次數(字串對應唯一葉節點)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;              <span class="comment">//查找字串s</span></span><br><span class="line">    Trie *ptr = root;           <span class="comment">//根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;                  <span class="comment">//無此字串，回傳次數0</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];</span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;cnt;            <span class="comment">//回傳字串出現次數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">105</span>];cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">105</span>];cin&gt;&gt;s;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">find</span>(s)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NEOJ-265-欸迪的字串"><a href="#NEOJ-265-欸迪的字串" class="headerlink" title="NEOJ 265 欸迪的字串"></a>NEOJ 265 欸迪的字串</h3><p><a href="https://neoj.sprout.tw/problem/265/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179036/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你字串S和字串T，求出S在T中出現的位置</p>
</blockquote>
<p>這一題在<strong>隨機演算法</strong>也有出現過，當時是用Rolling Hash的方式透過扣掉Hash的方法比對字串是否相同（推一下公式就知道）。現在要用的是<strong>KMP演算法</strong>，很複雜不好想。</p>
<p>比較一下隨機跟KMP的時間，下方為KMP，上方則是隨機算法，兩者時間差了將近1倍，雖然兩者都可以在O(|T|)時間內進行匹配，但是建立Rolling Hash的常數是比較大的！<br><img src="https://i.imgur.com/a7CPjyi.png" alt=""></p>
<h4 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">KMP_match</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F,<span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;            <span class="comment">//回傳匹配相同地方</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;                 <span class="comment">//紀錄短字串有多少被匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)&#123;      <span class="comment">//每一迴圈都讓T[i]被匹配到</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=T[i])</span><br><span class="line">            p = F[p];           <span class="comment">//使T[i]一定可以被匹配到</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == T[i])</span><br><span class="line">            p += <span class="number">1</span>;             <span class="comment">//T的第i個與S的p+1可以匹配</span></span><br><span class="line">        <span class="keyword">if</span>(!S[p+<span class="number">1</span>])&#123;            <span class="comment">//S[p]已經匹配完成</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-p); <span class="comment">//回推匹配開頭</span></span><br><span class="line">            p = F[p];           <span class="comment">//繼續下一輪匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(|S|)要配對的字串以及Fail Function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_build</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = F[<span class="number">0</span>] = <span class="number">-1</span>;              <span class="comment">//初始設定為-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;          <span class="comment">//1到接下來字元</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=S[i])</span><br><span class="line">            p = F[p];               <span class="comment">//無法繼續配對，尋找更短字串</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == S[i])          <span class="comment">//配對成功(如都沒有一樣的就-1)</span></span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        F[i] = p;                   <span class="comment">//設定F[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">char</span> S[N],T[N];     <span class="comment">//詢問短字串、長在串</span></span><br><span class="line">    <span class="keyword">int</span> F[N];           <span class="comment">//失敗函數</span></span><br><span class="line">    cin&gt;&gt;S&gt;&gt;T;</span><br><span class="line">    <span class="built_in">KMP_build</span>(S,F);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">KMP_match</span>(S,F,T);</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,ans.<span class="built_in">size</span>()<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NEOJ-267-自動完成系統"><a href="#NEOJ-267-自動完成系統" class="headerlink" title="NEOJ 267 自動完成系統"></a>NEOJ 267 自動完成系統</h3><p><a href="https://neoj.sprout.tw/problem/267/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179148/">Submission</a></p>
<blockquote>
<p>題目敘述<br><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2015/round-1/problems/B">點這裡</a>有FB Hacker Cup的原題連結，簡單來說就是想像手機的自動填入系統，每加入一個字串會記錄到資料庫中，當資料庫裡面沒有相同前綴的字串時就輸出前綴長度。</p>
</blockquote>
<p>用字典樹Trie插入每一個字串，插入過程中返回從頭到開始new新的節點之間經過的節點樹，代表需要輸入多少個字元才能觸發自動完成系統。這一題是基礎的Trie應用。</p>
<h4 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie *root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(*S)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f)step++;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*S)])&#123;</span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*S)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*S)];</span><br><span class="line">        S++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Trie *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;c[i])&#123;</span><br><span class="line">            <span class="built_in">clear</span>(s-&gt;c[i]);</span><br><span class="line">            <span class="keyword">delete</span> s-&gt;c[i];</span><br><span class="line">            s-&gt;c[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;S;</span><br><span class="line">            step +=<span class="built_in">insert</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;step&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NEOJ-264-欸迪的字串"><a href="#NEOJ-264-欸迪的字串" class="headerlink" title="NEOJ 264 欸迪的字串"></a>NEOJ 264 欸迪的字串</h3><p><a href="https://neoj.sprout.tw/problem/264/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179060/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你字串S，求一個最短字串T的長度，滿足經由複製若干次後接起來會是字串S。</p>
</blockquote>
<p>這一題在一開始看到感覺好難，不過在慢慢理解 Z_Algorithm 之後，在講義中發現到這個問題也可以用這個演算法來解決！因為Z函數是滿足從i開始的最長前綴，因此當 $i$ 為 字串長度 $n$ 的因數的時候，只要 $i+Z[i+1]=n$ 成立，就必定可以用 $S[1:i]$ 組成字串 $S$ 。實作上要注意字串是0-base，i+1就相等於字串第i個位置，處理上要特別注意！</p>
<h4 id="程式碼-3"><a href="#程式碼-3" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *Z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(Z[i-l],r-i));</span><br><span class="line">        <span class="keyword">while</span>(S[Z[i]]&amp;&amp;S[Z[i]] == S[i+Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">char</span> s[N];cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> Z[N],n = <span class="built_in">strlen</span>(s),ans = n;</span><br><span class="line">    <span class="built_in">Z_algo</span>(s,Z);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span> &amp;&amp; i+Z[i]==n)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-d518-文字抄寫-II"><a href="#ZJ-d518-文字抄寫-II" class="headerlink" title="ZJ d518: 文字抄寫 II"></a>ZJ d518: 文字抄寫 II</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d518">題目連結</a></p>
<blockquote>
<p>題目敘述<br>若這個字串之前已經出現過，則輸出的出現號碼，若沒有則輸出它將被編寫的號碼.</p>
</blockquote>
<p>裸題Trie，不過要注意每一次要重置，將所有的實體Delete掉。</p>
<h4 id="程式碼-4"><a href="#程式碼-4" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> ind;</span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">ind</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie* root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">char</span> temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Trie *cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;c[i])&#123;</span><br><span class="line">            <span class="built_in">clear</span>(cur-&gt;c[i]);</span><br><span class="line">            <span class="keyword">delete</span>[] cur-&gt;c[i];</span><br><span class="line">            cur-&gt;c[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;           <span class="comment">//從根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])     <span class="comment">//如果樹上無此字元則new</span></span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*s)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];   <span class="comment">//繼續造訪Trie</span></span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;ind = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;              <span class="comment">//查找字串s</span></span><br><span class="line">    Trie *ptr = root;           <span class="comment">//根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;                  <span class="comment">//無此字串，回傳次數0</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];</span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;ind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans,cur_id = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">char</span> s[N];<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">            ans = <span class="built_in">find</span>(s);</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;New! %d\n&quot;</span>,cur_id);</span><br><span class="line">                <span class="built_in">insert</span>(s,cur_id);</span><br><span class="line">                cur_id += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Old! %d\n&quot;</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1306-字串中的字串"><a href="#TIOJ-1306-字串中的字串" class="headerlink" title="TIOJ 1306 字串中的字串"></a>TIOJ 1306 字串中的字串</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1306">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/263572">Submission</a></p>
<blockquote>
<p>題目敘述<br>裸字串匹配。對於每個詢問輸出 $S$ 在 $T$ 中出現過幾次。</p>
</blockquote>
<p>裸KMP字串匹配，統計出現次數。可以嘗試不要看資料自己寫一次，會更了解KMP算法！</p>
<h4 id="程式碼-5"><a href="#程式碼-5" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n,F[N];;</span><br><span class="line"><span class="keyword">char</span> T[N],S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP_match</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">char</span> *T,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=T[i])</span><br><span class="line">            p = F[p];</span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == T[i])</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!S[p+<span class="number">1</span>])&#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            p = F[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_build</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = F[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=S[i])</span><br><span class="line">            p = F[p];</span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == S[i])</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        F[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(F));</span><br><span class="line">        cin&gt;&gt;S;</span><br><span class="line">        <span class="built_in">KMP_build</span>(S,F);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">KMP_match</span>(S,T,F)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;T&gt;&gt;n;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1321-好多回文-ndromePali"><a href="#TIOJ-1321-好多回文-ndromePali" class="headerlink" title="TIOJ 1321 好多回文 ndromePali"></a>TIOJ 1321 好多回文 ndromePali</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1321">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/263962">Submission</a></p>
<blockquote>
<p>題目敘述<br>給一個長度 ≤ $10^6$ 的字串 A，問有幾種把該字串的某前綴搬到最後面的方法，使得最後的字串為回文。<br>(提示:可以用類似 Z 函數的概念計算出以某字元為中心的最長回文長度。)</p>
</blockquote>
<p>這一題搞得我快掛了QQQ。為什麼呢？看看以下照片就知道了：</p>
<p><img src="https://i.imgur.com/i8Gx5Yo.png" alt=""></p>
<p>根據上面的「提示」，要用類似Z函數的概念把以某點為中心的最長回文算出來。一個Naive裸的作法，把用 $O(n)$ 枚舉每一個點為分割點，把分割點前面的子字串接到後面，用 $O(n)$ 的時間看是否為一回文字串。如此一來時間複雜度為 $O(n^2)$ ，對這一題來說顯然是不可行的，因為字串長度達到 $10^6$！</p>
<p>當我們用Manacher’s Algorithm $O(n)$ 的時間每一個字元的最大回文之後，就可以枚舉每一個可以作為分割點的地方，檢查回文的狀況。討論分割點在前半部分的情況下，也就是把短的（長度小於一半）前綴搬到後面的狀況。當分割的索引值為 $i$ ，必須保證 $s[0:i]$ 跟 $s[i:2i]$ 對稱，移到字串尾巴才能成為回文。除此之外，也必須滿足 $Z[mid+i] = mid-i$ 的情況，以就是剩下不是分割點兩側的字串必須是回文，把前綴接到後面之後才能對稱！</p>
<p>實作上很多細節，我DEBUG超久最後才想到不能枚舉所有字元，會出事（就像上面的三色WA），只要枚舉以 $’.’$ 為分割點的情況（分割在字元上就不行），還有很多細節，WA很多次才會知道XD</p>
<h4 id="程式碼-6"><a href="#程式碼-6" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,Z[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">2</span>*N],T[N];</span><br><span class="line"><span class="comment">//T原字串、S插入點字串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Longest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(T);m = <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(S,<span class="string">&#x27;.&#x27;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)S[<span class="number">2</span>*i+<span class="number">1</span>] = T[i];</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[<span class="number">2</span>*l-i],r-i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i-Z[i]&gt;=<span class="number">0</span> &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="built_in">Longest</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)Z[i]--;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (m<span class="number">-1</span>)/<span class="number">2</span>,i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Z[mid] == mid)ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;mid;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[i] == i &amp;&amp; Z[mid+i] == mid-i)&#123;</span><br><span class="line">            ans[(i/<span class="number">2</span>)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;m;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[i] == m-i<span class="number">-1</span> &amp;&amp; Z[i-mid] == i-mid)&#123;</span><br><span class="line">            ans[(i/<span class="number">2</span>)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(ans[i])sum++;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;none&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(ans[i])cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-d978-最长回文字串"><a href="#ZJ-d978-最长回文字串" class="headerlink" title="ZJ d978: 最长回文字串"></a>ZJ d978: 最长回文字串</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d978">題目連結</a></p>
<blockquote>
<p>題目敘述<br>題目即題意，給你一個字串，求出最長的回文字串長度為何？</p>
</blockquote>
<p>一題LPS的裸題，用Manacher’s Algorithm可以將時間複雜度做到 $O(n)$！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,Z[<span class="number">2</span>*N],t;</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">2</span>*N],T[N];</span><br><span class="line"><span class="comment">//T原字串、S插入點字串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Longest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(T);m = <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(S,<span class="string">&#x27;.&#x27;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)S[<span class="number">2</span>*i+<span class="number">1</span>] = T[i];</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[<span class="number">2</span>*l-i],r-i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i-Z[i]&gt;=<span class="number">0</span> &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;T;</span><br><span class="line">        <span class="built_in">Longest</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> z = (Z[i]<span class="number">-1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,z);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1725-Massacre-at-Camp-Happy"><a href="#TIOJ-1725-Massacre-at-Camp-Happy" class="headerlink" title="TIOJ 1725 Massacre at Camp Happy"></a>TIOJ 1725 Massacre at Camp Happy</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1725">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/264017">Submission</a></p>
<blockquote>
<p>題目敘述：<br>定義字串 A 和 B「k-幾乎相同」代表把字串 A 的前 k 字元搬到最後面時，與 B 恰有一個字元相異。給你兩個長度 ≤ $10^6$ 的字串 A 和 B，求所有使 A 和 B「k-幾乎相同」成立的 k 值。</p>
</blockquote>
<p>這一題好特別，一樣要用 $O(n)$ 的時間求出答案，對於每一個操作將前k個字元搬到後面，只能用 $O(1)$ 算出來到底符不符合一字元相異的條件。<br>以兩個相等長度的字串 $A,B$ 為例，長度為 $l$，假設 $A=aabba,B = aacba$，兩者相差一個字元的情況下，必定會滿足$l = LCP(A,B)+LCP(rev(A),rev(B))+1$，其中rev函數表示reverse。</p>
<p>我們要做的就是在 $O(1)$ 的時間內求出LCP，因為題目的字串 $A$ 要求不同的起始位置，因此我們假設一個非常特別的字串 $B@AA$ ，其中@為任意沒出現過的字元。只要計算這一個字串的Z函數，就表示了 $A$ 和 $B$ 的最長共同前綴，需要兩個A的原因是因為模擬不同的k-位移下情形。</p>
<p><img src="https://i.imgur.com/5Ir8Hjt.png" alt=""></p>
<div class="note success">
            <p><strong>實作小細節</strong><br>程式碼的第42行可以試著推推看逆序之後的尾巴的索引值為何。我是利用列出幾個數字之後推出來的，不過應該可以寫成比較嚴謹的數學證明！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Z1[n+<span class="number">1</span>+i]+Z2[<span class="number">2</span>*n-i+<span class="number">1</span>]+<span class="number">1</span> == n</span><br></pre></td></tr></table></figure>
          </div>
<h4 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>$O(n)$ 建立z函數，$O(n)$ 枚舉每一個起始點，總時間為 $O(n)$。</p>
<h4 id="程式碼-7"><a href="#程式碼-7" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,Z1[<span class="number">3</span>*N],Z2[<span class="number">3</span>*N];</span><br><span class="line"><span class="keyword">char</span> A[<span class="number">3</span>*N],B[<span class="number">3</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo</span><span class="params">(<span class="keyword">int</span> *z,<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(z[i-l],r-i),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(S[i+z[i]] &amp;&amp; S[z[i]] == S[i+z[i]])&#123;</span><br><span class="line">            l = i;r = i+z[i];</span><br><span class="line">            z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    m = <span class="number">3</span>*n+<span class="number">1</span>;</span><br><span class="line">    B[n] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    <span class="comment">//正常序列求Z value</span></span><br><span class="line">    <span class="built_in">rep</span>(i,n+<span class="number">1</span>,<span class="number">2</span>*n)B[i] = A[i-n<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">3</span>*n)B[i] = A[i<span class="number">-2</span>*n<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">Z_algo</span>(Z1,B);</span><br><span class="line">    <span class="comment">//逆序求Z value</span></span><br><span class="line">    <span class="built_in">reverse</span>(B,B+n);<span class="built_in">reverse</span>(B+n+<span class="number">1</span>,B+m);</span><br><span class="line">    <span class="built_in">Z_algo</span>(Z2,B);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z1[n+<span class="number">1</span>+i]+Z2[<span class="number">2</span>*n-i+<span class="number">1</span>]+<span class="number">1</span> == n)vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TAK&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NIE&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[0,n-1][n,n][n+1,2n][2n+1,3n]</span></span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1497-喝醉的宿主-The-drunk-host"><a href="#TIOJ-1497-喝醉的宿主-The-drunk-host" class="headerlink" title="TIOJ 1497 喝醉的宿主 The drunk host"></a>TIOJ 1497 喝醉的宿主 The drunk host</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1497">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/264189">Submission</a></p>
<blockquote>
<p>題目敘述<br>裸後綴數組。</p>
</blockquote>
<p>後綴數組我看了好久（大概有4天吧），一直對著它發呆，不知道它的精髓到底在哪裡。。剛好又遇到開學，不能整天快樂寫題XD</p>
<h4 id="倍增優化"><a href="#倍增優化" class="headerlink" title="倍增優化"></a>倍增優化</h4><p>對著螢幕發呆的日子終於結束了，直到我看了<a href="https://oi-wiki.org/string/sa/">這一篇</a>（雖然說我前幾天也有看但看不懂，可能是消化的天數不夠多吧），尤其是裡面的一張圖，深刻說明了倍增的精髓。</p>
<p>後綴數組求法就不多解釋（上面有），放幾個實作上的小細節。</p>
<div class="note primary">
            <p><strong>實作小細節</strong><br>我們要求進行 $O(\log n)$ 層的倍增，可以使用C++內建的log10()再用ceil去處理，但顯然有點慢，如果套用以下函數，它會回傳數字二進位之後最大的1前面總共有多少個0（前綴0的數量），與32相減（32是long long的關係）就是我們要的log的次數。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lg = __builtin_clz(n)</span><br></pre></td></tr></table></figure><p>另外一個小小細節，就是在字串的後半部分，如果跟前面一樣倍增一個比較大的數字，有可能會超出範圍，這時候初始值就很重要了！初始設定rk[n] = -1，導致任何只要超出範圍的都會取到這個-1，表示只要後面沒有字串、如果前面都相同但長度比較長的字串比起來，較短的會排在比較前面的位置！</p>
          </div>
<p>這個算法是 $O(n\log^2 n)$，TIOJ這一題可以過，不過到<a href="https://www.spoj.com/problems/SARRAY/">SPOJ</a>就會被卡TLE</p>
<blockquote>
<p>$O(n^2 log(n))$ is expected to score about 20-30. (Naive sorting all suffixes)<br>$O(n log^2(n))$ is expected to score about 40. (OK for most programming contest problems)<br>$O(n log n)$ is expected to score about 60-70. (Use counting sort for small alphabet size)<br>$O(n)$ without tweaks is expected to score about 80-90.<br>$O(n)$ with tweaks is expected to score 100. (This is meant for fun only :)</p>
</blockquote>
<p>越後面就越毒瘤XD</p>
<blockquote>
<p>test 1 - AC (score=0.000000, sig=0, time=0.009123, mem=5372)<br>test 2 - AC (score=0.000000, sig=0, time=0.006427, mem=5508)<br>test 3 - AC (score=0.000000, sig=0, time=0.014975, mem=5468)<br>test 4 - AC (score=0.000000, sig=0, time=0.031332, mem=5536)<br>test 5 - AC (score=0.000000, sig=0, time=0.026948, mem=5456)<br>test 6 - AC (score=0.000000, sig=0, time=0.023113, mem=5396)<br>test 7 - TLE (score=0.000000, sig=0, time=0.210000, mem=7340)<br>test 8 - TLE (score=0.000000, sig=0, time=0.210000, mem=7152)<br>test 9 - AC (score=0.000000, sig=0, time=0.170094, mem=7284)<br>test 10 - AC (score=0.000000, sig=0, time=0.140098, mem=7340)</p>
</blockquote>
<h4 id="程式碼-8"><a href="#程式碼-8" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==b.x &amp;&amp; y==b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一位、第二位比較以及後綴編號</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);</span><br><span class="line">    <span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    string S;<span class="built_in">getline</span>(cin,S);</span><br><span class="line">    <span class="built_in">suffix_array</span>(S);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Radix-Sort-優化"><a href="#Radix-Sort-優化" class="headerlink" title="Radix Sort 優化"></a>Radix Sort 優化</h4><p><a href="https://tioj.ck.tp.edu.tw/submissions/264407">Submission</a></p>
<p>比較一下 $O(n\log^2 n)$ 以及 $O(n\log n)$ 的時間，兩者花了近兩倍的時間差距。看了一下這一題的TopCoder，竟然可以做到十位數毫秒！如果要繼續優化成線性 $O(n)$ 的複雜度，就會使用到 DC3 的演算法，雖然好像很複雜不實用QQ</p>
<p><img src="https://i.imgur.com/tQph2uA.png" alt=""></p>
<p><img src="https://i.imgur.com/1wcKazZ.png" alt=""></p>
<p><img src="https://i.imgur.com/i4WSvw8.png" alt=""></p>
<p>使用 $O(n\log^2n)$ 的算法會TLE第八、九筆測資，不過使用基數排序就可以AC了！</p>
<blockquote>
<p>test 1 - AC (score=0.000000, sig=0, time=0.006565, mem=6048)<br>test 2 - AC (score=0.000000, sig=0, time=0.006594, mem=6300)<br>test 3 - AC (score=0.000000, sig=0, time=0.012431, mem=7860)<br>test 4 - AC (score=0.000000, sig=0, time=0.012267, mem=7208)<br>test 5 - AC (score=0.000000, sig=0, time=0.011158, mem=6804)<br>test 6 - AC (score=0.000000, sig=0, time=0.012057, mem=7892)<br>test 7 - AC (score=0.000000, sig=0, time=0.140876, mem=17720)<br>test 8 - AC (score=0.000000, sig=0, time=0.077631, mem=21952)<br>test 9 - AC (score=0.000000, sig=0, time=0.074905, mem=21340)<br>test 10 - AC (score=0.000000, sig=0, time=0.076732, mem=30160)</p>
</blockquote>
<h4 id="程式碼-9"><a href="#程式碼-9" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==b.x &amp;&amp; y==b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一位、第二位比較以及後綴編號</span></span><br><span class="line">vector&lt;pt&gt; temp,box[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)box[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raddix_sort</span><span class="params">(vector&lt;pt&gt; &amp;cur)</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i].y == <span class="number">-1</span>)temp.<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">        <span class="keyword">else</span> box[cur[i].y].<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)box[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        box[temp[i].x].<span class="built_in">push_back</span>(temp[i]);</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])cur.<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);<span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        rk[cur[i].id] = (cur[i]==cur[i<span class="number">-1</span>])?rk[cur[i<span class="number">-1</span>].id]:i;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;rk[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;                <span class="comment">//進行O(lgn)次</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">raddix_sort</span>(cur);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)            <span class="comment">//倍增pair的second</span></span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">raddix_sort</span>(cur);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    string S;<span class="built_in">getline</span>(cin,S);</span><br><span class="line">    <span class="built_in">suffix_array</span>(S);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1515-Problem-E-似曾相識"><a href="#TIOJ-1515-Problem-E-似曾相識" class="headerlink" title="TIOJ 1515 Problem E. 似曾相識"></a>TIOJ 1515 Problem E. 似曾相識</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1515">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/264483">Submission</a></p>
<blockquote>
<p>題目敘述<br>裸後綴數組 LCP。</p>
</blockquote>
<p>這題我想好久，一直想不通轉移的條件以及k-1的原因，不過最後還是想通了！這一題只要把 $lcp$ 求出來之後，找最大值就是題目要求的答案。</p>
<h4 id="程式碼-10"><a href="#程式碼-10" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==b.x &amp;&amp; y==b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一位、第二位比較以及後綴編號</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);</span><br><span class="line">    <span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">LCP</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n,<span class="number">0</span>)</span>,<span class="title">lcp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)rk[sa[i]] = i;      <span class="comment">//利用sa反函數得到rk</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        <span class="keyword">if</span>(rk[i] == n<span class="number">-1</span>)<span class="keyword">continue</span>;   <span class="comment">//rk[n-1]未定義</span></span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]+<span class="number">1</span>];        <span class="comment">//下一名後綴從何開始</span></span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;</span><br><span class="line">        lcp[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;cin.<span class="built_in">ignore</span>();</span><br><span class="line">    string S;<span class="built_in">getline</span>(cin,S);</span><br><span class="line">    <span class="built_in">suffix_array</span>(S);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; lcp = <span class="built_in">LCP</span>(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)ans = <span class="built_in">max</span>(lcp[i],ans);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>字串演算法跟最短路徑、計算幾何比起來，數學推導成分就多了很多，有許多的遞迴概念，例如失敗函數以及z函數的概念，也有很多是要理解在不同條件下做什麼事，以及其他優化處理。最初的是字典樹Trie，就是一些資料結構的運用；接下來的KMP、Z Algorithm以及LPS就很吃觀念，追蹤整個程式的過程。最後是後綴數組，在這邊卡了超久，遲遲無法理解倍增的概念、以及LCP的作法。可能這就是頓悟吧，每天看了同篇解說很久之後，總有一天會突然頓悟，想到演算法的精髓！</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>字串演算法</category>
      </categories>
      <tags>
        <tag>演算法</tag>
        <tag>字串</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路徑例題（Shortest Path Problem）</title>
    <url>/path2/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>可魚果運輸問題</li>
<li>百慕達三角洲</li>
<li>江神與他的小火車</li>
<li>貨物運送計劃</li>
<li>E.漢米頓的麻煩</li>
<li>旅遊規劃問題</li>
<li>Codeforces 543B: Destroying Roads<span id="more"></span>
</li>
</ul>
<h3 id="可魚果運輸問題"><a href="#可魚果運輸問題" class="headerlink" title="可魚果運輸問題"></a>可魚果運輸問題</h3><p><a href="https://neoj.sprout.tw/problem/391/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178079/">Dijkstra’s Algorithm</a><br><a href="https://neoj.sprout.tw/challenge/178078/">SPFA</a><br>這一題的來源是NPSC2013的題目，題目大意如下：</p>
<blockquote>
<p>有n個城市m個運輸方案，每個方案 $P_i$ 會從一個固定的起始城市 $A_i$ 運送東西到另一個固定的終點城市 $B_i$，每運輸一件物品，就必須付 $C_i$ 價錢。若用方案 $P_i$ 運輸了超過 $D_i$ 件物品，多出來的部份每件物品收 $C_i’$ 元。共要運輸 $f$ 物品。<br>求起點 $s$ 到終點 $e$ 的最短路徑。</p>
</blockquote>
<p>當運輸總量超過 $D_i$ 件物品，表示可以使用更小的邊權重去計算接下來的費用。這時候我們可以了解到一個性質，如果我把全部的物品全部集中在一條路徑運送，因為送的越多，相對的在費用上就可能產生優惠，比分散多條路徑的運送花費來的小。因為總共要運送 $f$ 件物品，因此會將邊的權重設定為當 $f$ 件物品都經過這一條邊時，所要花費的價格。</p>
<p>有了邊以及價格之後，便可開始進行最短路徑的演算法。因為題目範圍 $N≤100$ ，因此用Dijkstra’s 或是 SPFA 都可以做（Bellman-Ford就先不要XD）。</p>
<h4 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h4><p>這篇有<a href="http://www-m3.ma.tum.de/foswiki/pub/MN0506/WebHome/dijkstra.pdf">一篇論文</a>是Dijkstra在針對最短路徑寫的論文（也就是以他名字命名的演算法論文），這篇只有三頁耶！<br>以下是「演算法導論」這本書中演算法的虛擬碼：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">  1  INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">  2    S &lt;- Ø</span><br><span class="line">  3    Q &lt;- V[G]</span><br><span class="line">  4    while Q ≠ Ø</span><br><span class="line">  5        do u &lt;- EXTRACT-MIN(Q)</span><br><span class="line">  6            S &lt;- S ∪ &#123;u&#125;</span><br><span class="line">  7            for each vertex v ∈ Adj[u]</span><br><span class="line">  8                do RELAX(u,v,w)</span><br></pre></td></tr></table></figure>
<p>其中集合 $S$ 在程式碼中代表的是visit，而集合 $Q$ 因為要操作取出最小元素的動作，因此會用priority_queue實現，以heap來進行 $O(\log n)$ 的插入以及取出。</p>
<p>這裡面使用$visit$判斷是否在集合 $S$ 中，但我們可以發現，如果在priority_queue中有兩個點的存在，第一個點處理完被加入集合 $S$ 中之後，第二次再次被拿出來進行處理時就不會有任何相鄰的點再一次被處理，這是因為第一次與第二次更新所使用的 $dis[cur]$ 是一樣的。因此，當一個點已經在visit中（也就是在集合 $s$ 中），我們可以直接換下一個點去執行（不過如果忘了visit也是沒差啦）。</p>
<div class="note default">
            <p><strong>複雜度分析</strong></p><p>以下分析一下演算法時間複雜度，總共有兩個時間複雜度，取決於使用何種資料結構來實作。</p><p><strong>1. 時間複雜度 $O(V^2+E)$</strong><br>首先是每一個點執行 $V$ 次對每一個相鄰的點進行更新，每一輪執行 $O(V)$ 尋找目前距離 $dis$ 最小的點。總共有 $E$ 條邊需要更新，因此最後要把 $E$ 再加上去。這樣總複雜度就會 $V\times O(V)+O(E) = O(V^2+E)$。此實作方式一般在稠密的圖中會有比較好的表現。<br><br></p><p><strong>2. 時間複雜度 $O((V+E)\log V)$</strong><br>這一題在 $O(n)$ 爆搜尋找改用heap去優化，因此複雜度就會是一樣執行V 輪利用 $O(logV)$ 找到距離 $dis$ 最小的點，同時將更新後的點放進heap中，我們知道放入heap的複雜度也是 $O(\log n)$，因此複雜度就會變成 $O(V\log V)+O(E\log V) = O((V+E)\log V)$。此實作方式一般在稀疏的圖中會有比較好的表現，從 $V$ 與 $E$ 的大小估計可以大致發現。</p>
          </div>
<p>以下是程式法的實作，最需要注意的地方是pair的first跟second儲存的東西。在存圖時會使用（點,權重）搭配vector；而在priority_queue中，因為要對權重進行比較，因此會用（權重,點），需要特別注意別搞混了!</p>
<div class="note success">
            <p><strong>Priority_Queue實作細節</strong></p><p>預設的priority_queue會pop出目前heap中最大的元素（預設是less&lt;&gt;函數），如果要實作一個min heap 的話要使用greater&lt;&gt;函數，同時第二個傳進函數的參數要用一個vector！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;Type, vector&lt;Type&gt;, ComparisonType &gt; min_heap;</span><br><span class="line">priority_queue &lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;   </span><br></pre></td></tr></table></figure>
          </div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pii&gt; edge[N];                <span class="comment">//存圖</span></span><br><span class="line">    <span class="keyword">int</span> n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dis[N];<span class="built_in">fill</span>(dis,dis+N,<span class="number">1e16</span>);</span><br><span class="line">    <span class="keyword">bool</span> visit[N];                     <span class="comment">//城市數n、方案數m、s起、e終、f箱數</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;</span><br><span class="line">        <span class="comment">//一條由a連到b的邊，權重c，流量超過d，則改權重c</span></span><br><span class="line">        <span class="keyword">int</span> val = (f&gt;d?c*d+e*(f-d):c*f);</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Dijkstra</span></span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;    <span class="comment">//(距離,點)</span></span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visit[cur])<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first,weight = i.second;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dis[cur]+weight&lt;dis[next])&#123;</span><br><span class="line">                dis[next] = dis[cur]+weight;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[next],next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[e]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Shortest-Path-Faster-Algorithm-SPFA"><a href="#Shortest-Path-Faster-Algorithm-SPFA" class="headerlink" title="Shortest Path Faster Algorithm(SPFA)"></a>Shortest Path Faster Algorithm(SPFA)</h4><p>這是一個使用queue最佳化的Bellman-Ford演算法，基本的使用方式跟BFS幾乎相同，在Bellman-Ford對邊進行更有效率的鬆弛(relaxation)。<br>以下一樣是「演算法導論」中Bellman-Ford的虛擬碼：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BELLMAN-FORD(G,w,s)</span><br><span class="line">  1    INITIALIZE-SINGLE-SOURCE(G,s)</span><br><span class="line">  2    for i &lt;- 1 to |V[G]|-1</span><br><span class="line">  3        do for each edge (u,v)∈ E[G]</span><br><span class="line">  4            do RELAX(u,v,w)</span><br><span class="line">  5    for each edge (u,v)∈ E[G]</span><br><span class="line">  6        do if d[v] &gt; d[u]+w(u,v)</span><br><span class="line">  7            then return FALSE</span><br><span class="line">  8    return TRUE</span><br></pre></td></tr></table></figure>
<p>以下是SPFA的虛擬碼，如果節點有被實際鬆弛過，且節點不在queue中（同樣元素在queue中出現兩次沒有意義，因為只要確保有在queue中等會會被更新到就好，到它的最短距離不會被改變），便將此節點推入queue中。裡面存的是帶進行鬆弛的節點們，也就是被剛剛更新過的節點。我們可以利用$visit[ ]$來 $O(1)$ 判斷節點是否有在queue中！</p>
<p>有進行判斷是否在queue中的（比較省空間一點）：<br><img src="https://i.imgur.com/vdtJWR2.png" alt=""><br>沒有進行判斷的，有被更新過就塞進去：<br><img src="https://i.imgur.com/fsorAoE.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shortest-Path-Faster-Algorithm(G, s)</span><br><span class="line">  1    for each vertex v ≠ s in V(G)</span><br><span class="line">  2        d(v) := ∞</span><br><span class="line">  3    d(s) := 0</span><br><span class="line">  4    offer s into Q</span><br><span class="line">  5    while Q is not empty</span><br><span class="line">  6        u := poll Q</span><br><span class="line">  7        for each edge (u, v) in E(G)</span><br><span class="line">  8            if d(u) + w(u, v) &lt; d(v) then</span><br><span class="line">  9                d(v) := d(u) + w(u, v)</span><br><span class="line"> 10                if v is not in Q then</span><br><span class="line"> 11                    offer v into Q</span><br></pre></td></tr></table></figure>
<p>SPFA有一個問題，他可以被出題目的人設計測資去卡這種算法，使時間複雜度變成糟糕的$O(V^2)$，因此一般來說會實作Dijkstra而非SPFA！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pii&gt; edge[N];                <span class="comment">//存圖</span></span><br><span class="line">    <span class="keyword">int</span> n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dis[N];<span class="built_in">fill</span>(dis,dis+N,<span class="number">1e16</span>);</span><br><span class="line">    <span class="keyword">bool</span> visit[N];                     <span class="comment">//城市數n、方案數m、s起、e終、f箱數</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;</span><br><span class="line">        <span class="comment">//一條由a連到b的邊，權重c，流量超過d，則改權重c</span></span><br><span class="line">        <span class="keyword">int</span> val = (f&gt;d?c*d+e*(f-d):c*f);</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SPFA</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    visit[s] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        visit[cur] = <span class="number">0</span>;                <span class="comment">//pop出來將狀態改成不在queue中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first,weight = i.second;</span><br><span class="line">            <span class="keyword">if</span>(dis[next] &gt; dis[cur]+weight)&#123;</span><br><span class="line">                dis[next] = dis[cur]+weight;</span><br><span class="line">                <span class="keyword">if</span>(!visit[next])que.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[e]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="百慕達三角洲"><a href="#百慕達三角洲" class="headerlink" title="百慕達三角洲"></a>百慕達三角洲</h3><p><a href="https://neoj.sprout.tw/problem/393/">題目連結</a></p>
<blockquote>
<p>題目大意：<br>給定一張長n寬m的矩形圖，由”#”和”.”組成，給定起點$(x_1,y_1)$以及終點$(x_2,y_2)$，必須最小化經過”.”的次數，求最少需幾過幾次。</p>
</blockquote>
<p>當下看到這一個題目的想法，就是跟處理一般的圖論題目一樣，將邊用vector儲存起來，將經過”.”的權重設為很大的一個數字，這樣用Dijkstra做一次最短路徑就可以找出經過”.”最小化的次數了！</p>
<p>以下是MLE的<a href="https://neoj.sprout.tw/challenge/178136/">Submission</a><br><img src="https://i.imgur.com/9ZaisdZ.png" alt=""><br>吃了開心的MLE，如果當成一般的圖在處理，不管是在 $dis$ 開long long的處裡，或是開了一個vector陣列儲存邊，都非常的消耗空間。因此，我詢問了一下電神這一題的想法，他說我的想法用Dijkstra是正確的，不過在設定邊權的部分可以直接用0跟1代替，而且可以用queue去輔助實作BFS（要說它也可以是Dijkstra的另一種比較簡單的版本）。</p>
<p><img src="https://i.imgur.com/9JldAha.png" alt=""></p>
<p>這題也就是所謂<a href="https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/">0-1 BFS (Shortest Path in a Binary Weight Graph)</a>，或是<a href="https://codeforces.com/blog/entry/22276">這裡0-1 BFS</a>，想法可以說是Dijkstra跟BFS的綜合（其實它跟SPFA也很相似）。以下是實作步驟：</p>
<ol>
<li>建立雙向的佇列(deque)，等等要存放被relax過的點，初始放入起點</li>
<li>每一次從deque前方pop出一點，對那一點相鄰的所有點進行鬆弛</li>
<li>如果被鬆弛時的邊權重為0，將點push dequeue的前方</li>
<li>否則當鬆弛時的邊權重為1，將點push dequeue的後方</li>
<li>重複執行2-4步驟直到deque為空</li>
</ol>
<p>當我們一直利用deque最前端的元素進行鬆弛，因為我們將邊權為0的元素放入最前端，用距離最小的那些點進行鬆弛，每一個點最多會被鬆弛一次，因此總時間複雜度為$O(V+E)$，比起用Dijktra直接做$O((V+E)\log V)$快了許多（此演算法之所以正確是因為其中一邊的權重是0，不管0接到誰他的權重也都是0，有點像「從最小層逐漸擴展」的概念）！</p>
<div class="note success">
            <p>小問題（出處<a href="https://codeforces.com/blog/entry/22276">這裡</a>）</p><ol><li>Can we apply the same trick if our edge weights can only be 0 and x (x &gt;= 0) ?</li><li>Can we apply the same trick if our edge weights are x and x+1 (x &gt;= 0) ?</li><li>Can we apply the same trick if our edge weights are x and y (x,y &gt;= 0) ?</li></ol><p>解答YES,NO,NO</p>
          </div>
<p>這題之所以可行是因為有一邊的權重是0，當點皆以權重為0串再一起時，他會是最短的，使用最短去更新接下來的點，因此第一題是正確的！但第二題與第三題是錯誤的，考慮以下點與邊的情況：</p>
<p><img src="https://i.imgur.com/BYojGwm.jpg" alt=""></p>
<p>當我依照01BFS的方法不斷去用x更新其他的點，更新完之後會發現點1到點3的最短路徑應該是x+1，到時候又要再重新Relax一次，複雜度會爆炸喔（比SPFA可能還慘，因為當點三利用兩個x更新完之後，用它來做跟3所有相鄰的點，做完卻發現$(1,3)$有更短的距離，又必須重新全部更新一次！）總結來說，他只是用於只有兩種邊的情況，且其中一邊必須為0。</p>
<p><img src="https://i.imgur.com/wnXKbI8.png" alt=""></p>
<div class="note info">
            <p><strong>比較一下記憶體用量</strong><br>最主要還是時間複雜度的比較，不過既然空間已經爆了，時間也沒法比了QQ</p><p><strong>MLE</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N2 4000005</span></span><br><span class="line"><span class="keyword">int</span> n,m,q,predecessor[N2],dis[N2];</span><br><span class="line"><span class="keyword">bool</span> visit[N2],maze[N2];</span><br><span class="line">vector&lt;pii&gt;edge[N2];</span><br></pre></td></tr></table></figure><p><strong>AC</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2003</span></span><br><span class="line"><span class="keyword">int</span> n,m,dis[N][N];</span><br><span class="line"><span class="keyword">bool</span> visit[N][N],maze[N][N];</span><br></pre></td></tr></table></figure>
          </div>
<p>以下是使用deque實作01BFS的AC code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,dis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[N][N],maze[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&#x27;.&#x27;</span>)maze[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> maze[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;pii&gt;deq;</span><br><span class="line">    <span class="keyword">int</span> s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s1][s2] = <span class="number">0</span>;</span><br><span class="line">    deq.<span class="built_in">push_back</span>(&#123;s1,s2&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = deq.<span class="built_in">front</span>().first,y = deq.<span class="built_in">front</span>().second;</span><br><span class="line">        deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dis[nx][ny] &gt; dis[x][y]+maze[nx][ny])&#123;</span><br><span class="line">                dis[nx][ny] = dis[x][y]+maze[nx][ny];</span><br><span class="line">                <span class="keyword">if</span>(maze[nx][ny]==<span class="number">0</span>)deq.<span class="built_in">push_front</span>(&#123;nx,ny&#125;);</span><br><span class="line">                <span class="keyword">else</span> deq.<span class="built_in">push_back</span>(&#123;nx,ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[e1][e2]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="江神與他的小火車"><a href="#江神與他的小火車" class="headerlink" title="江神與他的小火車"></a>江神與他的小火車</h3><p><a href="https://neoj.sprout.tw/problem/431/">題目連結</a></p>
<blockquote>
<p>題目大意<br>已知有N個點以及M條邊，總共有Q筆詢問，每筆詢問有$\delta(a,b)$，表示新增一條由 $a$ 指向 $b$ 的邊（其權重為1），對每一筆詢問輸出從點 $1$ 到點 $N$ 的最短距離。</p>
</blockquote>
<p><img src="https://i.imgur.com/f96GUmd.jpg" alt=""></p>
<p>我們知道如果有用新加進來的邊 $\delta(a,b)$，則路徑可以被拆解成 $\delta(1,a)+\delta(a,b)+\delta(b,n)$。其中，我們可以用Dijkstra 一次尋找1到任何點的最短距離，那要如何處理路徑 $\delta(b,n)$ 呢？這就是<strong>單一目的最短距離問題</strong>，我們可以將所有的邊逆序，將終點做一次Dijkstra尋找最短路，這時候我們就可以用 $O(1)$ 的時間回答每一筆詢問，總時間複雜度：預處理$O((V+E)\log V)$，詢問 $O(Q)$。</p>
<div class="note info">
            <p><strong>測資小問題</strong><br>有一筆測資如下，藍線是給定的路徑與權重，紅色是新加入的邊，如果按照上面 $\delta(1,a)+\delta(a,b)+\delta(b,n)$ 我們可以計算出從起點到終點的最短距離為：$2+1+4 = 7$，很明顯兩點之間的最短距離是 $5$ ，但因為原本作法會經過一條$\delta (B,C)$ 的重邊，造成算出來的距離是比較大的！這時候我們只要對最短路徑長度取min即可，也就是說在這種情況加入這一條邊並不會影響最短路徑的長度！</p><blockquote><p>測資（1,2,3分別對應A,B,C）：<br>6 5 1<br>1 2 1<br>2 3 1<br>3 4 1<br>4 5 1<br>5 6 1<br>3 2</p></blockquote><p><img src="https://i.imgur.com/Uocw0hc.png" alt=""></p>
          </div>
<p>接下來是程式碼，之後如果遇到最短路徑的題目，一般來說會避免使用SPFA（除非有負邊），為了要避免最糟的時間複雜度，因此會使用Dijkstra來處理最短路徑問題！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;pii&gt; edge[<span class="number">2</span>][N];</span><br><span class="line"><span class="comment">//edge[0]-&gt;normal,edge[1]-&gt;opposite</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">bool</span> is_nor)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n+<span class="number">2</span>,<span class="number">1e16</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    </span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visit[cur])<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : edge[is_nor][cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first,weight = i.second;</span><br><span class="line">            <span class="keyword">if</span>(dis[next] &gt; dis[cur] + weight)&#123;</span><br><span class="line">                dis[next] = dis[cur] + weight;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[next],next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edge[<span class="number">0</span>][a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">        edge[<span class="number">1</span>][b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; normal,opposite;</span><br><span class="line">    normal = <span class="built_in">Dijkstra</span>(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    opposite = <span class="built_in">Dijkstra</span>(n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(normal[a]+opposite[b]+<span class="number">1</span>,normal[n])&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="貨物運送計劃"><a href="#貨物運送計劃" class="headerlink" title="貨物運送計劃"></a>貨物運送計劃</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1641">題目連結</a></p>
<blockquote>
<p>題目敘述<br>給定N個點M條邊，第i條邊有方邊率$C_i$，假設目前運送貨物重量p經過此邊，代表經過邊i會需要多增加 $p\times C_i$ 的重量。給定起點、終點，求到達終點時最少的貨物重量為多少。</p>
</blockquote>
<p>換種說法，題目要求的是每經過一條邊，就要乘上某一個數，要求到終點最小的重量。下圖是題目範例測資：<br><img src="https://i.imgur.com/BSNWgh8.png" alt=""></p>
<p>$\delta(1,2)\to\delta(2,3)$，所付出的代價是$(1\times (1+1))\times (2+1)=6$。如果是$\delta(1,3)$ 的話直接$1\times (4+1)=5$，可以觀察到，遇到邊就需要將原本的數字乘上$C_i+1$。</p>
<p>我們可以透過將邊權取 $\log$ 之後，就可以利用Dijkstra進行最短路徑的計算，因為取 $\log$ 後的加減運算等同於原本的乘法運算，只要最後把算出來的答案次方即可！</p>
<p>這一題的輸出要求科學記號（為了要避免浮點數誤差），以下程式碼來達成（要求小數點後兩位，同時次方部分要求整數3位）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2fe+%03lld\n&quot;</span>,<span class="built_in">pow</span>(<span class="number">10</span>,ans),x);</span><br></pre></td></tr></table></figure>
<p>程式碼的部分，透過$edge$存完所有的取完 $\log$ 之後的邊，進行Dijkstra，輸出最短路徑（以科學記號表示）即可！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">double</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;pid&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;<span class="keyword">double</span> c;<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lf&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,(<span class="keyword">double</span>)<span class="built_in">log10</span>(c+<span class="number">1</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis+n+<span class="number">2</span>,<span class="number">1e16</span>);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pdi,vector&lt;pdi&gt;,greater&lt;pdi&gt;&gt; pq;</span><br><span class="line">    dis[s] = <span class="number">0.0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visit[cur])<span class="keyword">continue</span>;</span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first;</span><br><span class="line">            <span class="keyword">double</span> w = i.second;</span><br><span class="line">            <span class="keyword">if</span>(dis[next] &gt; dis[cur]+w)&#123;</span><br><span class="line">                dis[next] = dis[cur]+w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[next],next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = dis[t];</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">floor</span>(ans);</span><br><span class="line">    ans-=x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2fe+%03lld\n&quot;</span>,<span class="built_in">pow</span>(<span class="number">10</span>,ans),x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="E-漢米頓的麻煩"><a href="#E-漢米頓的麻煩" class="headerlink" title="E.漢米頓的麻煩"></a>E.漢米頓的麻煩</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1096">題目連結</a></p>
<p>他題目時不時提到漢米頓，是多愛漢米頓XDD（這一題跟漢米頓根本沒關係）</p>
<blockquote>
<p>題目大意<br>在一張n(n≤100)個點的圖中，尋找路徑長度最短的環</p>
</blockquote>
<p>那就用<strong>Floyd-Warshall</strong>找最小的環就好！</p>
<div class="note info">
            <p><strong>Floyd-Warshall</strong><br>這就是dp的作法，用 $O(N^3)$ 的時間進行轉移，就能得到全點對的最短路徑。這邊有一個重要的轉移順序，也就是中點-起點-終點進行轉移，如果把dp展開就會發現中點必須在最外層進行轉移：</p><blockquote><p>定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路徑，則轉移式變成：</p><script type="math/tex; mode=display">d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])</script></blockquote><p>每一個k+1都是由k轉移而來，仰賴k的點的配對，因此必須最先轉移中點k的部分！（不過順序顛倒也不會怎樣啦，上面「課程內容」的地方有寫到）</p>
          </div>
<p>同樣這一份code也可以判斷有沒有負環，只要ans小於0的話代表有負環（有的話距離是不能用的喔，因為Floyd-Warshall不能處理負環，但負邊是可以處理的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="number">0</span>)dp[i][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,dp[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == INT_MAX)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旅遊規劃問題"><a href="#旅遊規劃問題" class="headerlink" title="旅遊規劃問題"></a>旅遊規劃問題</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1028">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262198">Submission</a><br>這一題 $n≤13$ 大概就是位元dp來完成（狀態壓縮），定義 $dp[i][j]$ 為現在在點i上，拜訪過點集j的最短距離（j中不包含點i）。這裡使用到了同層轉移的技巧，也就是利用j中的點，對相同狀態下不在i中的點進行更新。</p>
<p>點集j中在狀態i下為起點，用Dijkstra對不在i中的其他點進行更新，最後的答案即為$dp[s][S-(1&lt;&lt;s)]$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">vector&lt;pii&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],dp[N][<span class="number">1</span>&lt;&lt;N],pre[N][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="comment">//定義dp[i][j]為現在在點i，拜訪過點集合j（i不在點集j中）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m)&#123;                                 <span class="comment">//讀入m條邊</span></span><br><span class="line">        <span class="keyword">int</span> a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> S = <span class="number">0</span>,start = <span class="number">-1</span>;cin&gt;&gt;m;                <span class="comment">//S為待拜訪的所有點集合</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        S = S|(<span class="number">1</span>&lt;&lt;temp);</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">-1</span>)start = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)<span class="built_in">rep</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n))dp[i][j] = INF;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == (S &amp; i))&#123;                       <span class="comment">//在集合i中的點在S一定要有</span></span><br><span class="line">            priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">            <span class="built_in">fill</span>(dis,dis+n,INF);                <span class="comment">//將dis初始為無限大，做Dijkstra</span></span><br><span class="line">            <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;                   <span class="comment">//從有在i中的點向不在的點做Dijkstra</span></span><br><span class="line">                    dis[j] = dp[j][i^(<span class="number">1</span>&lt;&lt;j)];   <span class="comment">//目前在j，經過拜訪了點集i（不包含點j）</span></span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;dis[j],j&#125;);        <span class="comment">//利用在i中的點對其他點進行更新</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                visit[cur] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> k : edge[cur])&#123;</span><br><span class="line">                    <span class="keyword">int</span> v = k.first,w = k.second;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;v))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dis[v] &gt; dis[cur]+w)&#123;</span><br><span class="line">                        dis[v] = dis[cur] + w;</span><br><span class="line">                        pre[v][i] = cur;        <span class="comment">//紀錄點v在狀態i下由cur轉移</span></span><br><span class="line">                        pq.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dis[v] == dis[cur]+w &amp;&amp; pre[v][i] &gt; cur)&#123;</span><br><span class="line">                        pre[v][i] = cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;               <span class="comment">//對於不在點集i中的點進行更新</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))<span class="keyword">continue</span>;</span><br><span class="line">                dp[j][i] = dis[j];              <span class="comment">//同層狀態轉移，更新dp[j][i]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Minimum travel distance: &quot;</span>&lt;&lt;dp[start][S^(start)]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Travel route:&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = start;S = S^(<span class="number">1</span>&lt;&lt;start);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cur;</span><br><span class="line">        <span class="keyword">if</span>(!S)<span class="keyword">break</span>;</span><br><span class="line">        cur = pre[cur][S];</span><br><span class="line">        <span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;cur))S = (S^(<span class="number">1</span>&lt;&lt;cur));         <span class="comment">//經過的點不一定是指定的觀光點</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Codeforces-543B-Destroying-Roads"><a href="#Codeforces-543B-Destroying-Roads" class="headerlink" title="Codeforces 543B: Destroying Roads"></a>Codeforces 543B: Destroying Roads</h3><p><a href="https://codeforces.com/problemset/problem/543/B">題目連結</a><br><a href="https://codeforces.com/problemset/submission/543/125743532">Submission</a></p>
<blockquote>
<p>題目大意<br>給定N個點M條無向邊，每一邊權重都是1，以及兩筆資料，由三個數$(x,y,w)$ 構成，代表起點為x、終點為x、要在w距離內從起點走到終點。試問最多可以拔掉幾條邊同時滿足以上兩個資料所描述的特性？</p>
</blockquote>
<p>這一題蠻有趣的，首先他的邊權重都是1，因此我們可以直接用BFS尋找最短路徑，並且點第一次拜訪到時的就是該點的最短距離（BFS一層一層擴展）。</p>
<div class="note primary">
            <p><strong>第一個想法：錯誤想法</strong><br>我先將兩個起點與終點的最短路徑都找出來，把將過的邊都標上不能移除，將其他的邊全部拔掉。</p><p><strong>問題點：</strong><br>固然找到的是最短路徑，但不代表可以最大化拔除邊的數量。因為題目要求兩點只要符合最短距離 $w$ 即可，因此每一個配對其實不用符合是最短路徑的情況（如下圖）！目標是在題目要求的限度內最大化重複的邊，使能夠被拔除的邊最大化！</p><p><img src="https://i.imgur.com/QfbfF82.png" alt=""></p><p>上圖紅色線段是$\delta(1,7)$的最短路徑、褐色是線段$\delta(3,6)$的最短路徑、黑色線段是皆以最短路徑之下可以被拔除的邊。但是如果將路徑$\delta(3,6)$換成是$(3,2)\to(2,4)\to(4,5)\to(5,6)$，被拔除的邊可以增過為三條。</p>
          </div>
<p>這一題最重要的關鍵就是以$O(V^2)$枚舉所有點對（距離長度可以直接換算成邊的數量），可以先用$O(V(V+E)$的時間對每一個點用進行BFS，如此一來總複雜度即為$O(V^2+VE)$，所幸題目給定總共的邊數不會超過3000條，因此是可以在時間限制內完成枚舉。</p>
<div class="note primary">
            <p>枚舉路徑 $\delta(i,j)$ 為共同邊的時候，必須考慮起點與終點的方向，同時考慮從 $i\to j$ 以及從 $j\to i$ 兩個方向。以下圖為例，當枚舉都使用相同的起點以及終點，會讓下圖的 $(3,4)$ 被重複計算！</p><p><img src="https://i.imgur.com/tjq8oe7.png" alt=""></p>
          </div>
<p>以下是AC程式碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,s1,e1,w1,s2,e2,w2,dis[N][N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;e1&gt;&gt;w1&gt;&gt;s2&gt;&gt;e2&gt;&gt;w2;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">        que.<span class="built_in">push</span>(i);</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:edge[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit[j])<span class="keyword">continue</span>;</span><br><span class="line">                dis[i][j] = dis[i][cur]+<span class="number">1</span>;</span><br><span class="line">                visit[j] = <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[s1][e1]&gt;w1||dis[s2][e2]&gt;w2)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = dis[s1][e1]+dis[s2][e2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n^2)枚舉所有共同邊</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[s2][i]+dis[i][j]+dis[j][e2]&lt;=w2)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[s2][i]+dis[j][e2]);</span><br><span class="line">            <span class="keyword">if</span>(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[e2][i]+dis[i][j]+dis[j][s2]&lt;=w2)</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[e2][i]+dis[j][s2]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m-ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-2180-勇者冒險-Adventure"><a href="#TIOJ-2180-勇者冒險-Adventure" class="headerlink" title="TIOJ 2180 勇者冒險 (Adventure)"></a>TIOJ 2180 勇者冒險 (Adventure)</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/2180">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262669">Submission</a></p>
<blockquote>
<p>題目敘述<br>給定一個地圖共 $R\times C$ 行，接著會有 $M$ 行每一行都有一個座標和等級，代表經過這個座標需要多少等級才能通過。問從特定起點到終點所需要的最低的等級為多少。</p>
</blockquote>
<p>這題蠻特別的，他用到了Dijkstra中每一次都找最小的去更新，同時因為要求的是路徑上最大的等級為何，因此也用到了類似BFS的手法去擴展每一個座標。</p>
<p>因為題目保證至少會有一條路徑通往起點與終點，同時我們每一次從queue拿出來的都是目前等級最低的點，因此如果碰到終點就可以確定這一條路線一定是需要等級最小的一條路徑！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,row,col,mp[N][N],dis[N][N];</span><br><span class="line"><span class="keyword">int</span> s1,s2,e1,e2;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Dijkstra</span></span><br><span class="line">    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;</span><br><span class="line">    dis[s1][s2] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,&#123;s1,s2&#125;&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> rr = pq.<span class="built_in">top</span>().y.x,cc = pq.<span class="built_in">top</span>().y.y;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = rr+dx[i],ny = cc+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;=row||ny&gt;=col)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx == e1 &amp;&amp; ny == e2)&#123;</span><br><span class="line">                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp[nx][ny] == <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[nx][ny])<span class="keyword">continue</span>;</span><br><span class="line">            dis[nx][ny] = <span class="built_in">max</span>(dis[rr][cc],mp[nx][ny]);</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);</span><br><span class="line">            visit[nx][ny] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        mp[a][b] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小花費的航空之旅"><a href="#最小花費的航空之旅" class="headerlink" title="最小花費的航空之旅"></a>最小花費的航空之旅</h3><blockquote>
<p>題目敘述：<br>給定很多種連接城市間的聯票，要求從起始站搭乘，可以在中途任意站下車，但下車以後就不能再次上車。輸入的第一行為一個正整數 n (1 ≤ n ≤ 20)，即聯票的種類數。以下 n 行每航為一個聯票的資訊，其中第一個整數為聯票的價格，然後是聯票上城市的數目。</p>
<p>接下來為一個行程單的資訊，其中第一個正整數為行程單上的城市數目k（包括起始城市，2 ≤ k ≤ 10），以及這些城市的編號（按順序列出）。</p>
<p>輸出最小花費和對應的方案的其中一組解。</p>
</blockquote>
<p>這一題是APCS Class的其中一題，難度頗高，因為他要找最短的路徑，同時增加了可以在任意站下車的條件。首先我們要維護每一個聯票的資訊，它的價值、起點、編號以及經過的城市。接著，我們考慮所有從起點出發的聯票，將每一種聯票上的每一個經過的城市都加入queue中。</p>
<p>跟上一題一樣，當我們每一次都從cost最小的點下手，在轉移的過程中如果將所有的點都走訪一遍，則他的路徑必定是最短的，因為每一次的更新都是從花費最小的路徑去轉移。</p>
<div class="note primary">
            <p><strong>使用自定義比較函數放入Priority_queue中</strong></p><p>Priority_queue中的比較函數需要使用到struct或class包覆的比較函數，若要回傳cost的最小值，則必須以大於來寫（有點像預設是pop出最大值，使用的卻是less<int>的比較函數）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pif pair<span class="meta-string">&lt;int,float&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,visit[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ticket</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,cost;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next_city;</span><br><span class="line">    <span class="comment">//陣列ticket[i]存以i為起點</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Ticket&gt; ticket[<span class="number">30</span>];          <span class="comment">//ticket[i] 起點為i的聯票</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cost,cur_pos,visit_pos;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; used_ticket;</span><br><span class="line">    <span class="comment">//cur_pos現在所在位置、visit_pos在行程單上位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//讓priority_queue可以pop出最小的cost的路徑</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,num<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k;cin&gt;&gt;k;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        ticket[s].<span class="built_in">push_back</span>(&#123;i,cost,temp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k)cin&gt;&gt;visit[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : ticket[visit[<span class="number">1</span>]])&#123;         <span class="comment">//行程第一個起點的聯票起點</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i.next_city)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p &lt; k &amp;&amp; j == visit[p+<span class="number">1</span>])p++;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;一開始聯票：&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.visit_pos == k)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Cost = &quot;</span>&lt;&lt;cur.cost&lt;&lt;<span class="string">&quot;, Tickets used: &quot;</span></span><br><span class="line">                &lt;&lt;cur.used_ticket[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cur.used_ticket.<span class="built_in">size</span>();i++)</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;cur.used_ticket[i];</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ticket[cur.cur_pos])&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(cur.used_ticket)</span></span>;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(i.id);                <span class="comment">//將現在使用的第i聯票推入</span></span><br><span class="line">            <span class="keyword">int</span> p = cur.visit_pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : i.next_city)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p &lt; k &amp;&amp; j == visit[p+<span class="number">1</span>])p++;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;cur.cost+i.cost,j,p,vec&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>最短路徑</category>
      </categories>
      <tags>
        <tag>2021暑期筆記</tag>
        <tag>2020資訊之芽</tag>
      </tags>
  </entry>
  <entry>
    <title>計算幾何例題（Computational Geometry Problems）</title>
    <url>/geo2/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>向量加法</li>
<li>等長線段對</li>
<li>向左轉向右轉</li>
<li>線段相交</li>
<li>最小凸多邊形</li>
<li>TIOJ 1178 Convex Hull</li>
<li>來吧，遊戲開始了</li>
<li>遊戲：最終回</li>
<li>TIOJ 1205 直角三角形<span id="more"></span></li>
<li>TIOJ 1105 H.PS3</li>
<li>ZJ b288: 夏季大三角</li>
<li>TIOJ 1500 Clean up on aisle 3</li>
<li>ZJ a871: Museum Area</li>
<li>TIOJ 1280 領土 (Territory)</li>
<li>TIOJ 1678 剪多邊形（molding）</li>
<li>ZJ d269: 11579 - Triangle Trouble</li>
</ul>
<h3 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h3><p><a href="https://neoj.sprout.tw/problem/398/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178462/">Submission</a></p>
<blockquote>
<p>題目敘述：<br>給你n個數字（0≤i&lt;1，小數點精度到末九位），想知道到底有多少組 $(i,j,k)$ 滿足 $v_i+v_j=v_k$，其中 $i,j,k$ 可以重複。</p>
</blockquote>
<p>這題其實跟計算幾何沒什麼關係，直接用unordered_map去做（有點像two sum，不過下面的code好像也不用開到multi），簡單！不過我在浮點數的地方吃了一些WA，最後算了直接改用字串處理這個惱人的東西XD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep2(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps (1e-9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">rep2</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        string s;cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>,times = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            num += (s[i]-<span class="string">&#x27;0&#x27;</span>)*times;</span><br><span class="line">            times/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_multimap&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        mp.<span class="built_in">insert</span>(&#123;vec[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            ans += mp.<span class="built_in">count</span>(vec[i] + vec[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等長線段對"><a href="#等長線段對" class="headerlink" title="等長線段對"></a>等長線段對</h3><p><a href="https://neoj.sprout.tw/problem/399/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178471/">Submission</a></p>
<blockquote>
<p>題目敘述：<br>給定平面上很多個點，求出有幾對線段等長（輸入有重複的點）。</p>
</blockquote>
<p>既然n≤500，那就直接枚舉吧，沒啥特別難度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a,i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep2(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a.x-b.x,y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> x*x+y*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep2</span>(i,<span class="number">0</span>,n)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> dis = <span class="built_in">dist</span>(p[i],p[j]);</span><br><span class="line">            mp[dis]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = i.second;</span><br><span class="line">        ans+=((cnt*(cnt<span class="number">-1</span>))/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向左轉向右轉"><a href="#向左轉向右轉" class="headerlink" title="向左轉向右轉"></a>向左轉向右轉</h3><p><a href="https://neoj.sprout.tw/problem/400/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178524/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你平面上n個點，依序走訪每一個點，試問走訪過程中共執行幾次的左轉、右轉以及迴轉。</p>
</blockquote>
<p>很特別，計算幾何讓電腦可以處理平常我們所看到的平面圖形，可以利用向量內積、外積等方式判斷方向。這一題最重要的就是<strong>方向函數</strong>。傳入3個點$(A,B,O)$，方向函數會會回傳$\stackrel\longrightarrow{OA}\times \stackrel\longrightarrow{OB}$ 的正負數值。</p>
<p>下圖為外積$\stackrel\longrightarrow{OA}\times \stackrel\longrightarrow{OB}$ 的結果，當 $\sin\theta$的結果為負，也就是下圖的情況，從B走到A就需要往左邊走；反之亦然。<br><img src="https://i.imgur.com/eDNRLhm.png" alt=""></p>
<p>至於如何判斷當兩個向量的方向呈現一直線時，也就是外積回傳的值為0時（$\sin\theta = 0$），應該是同向還是異向呢？這時候就需要搭配向量內積（這我想了很久），因為內積公式是$A\cdot B = |A||B|\cos\theta$，將兩個向量內積之後就可以很明確的判斷到底是朝原本的方向走，還是反方向的行走！</p>
<div class="note info">
            <p><strong>內積、外積公式</strong><br>有一點數學，不過蠻有趣的。可以利用$\sin$與$\cos$達到計算角度的目的，利用兩者不同的值域，互相搭配，就可以更輕鬆的進行判斷！注意到外積的正負就代表著A到B是順時針或是逆時鐘。</p><script type="math/tex; mode=display">A\cdot B = |A||B|\cos\theta = A_xB_x+A_yB_y\\A\times B = |A||B|\sin\theta = A_xB_y-A_yB_x</script><p><br></p><p><strong>方向函數</strong></p><p>當我們要判斷方向的時候，會利用正弦函數，逆時針正、順時針為負進行判斷！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到此時在判斷是否為平行的時候（cross==0），使用到$fabs()$這個函數，目的是為了避免誤差而導致判斷錯誤，因此需要進行誤差的處理（其實不用也沒差啦，只是這樣嚴謹一點）</p>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pt&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    a.<span class="built_in">resize</span>(n+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>,left = <span class="number">0</span>,turn = <span class="number">0</span>;</span><br><span class="line">    pt pre = a[<span class="number">1</span>],from = a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ori = <span class="built_in">dir</span>(a[i],from,pre);</span><br><span class="line">        <span class="keyword">if</span>(ori == <span class="number">1</span>)right+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ori == <span class="number">-1</span>)left+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ori == <span class="number">0</span> &amp;&amp; ((a[i]-from)*(from-pre))&lt;<span class="number">0</span>)turn+=<span class="number">1</span>;</span><br><span class="line">        pre = from;from = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;left&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;right&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;turn&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="線段相交"><a href="#線段相交" class="headerlink" title="線段相交"></a>線段相交</h3><p><a href="https://neoj.sprout.tw/problem/401/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178537/">Submission</a><br>線段相交 = <del>線段香蕉</del>，自動選字永遠都是香蕉，有點煩XDD</p>
<p>如何判斷兩線段是否相交？首先需要一個函數可以判斷點是否在一個線段上，如此一來就可以判斷端點在另一條線段上的特殊情況。以下程式碼為判斷點$P_o$ 是否在 $\overline{P_aP_b}$ 上。利用向量外積可以判斷兩線段是否平行，而使用內積公式可以判斷$P_o$是否在線段中，而非線段的兩側！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;       <span class="comment">//o是否在ab線段上</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);  <span class="comment">//是否平行</span></span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);    <span class="comment">//是否在線段中</span></span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>)&amp;&amp;(dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>說明：由點$P_o$指向a和b的向量必須呈現180度角（也就是異向），才可確保在ab線段中（跟a,b重合也算是跟ab線段相交）。</p>
<p>接下來是主要的部分，首先先確認4個端點是否恰好在另外一條線段上，判斷完之後就是處理一般相交的情況。若線段 $\overline{P_1P_2}$ 與 $\overline{P_3P_4}$ 相交，則點 $P_1$ 與點 $P_2$ 會在線段$\overline{P_3P_4}$ 的異側。用方向函數表示：$dir(a,b,c)\times dir(a,b,d)&lt;0$。確認完兩個線段之後即完成線段相交的判斷！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(pt a, pt b, pt c, pt d)</span></span>&#123;      <span class="comment">//線段ab是否與cd相交</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c)||<span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點c、d是否洽在線段ab上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a)||<span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點a、b是否洽在線段cd上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c)*<span class="built_in">dir</span>(a,b,d)==<span class="number">-1</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a)*<span class="built_in">dir</span>(c,d,b)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">//對於線段兩端點看另外兩端點必須方向相反</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由下圖可以得到上面的結論，當兩線段相交時，方向函數得到的值（用外積，也就是下圖 $\theta_1$ 以及 $\theta_2$）的方向），會呈現一正一負，從兩個相反的方向看同一條線段得出來的結論！<br><img src="https://i.imgur.com/b5pW6IS.png" alt=""></p>
<p>AC Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pt&gt; point;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;                         <span class="comment">//方向函數</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;                       <span class="comment">//o是否在ab線段上</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);                  <span class="comment">//是否平行</span></span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);                    <span class="comment">//是否在線段中</span></span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>)&amp;&amp;(dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(pt a, pt b, pt c, pt d)</span></span>&#123;          <span class="comment">//線段ab是否與cd相交</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c)||<span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">//點c、d是否洽在線段ab上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a)||<span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">//點a、b是否洽在線段cd上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c)*<span class="built_in">dir</span>(a,b,d)==<span class="number">-1</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a)*<span class="built_in">dir</span>(c,d,b)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                                <span class="comment">//對於線段兩端點看另外兩端點必須方向相反</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    point.<span class="built_in">assign</span>(<span class="number">4</span>,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)cin&gt;&gt;point[i].x&gt;&gt;point[i].y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Intersection</span>(point[<span class="number">0</span>],point[<span class="number">1</span>],point[<span class="number">2</span>],point[<span class="number">3</span>]))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1178-Convex-Hull"><a href="#TIOJ-1178-Convex-Hull" class="headerlink" title="TIOJ 1178 Convex Hull"></a>TIOJ 1178 Convex Hull</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1178">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262532">Submission</a></p>
<blockquote>
<p>題目敘述<br>給定n個二維平面的點，找出位在凸包上的所有點的個數</p>
</blockquote>
<p>最小凸多邊形 = 凸包，要找出能包住所有點的最小凸多邊形，簡稱凸包。聽說最好寫的凸包演算法是：Andrew’s Monotone Chain，翻成中文叫做Andrew’s 單調鍊？有一點單調+鍊的味道。下圖是我用照片合成起來的GIF，大致模擬出使用Andrew’s Monotone Chain 找凸包的方法。</p>
<p><img src="https://i.imgur.com/YUOC9xZ.gif" alt=""></p>
<div class="note default">
            <p><strong>Andrew’s Monotone Chain</strong><br>這個演算法的時間複雜度是 $O(n\log n)$，空間複雜度 $O(n)$，資料說它可以解決了凸包有重疊的點、共線的點、退化成線段和點的情況。它的名字叫做「單調鍊」，要維護一個有點像單調隊列的東西，對於在容器中第 $i$ 個位置的點都滿足 $\stackrel\longrightarrow{P<em>i P</em>{i+1}}\times \stackrel\longrightarrow{P<em>{i+1} P</em>{i+2}} &gt; 0$ ，如果有點做外積後的結果小於等於0，則它會被pop掉（這是依照上圖逆時針完成凸包的描述，如果方向相反則會變號）。<br><br></p><p>以下是此演算法的執行步驟：</p><ol><li>先把所有的點按照 $(x,y)$ 排序</li><li>將下凸包圍出來，有點像維護單調隊列，對所有新加入的點i計算點i-2、i-1與i之間的外積，如果不符合情況代表圍不到新加入的點，需要將舊的點pop出來</li><li>將原本已經排序好的點逆序</li><li>再把上凸包由x座標大到小圍出來，將上下合併就是凸包了（必須注意起終點被push的次數問題）！</li></ol>
          </div>
<p>一般會用一個vector儲存在凸包上面的點（不包含在邊上的點，只有位於轉折點的點），在頭尾的部分（x座標最大與最小）需要特別處理，讓每一個點最多近到vector一次。</p>
<div class="note success">
            <p><strong>實作細節</strong><br>以下是確認是否需要將vector中元素pop出來的關鍵，對向量$\stackrel\longrightarrow{OA}\times \stackrel\longrightarrow{OB}$ 做外積的結果，必須排除外積結果為0的情況，如果將0也納入，會造成一個點被push進去很多次，在數量和計算上出現問題。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;         <span class="comment">//這裡很關鍵，別吃WA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，上凸包在範圍限制上是需要注意的。假設x座標最大的點i，當在圍上凸包的過程中i是不可以被pop出去的，因此vector的大小必須大於下凸包的大小。</p><p>凸包使用第i-1跟第i個點的向量去看第i到第i+1個點的向量，決定一個點要不要被推入vector中。當我們逆序從x座標最大的點往前看時，要確保每一輪結束之後在i點後都必須要有至少一個點，設定hull.size() &gt; down_hull的原因是防止在下凸包的點被圍上凸包的過程更新到。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();    <span class="comment">//圍上凸包的程式碼片段</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">    <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull </span><br><span class="line">        &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">        hull.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
<p>以下是AC Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;                              <span class="comment">//這裡很關鍵，別吃WA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; hull;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;                       <span class="comment">//起點會經過兩次，剛好來算有向面積</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">convex_hull</span>();</span><br><span class="line">    cout&lt;&lt;hull.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小凸多邊形"><a href="#最小凸多邊形" class="headerlink" title="最小凸多邊形"></a>最小凸多邊形</h3><p><a href="https://neoj.sprout.tw/problem/402/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178589/">Submission</a></p>
<blockquote>
<p>題目敘述<br>找出二維平面上n個點的凸包所圍出來的面積為何？</p>
</blockquote>
<p>跟上一題類似，在找到全部在凸包上面的點後，就可以利用<strong>有向面積</strong>把凸包面積算出來，有一個公式可以計算多邊形面積，利用外積得到正負值，轉一圈後得到面積！對於多邊形的頂點 $P<em>0,P_1,…,P</em>{n-1},P_n=P_0$ 的面積如下：</p>
<script type="math/tex; mode=display">Area = \frac{1}{2}\sum_{i=0}^{n-1}\stackrel\longrightarrow{P_i}\times \stackrel\longrightarrow{P_{i+1}}</script><p>其中最後一個點會回到起點，形成一個封閉的迴路。</p>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; hull;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;                       <span class="comment">//起點會經過兩次，剛好來算有向面積</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        vector&lt;pt&gt; hull = <span class="built_in">convex_hull</span>();</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>,len = hull.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">1</span>)&lt;&lt;((ld)area/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="來吧，遊戲開始了"><a href="#來吧，遊戲開始了" class="headerlink" title="來吧，遊戲開始了"></a>來吧，遊戲開始了</h3><p><a href="https://neoj.sprout.tw/problem/790/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178691/">Submission</a><br><a href="https://www.geogebra.org/graphing/h4fxdquw">GGB模擬</a></p>
<blockquote>
<p>題目敘述<br>給你二維平面上n個點(n≤2400)，每一個點座標皆不相同，求出總共可以圍出多少個三角形？</p>
</blockquote>
<p>這是NEOJ上的加分題，好像是一個題組吧，反正總共有三題，這是第一題。如果 $O(n^3)$ 的枚舉，複雜度會爆炸（量級約$10^{10}$），根據電神的說法，這一題要用極角排序以及雙指標找到共線，接著就可以利用排列組合把因為共線而不能形成三角形的組合扣掉，就是答案了。</p>
<p><img src="https://i.imgur.com/t5TF96I.png" alt=""></p>
<p>這一題的核心概念是找共線，具體來說的作法是枚舉每一個點的同時，以它為原點對其他的點進行排序，如果遇到有相同的極角座標表示這些點共線，同時利用陣列cnt[x]統計共線點數為x的線段總共有幾條。</p>
<p>以下的GIF就是大致上程式執行的樣子。因為一條長度為x的線段會因為枚舉x次的關係，在最後扣掉的情況會重複x次因此需要除掉。</p>
<p><img src="https://i.imgur.com/MVfEx4i.gif" alt=""></p>
<div class="note primary">
            <p><strong>共線與三角形</strong></p><p>一般情況下（任三點不共線），總共可以形成 $C^n_3$ 個三角形，如果有一條m個點共線的情況下（其他點不共線），則可以形成的三角形數量就必須扣除共線限制的情況，變成 $C^n_3-C^m_3$ 個三角形。</p>
          </div>
<p>時間複雜度為：枚舉每一個點 $O(n)$，極角排序 $O(n\log n)$，總時間複雜度 $O(n^2\log n)$</p>
<div class="note default">
            <p><strong>實作小細節</strong></p><p><strong>1. 維護共線連續區間</strong></p><p>我們要想辦法讓有共線的點們所在位置是一個連續的位置。三個點共線可能為在對角線的象限中，也就是點差了180度，如此一來就沒辦法讓共線的點為在連續的區間。為了達到這個目的，我們將所有位於下半平面的點都移到上半平面（在上半平面找到有相同 $\tan\theta$ 值的位置），接著就能利用雙指針找極角座標排序後有相同極角的區間之最大值！</p><p><strong>2. 特例判斷</strong></p><p>如果有一點y座標為0但x座標為負，要將其移到x軸正向的地方，不能把這種情況涵蓋為一般情況，否則原本在x軸正向的點會被移到x軸負向，沒有達到預期的效果。</p>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f1 = a &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> f2 = b &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)<span class="keyword">return</span> f1 &lt; f2;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆時針將點進行極角排序，從270度開始逆時針</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用cnt[i]統計區間長度為i的線段數量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(pt id)</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; pp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                         <span class="comment">//以id為原點</span></span><br><span class="line">        pt cur = i-id;</span><br><span class="line">        <span class="keyword">if</span>(cur == pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.y &lt; <span class="number">0</span>)&#123;cur.x = -cur.x;cur.y = -cur.y;&#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.x &lt; <span class="number">0</span> &amp;&amp; cur.y==<span class="number">0</span>)&#123;cur.x = -cur.x;&#125;</span><br><span class="line">        pp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(pp),cmp);                      <span class="comment">//將id當作原點進行排序</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,len = pp.<span class="built_in">size</span>();      <span class="comment">//雙指針找共線區間</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt; n<span class="number">-1</span>)&#123;                        <span class="comment">//最大化區間</span></span><br><span class="line">        <span class="keyword">while</span>(p2+<span class="number">1</span> &lt; len &amp;&amp; (pp[p1]^pp[p2+<span class="number">1</span>]) == <span class="number">0</span>)p2++;</span><br><span class="line">        cnt[p2-p1+<span class="number">2</span>]+=<span class="number">1</span>;</span><br><span class="line">        p1 = p2+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    cnt.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)<span class="built_in">solve</span>(p[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = (n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>))/<span class="number">6</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">3</span>,n)ans-=(cnt[i]*(i<span class="number">-1</span>)*(i<span class="number">-2</span>))/<span class="number">6</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遊戲：最終回"><a href="#遊戲：最終回" class="headerlink" title="遊戲：最終回"></a>遊戲：最終回</h3><p><a href="https://neoj.sprout.tw/problem/792/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178786/">Submission</a></p>
<blockquote>
<p>題目敘述<br>共有n個二維平面上的格子點，這些點會形成簡單多邊形。試求或在簡單多邊形內部的格線總長（包括垂直與水平格線）。</p>
</blockquote>
<p>這邊有一個不嚴謹的推導方式，不過他是正確的。令多邊形內部格線長度為S，多邊形的邊落在的格線長度為T，多邊形面積T，則有以下關係式：</p>
<script type="math/tex; mode=display">S = 2A-\frac{T}{2}</script><p>詳細的公式推導可以可以參閱下圖，平行四邊形（斜線部分）內部<strong>垂直</strong>的格線長度為： 大矩形 $(x_1+x_2)(y_1+y_2)$ 扣掉左右上下共四個三角形兩兩拼成一個矩形 $x_1y_1$ 以及 $x_2y_2$，還有左上右下兩個正方形 $2x_2y_1$，整理之後會發現其實跟面積是一樣的。對於垂直部分也是類似的情況。</p>
<p><img src="https://i.imgur.com/wemDPMp.jpg" alt=""></p>
<p>好像隱約發現到面積與格線長度有十分密切的關係，算出面積，把在格線上的邊進行特判扣掉，就可以得到格線長度。</p>
<p>這一題我想了很久，一直看不出來關係式到底長怎樣，直到大神提點才發現原來有這樣的關係，我反應好遲鈍:cry:</p>
<p><img src="https://i.imgur.com/Fy1wSky.png" alt=""></p>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,edge,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        area += (p[i]^p[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(p[i].y == p[i+<span class="number">1</span>].y)edge += <span class="built_in">abs</span>(p[i].x-p[i+<span class="number">1</span>].x);</span><br><span class="line">        <span class="keyword">if</span>(p[i].x == p[i+<span class="number">1</span>].x)edge += <span class="built_in">abs</span>(p[i].y-p[i+<span class="number">1</span>].y);</span><br><span class="line">    &#125;</span><br><span class="line">    area = <span class="built_in">abs</span>(area);</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        p.<span class="built_in">assign</span>(n+<span class="number">1</span>,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        edge = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        ans = <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;ans-((ld)edge/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1205-直角三角形"><a href="#TIOJ-1205-直角三角形" class="headerlink" title="TIOJ 1205 直角三角形"></a>TIOJ 1205 直角三角形</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1205">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262842">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你N（N≤1500）個座標平面上的點，請問總共可形成多少個直角三角形呢？</p>
</blockquote>
<p>從極角排序後的第一個點開始逆時針進行雙指針的枚舉。這邊使用到一個很特別的手法，對於共線的情況我們先透過預處理的方式將共線的點合併起來，並用cnt[x]陣列紀錄第x個點是由幾個點所合併起來的，如此一來，在進行計算的時候就不會有共線要分別處理的問題（不需擔心是不是可以跟之前的點形成直角三角形，因為相同斜率的點已經被合併剩下一個），直接將數量相乘就可以知道直角三角形的數量！</p>
<p>時間複雜度：枚舉所有點 $O(n)\times$ 進行極角排序$O(n\log n)$ 以及雙指標$O(n)$，總時間複雜度為 $O(n^2\log n)$。</p>
<div class="note info">
            <p><strong>實作小細節</strong></p><p>雙指針進行枚舉的過程中，很有可能會指標指向的索引值會超出範圍。解決的方法有兩種：</p><ol><li>超出了即代表繞了一圈，只需要對索引值取餘數即可。</li><li>除了取餘數的方法之外，其實也可以直接在點集後面將所有點再推入一次，讓角度從360延伸成720度，就不會有超出範圍的問題！</li></ol>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f1 = a &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> f2 = b &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)<span class="keyword">return</span> f1 &lt; f2;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆時針將點進行極角排序，從270度開始逆時針</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n)枚舉每個點當直角情況</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(pt id)</span></span>&#123;</span><br><span class="line">    pp.<span class="built_in">clear</span>();cnt.<span class="built_in">clear</span>();temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        pt cur = i - id;</span><br><span class="line">        <span class="keyword">if</span>(cur == pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)<span class="keyword">continue</span>;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(temp),cmp);            <span class="comment">//以id為原點進行極角排序</span></span><br><span class="line">    pp.<span class="built_in">push_back</span>(temp[<span class="number">0</span>]);          <span class="comment">//pp每一角度只存至多一個點</span></span><br><span class="line">    cnt.<span class="built_in">push_back</span>(<span class="number">1</span>);               <span class="comment">//考慮每個點共線情況</span></span><br><span class="line">    <span class="keyword">int</span> len = temp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> cross = temp[i]^temp[i<span class="number">-1</span>],dot = temp[i]*temp[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(cross == <span class="number">0</span> &amp;&amp; dot &gt;= <span class="number">0</span>)cnt[cnt.<span class="built_in">size</span>()<span class="number">-1</span>] += <span class="number">1</span>;   <span class="comment">//共線數量+=1</span></span><br><span class="line">        <span class="keyword">else</span> &#123;pp.<span class="built_in">push_back</span>(temp[i]);cnt.<span class="built_in">push_back</span>(<span class="number">1</span>);&#125;      <span class="comment">//非共線設定數量為1</span></span><br><span class="line">    &#125;</span><br><span class="line">    len = pp.<span class="built_in">size</span>();            <span class="comment">//考慮橫跨一周的情況</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)&#123;             <span class="comment">//雙指針i,p1可能會超過一圈</span></span><br><span class="line">        pp.<span class="built_in">push_back</span>(pp[i]);    <span class="comment">//將點再繞一圈</span></span><br><span class="line">        cnt.<span class="built_in">push_back</span>(cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; i+len &amp;&amp; (pp[i]^pp[p1]) &gt;= <span class="number">0</span> &amp;&amp; (pp[i]*pp[p1]) &gt; <span class="number">0</span>)p1 += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//夾銳角的情況要p1+=1</span></span><br><span class="line">        <span class="keyword">if</span>((pp[i]^pp[p1]) &gt; <span class="number">0</span> &amp;&amp; (pp[i]*pp[p1]) == <span class="number">0</span>)ans += cnt[i]*cnt[p1];</span><br><span class="line">        <span class="comment">//正向的直角三角形，若共線則兩者數量相乘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            ans += <span class="built_in">solve</span>(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1105-H-PS3"><a href="#TIOJ-1105-H-PS3" class="headerlink" title="TIOJ 1105 H.PS3"></a>TIOJ 1105 H.PS3</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1105">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262930">Submission $O(n^2)$</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262947">Submission $O(n\log n)$</a></p>
<blockquote>
<p>題目敘述<br>給你平面上N個點（N≤3000），請求出最遠點對的索引值（小的在前、大的在後）</p>
</blockquote>
<p>我做了一份<a href="/hVplrqxCRdGiMkn2lwXGAA">最近點對：不同複雜度之解決方式</a>的筆記，共有四種方法可以解決那個問題，這一題要求的是最遠點對，作法與最近點對其實差蠻遠的。由上幾題知道凸包的求法，因為凸包是可以圍住所有點的多邊形，因此最遠點對也應該在凸包上，而且所在的位置會為在凸包的兩側上（如果不落在凸包上，一定可以把點向兩側延伸到凸包上，且移動過後的點對距離一定比原始的點對距離大）。</p>
<p>找完凸包之後，可以用旋轉卡尺的方式尋找最遠點對。想像兩條平行線中間夾著凸包，逆時鐘旋轉繞行凸包一圈，過程不斷更新最遠點對的距離。在實作上兩條平行線可以被想像成由 $P<em>i$ 指向 $P</em>{i+1}$ 的向量，透過外積三角形面積公式決定卡尺該如何移動。</p>
<script type="math/tex; mode=display">AREA = |\overrightarrow{AB}\times \overrightarrow{AC}|</script><p>以下圖為例，我們要找 $\overline{HM}$ 為底可以形成的最大三角形面積的頂點，因為在同底的情況下面積就代表點與邊的垂直距離，最大的垂直距離意味著這條底邊可以垂直延伸的最遠距離。因為凸包必定是凸多邊形，因此三角形的面積會呈現單峰函數，因此只需要從下一個三角形面積的大小，決定雙指針中比較快的指標的移動情況。</p>
<p><img src="https://i.imgur.com/SXv0gfN.png" alt=""></p>
<p>如果仔細來看，以下圖為例，當前較快的指標指向的位置是 $D$ 點，考慮一條與與 $\overline{HM}$ 平行的直線，若下一個點 $J$ 在平行線段的另外一側，則將指標移往 $J$ 點。可能會有一個疑問，如果比較下圖的線段長度，會發現到 $\overline{DH}$ 的長度比經過 $J$ 點的兩條線段都還要長，那為何還要更新至 $J$ 點？舉這個例子不太好，不過可以想像當旋轉卡尺轉到以 $\overline{FH}$ 為底的時候，會將最遠點對的距離更新成 $\overline{HD}$ 的長度。如果今天 $H$ 的左側又多加了一個新點 $P$，則最遠點對會變成 $\overline{PD}$ 的距離。</p>
<p>簡單來說，最遠點對一定會發生對角的凸包點上面，即使現在以 $\overline{HM}$ 為底最遠點並非 $J$ 而是 $D$ ，但在旋轉卡尺旋轉到 $\overline{FH}$ 時就能將距離更新成 $\overline{HD}$ 的距離。</p>
<p><img src="https://i.imgur.com/6Jeg2U8.png" alt=""></p>
<div class="note success">
            <p><strong>實作小細節</strong></p><p>這一題有點麻煩，因為他要輸出的是最遠點對的索引值，而不是最遠點對之間的距離。在尋找凸包的過程中，會對所有點進行排序，因此原有的索引值順序會被打亂，需要在一開始輸入的時後就好好維護每一個座標的索引值。</p>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,ind;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x*x + y*y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,hull;</span><br><span class="line">pt pt_ans;</span><br><span class="line"><span class="keyword">int</span> n,h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa ^ bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa = <span class="built_in">abs</span>((a - c)^(b - c));</span><br><span class="line">    <span class="keyword">int</span> bb = <span class="built_in">abs</span>((a - d)^(b - d));</span><br><span class="line">    <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)<span class="keyword">return</span> a.ind &lt; b.ind;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">stable_sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)<span class="keyword">if</span>(p[i] == p[i+<span class="number">1</span>])p[i+<span class="number">1</span>].ind = p[i].ind;</span><br><span class="line">    hull.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    h = hull.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; sz &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,d = h,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">check2</span>(hull[i],hull[(i+<span class="number">1</span>)%sz],hull[d],hull[(d+<span class="number">1</span>)%sz]))</span><br><span class="line">            d = (d+<span class="number">1</span>)%sz;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; (hull[i]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            ans = (hull[i]-hull[d]).<span class="built_in">dis</span>();</span><br><span class="line">            <span class="keyword">int</span> a = hull[i].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans == (hull[i]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = hull[i].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            <span class="keyword">if</span>(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; (hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            ans = (hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>();</span><br><span class="line">            <span class="keyword">int</span> a = hull[(i+<span class="number">1</span>)%sz].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans == (hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = hull[(i+<span class="number">1</span>)%sz].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            <span class="keyword">if</span>(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        pt_ans = (pt)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">            p[i].ind = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">convex_hull</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;pt_ans.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pt_ans.y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">9 1</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">9 9</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="ZJ-b288-夏季大三角"><a href="#ZJ-b288-夏季大三角" class="headerlink" title="ZJ b288: 夏季大三角"></a>ZJ b288: 夏季大三角</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=b288">題目連結</a><br><a href="https://zerojudge.tw/ShowThread?postid=26741&amp;reply=0">解題報告</a></p>
<blockquote>
<p>題目敘述<br>請輸出在N個二維平面的座標，挑選3顆出來成組成三角形的最大面積</p>
</blockquote>
<p>比較一下兩個複雜度的作法，第一個是使用 $O(n^3)$ 枚舉所有的點並計算面積，所需要的時間是0.4sec，而且需要特別注意不能使用到海龍公式計算面積，否則有很大的機會會超時。</p>
<p><img src="https://i.imgur.com/oN26CR4.png" alt=""></p>
<p>以下作法是先進行 $O(n\log n)$ 找尋凸包，因為面積最大的三角形必定三個點都在凸包上，因此用 $n^2$ 的時間進行枚舉，旋轉卡尺（類似最遠點對的作法）找面積最大的第三個點，就能在總時間複雜度 $O(n^2)$ 完成！（會再更少，因為只要枚舉凸包上的點）</p>
<p><img src="https://i.imgur.com/SUwVRWv.png" alt=""></p>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    ld x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-b.x)&lt;=eps &amp;&amp; <span class="built_in">abs</span>(y-b.y)&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    ld <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    ld <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pt&gt; p,hull;</span><br><span class="line"><span class="keyword">int</span> n,t,h;</span><br><span class="line">ld ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;                              <span class="comment">//這裡很關鍵，別吃WA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    ld aa = (a - c)^(b - c);</span><br><span class="line">    ld bb = (a - d)^(b - d);</span><br><span class="line">    <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">area</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a^b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hull.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    h = down_hull<span class="number">-1</span>;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,i+<span class="number">1</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">            d = (j+<span class="number">1</span>)%sz;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">check2</span>(hull[i],hull[(j)%sz],hull[d],hull[(d+<span class="number">1</span>)%sz]))</span><br><span class="line">                d = (d+<span class="number">1</span>)%sz;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">area</span>((hull[d]-hull[i]),(hull[d]-hull[j])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    <span class="built_in">convex_hull</span>();</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1500-Clean-up-on-aisle-3"><a href="#TIOJ-1500-Clean-up-on-aisle-3" class="headerlink" title="TIOJ 1500 Clean up on aisle 3"></a>TIOJ 1500 Clean up on aisle 3</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1500">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262966">Submission</a></p>
<blockquote>
<p>題目敘述<br>平面上n個點找最近點對的距離</p>
</blockquote>
<p>最近點對真的有超多種作法的，枚舉、掃描線、分治、隨機都可以做！這邊有<a href="/hVplrqxCRdGiMkn2lwXGAA">一篇筆記</a>比較各種時間複雜度的最近點對作法，這邊不多做贅述！</p>
<p>以下程式碼是掃描線演算法，最差情況下的時間複雜度是 $O(n^2)$，因為需要排序，所以下限為 $\Omega(n\log n)$！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p,p+n);</span><br><span class="line">        ld d = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j].x &gt; p[i].x + d)<span class="keyword">break</span>;</span><br><span class="line">                d = <span class="built_in">min</span>(d, <span class="built_in">dis</span>(p[i],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1280-領土-Territory"><a href="#TIOJ-1280-領土-Territory" class="headerlink" title="TIOJ 1280 領土 (Territory)"></a>TIOJ 1280 領土 (Territory)</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1280">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262848">Submission</a></p>
<blockquote>
<p>題目敘述<br>一個國家有 n 個安全哨，每一個都有座標 $(x,y)$ ，代表在座標軸上的位置。輸出該國安全哨所能圍出的最大領土。</p>
</blockquote>
<p>n個點所能圍成的最大面積，其實等價於凸包的面積。與前幾題的<strong>最小凸多邊形</strong>是一模一樣的題目！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa^bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    vector&lt;pt&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = h.<span class="built_in">size</span>();</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;sz &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-2</span>)&#123;</span><br><span class="line">        area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;((area%<span class="number">2</span>)?(area/<span class="number">2</span>)+<span class="number">1</span>:(area/<span class="number">2</span>))&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-a871-Museum-Area"><a href="#ZJ-a871-Museum-Area" class="headerlink" title="ZJ a871: Museum Area"></a>ZJ a871: Museum Area</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=a871">題目連結</a></p>
<blockquote>
<p>題目敘述<br>n個點圍成的多邊形，求面積</p>
</blockquote>
<p>水題，直接套行列式公式即可算出答案！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pdd p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">check</span><span class="params">(pdd a, pdd b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y - a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        ld area = <span class="number">0.0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)area += <span class="built_in">check</span>(p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">        ld ans = (ld)area/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans = -ans;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1678-剪多邊形（molding）"><a href="#TIOJ-1678-剪多邊形（molding）" class="headerlink" title="TIOJ 1678 剪多邊形（molding）"></a>TIOJ 1678 剪多邊形（molding）</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1678">題目連結TIOJ</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262849">TIOJ Submission</a><br><a href="https://zerojudge.tw/ShowProblem?problemid=d546">題目連結ZJ</a></p>
<blockquote>
<p>題目敘述<br>間單來說是求出多邊形面積以及凸包面積的差，詳細可以點上面題目連結。</p>
</blockquote>
<p>題目說多邊形需要才剪下的面積，我們就算凸包面積以及多邊形面積，兩者的差去除上題目給的色塊面積即是答案！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,a,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa^bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    vector&lt;pt&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = h.<span class="built_in">size</span>();</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;sz &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Polygon</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">temp</span><span class="params">(p)</span></span>;</span><br><span class="line">    temp.<span class="built_in">push_back</span>(temp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)area += (temp[i]^temp[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(area);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">    p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    ld small = (ld)<span class="built_in">Polygon</span>()/<span class="number">2</span>;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-2</span>)area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">    ld big = (ld)area/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">ceil</span>((big-small)/a);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-d269-11579-Triangle-Trouble"><a href="#ZJ-d269-11579-Triangle-Trouble" class="headerlink" title="ZJ d269: 11579 - Triangle Trouble"></a>ZJ d269: 11579 - Triangle Trouble</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d269">題目連結</a></p>
<blockquote>
<p>題目敘述<br>有一個三角形工廠有一個很大的問題。給你一些邊的邊長，想辦法找出用這些邊長圍出最大的三角形。</p>
</blockquote>
<p>根據海龍公式，三角形面積：</p>
<script type="math/tex; mode=display">\triangle ABC = \sqrt{s\cdot(s-a)\cdot(s-b)\cdot(s-c)}</script><p>可以利用貪婪法，將所有邊長由大到小進行排序，每一次拿最大的三個邊長進行枚舉，即可算出最大的三角形面積。不難理解，當換上一個比較大的邊，算出來的s也會比較大，跟邊相減的值也會比較大，總面積自然較大（好啦，這是非常不嚴謹的證明XD）</p>
<p>在想題過程中，我有思考到，如果周長一樣的情況下，到底何種面積的三角形面積會比較大？答案是正三角形！</p>
<div class="note default">
            <p><strong>三角形周長固定下面積的比較</strong><br>根據海龍公式：</p><script type="math/tex; mode=display">s = \frac{1}{2}(a+b+c)</script><p>想要比較在周長固定下三角形的面積，可以用算幾不等式比較，因為 $s$ 是定值，所以可以列出以下式子：</p><script type="math/tex; mode=display">\frac{(s-a)+(s-b)+(s-c)}{3} ≥ \sqrt[3]{(s-a)(s-b)(s-c)}</script><p>等好成立時，$a=b=c$。因為$s = \frac{a+b+c}{2}$，因此：</p><script type="math/tex; mode=display">(\frac{a}{2})^2 ≥ (s-a)(s-b)(s-c)</script><p>得到海龍公式</p><script type="math/tex; mode=display">\triangle ABC = \sqrt{s\cdot(s-a)\cdot(s-b)\cdot(s-c)} ≤ \sqrt{\frac{3a}{2}\cdot\frac{a^3}{8}}=\frac{\sqrt{3}}{4}a^2</script>
          </div>
<p>以下是使用貪婪法的AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">vector&lt;ld&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">area</span><span class="params">(ld a ,ld b, ld c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b + c)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ld p = (a+b+c)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> p*(p-a)*(p-b)*(p-c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i];</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(p),greater&lt;&gt;());</span><br><span class="line">        ld ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-3</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">area</span>(p[i],p[i+<span class="number">1</span>],p[i+<span class="number">2</span>]));</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">sqrt</span>(ans)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>計算幾何，顧名思義就是在電腦完成幾何的運算，要怎麼把平面的東西轉化成電腦看得懂的東西就是計算幾何在做的事情。常常我們覺得很容易判斷的事情，例如判斷線段是否相交，我們可以利用肉眼直輕易判斷出來，因為我們有強大的空間感幫助我們進行判斷，但換作是電腦就必須用一些數學的技巧，對於不同的情況做各自的判斷，才能讓電腦正確回答兩條線段的相交情形。</p>
<p>除此之外，在寫題過程中，使用到ggb進行輔助，讓我可以對程式的執行過程有更是覺化的概念，也幫助我在解題時能更理解解題的策略！上面一題三角形個數的判斷，就使用了ggb判定將點搬移的所有情況。利用它我抓到了當點的y座標為零時並沒進行好特殊情況的判斷，這也是一個視覺化之後的好處！</p>
<p>有一題沒有做的是模擬退火的題目實作，要求圓與三角形的交集面積，感覺超級複雜，以後有時間來慢慢實作！</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>計算幾何</category>
      </categories>
      <tags>
        <tag>計算幾何</tag>
        <tag>暑期筆記</tag>
      </tags>
  </entry>
</search>
