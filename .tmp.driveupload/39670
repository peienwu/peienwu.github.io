<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APCS 2021.01</title>
    <url>/2021/01/09/APCS%202021.01/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/YAk4Riy.png" alt=""><br>第一次考APCS，拿到觀念4級、實作3級，希望在下一次可以更進步！（我是大廢廢</p>
<h2 id="110-01-實作題第一題-購買力"><a href="#110-01-實作題第一題-購買力" class="headerlink" title="110/01 實作題第一題 購買力"></a>110/01 實作題第一題 購買力</h2><p>APCS的第一題都是應該要秒殺的，也順利拿到100分<br><span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,d,cost = <span class="number">0</span>,total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;d;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[<span class="number">0</span>]&gt;&gt;arr[<span class="number">1</span>]&gt;&gt;arr[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">sort</span>(arr, arr+<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">2</span>]-arr[<span class="number">0</span>]&gt;=d)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            cost +=((arr[<span class="number">0</span>]+arr[<span class="number">1</span>]+arr[<span class="number">2</span>])/<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cost&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-01-實作題第二題-流量"><a href="#110-01-實作題第二題-流量" class="headerlink" title="110/01 實作題第二題 流量"></a>110/01 實作題第二題 流量</h2><p>這一題的題序有點複雜，看了幾次之後才看懂。但重點是在考試的時候沒有想到要怎麼合併流量，所以只用了一維陣列計算最小值，因此只有拿到50分…<br>這是完整版的程式碼，主要是透過創建一個陣列r[i][j]，表示從城市i出發到城市j的總流量，再利用陣列r計算費用。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,K,s[<span class="number">50</span>][<span class="number">50</span>],r[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1e8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(r));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;N;q++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p;<span class="comment">//第i個伺服器架設在p城市</span></span><br><span class="line">            cin&gt;&gt;p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)r[p][j]+=s[q][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第0個跟第1個伺服器都架設在1的位置，則將流量相加，得到陣列r</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;M;q++)&#123;<span class="comment">//0&lt;p&lt;M</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q==j)sum+=r[q][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(r[q][j]&lt;=<span class="number">1000</span>)sum+=<span class="number">3</span>*r[q][j];</span><br><span class="line">                <span class="keyword">else</span> sum+=(r[q][j]<span class="number">-1000</span>)*<span class="number">2</span>+<span class="number">3000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="110-01-實作題第三題-切割費用"><a href="#110-01-實作題第三題-切割費用" class="headerlink" title="110/01 實作題第三題 切割費用"></a>110/01 實作題第三題 切割費用</h2><p>這一題雖然在考試中有想到利用二元樹的方法，於是開了一個陣列儲存樹的節點（前段時間寫了一些線段樹，所以用了這個方法！）但我沒有注意到這不是一棵完滿二元樹，<strong>不會平衡啊</strong>！把範例測資丟上去對了，結果半分都沒有拿到:cry:，以後必須注意！<br>用<em>std::set</em>搭配 <em>next(),prev()</em> 指標，找出鄰近的切割點之差，就可以AC了！</p>
<div class="note info">
            <p><img src="https://i.imgur.com/YqPsqDY.png" alt=""><br>在 <em>set</em> 中使用<em>insert()</em> 函式會回傳<em>pair<iterator,bool></em> 在使用的時候要變成：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = s.<span class="built_in">insert</span>(arr[i]).first;</span><br></pre></td></tr></table></figure></p>
          </div>
<p>這是考試送出的0分程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,L,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> seg[<span class="number">1000000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[cur]==<span class="number">0</span>)&#123;</span><br><span class="line">        seg[cur] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val&gt;seg[cur])<span class="built_in">build</span>(val, <span class="number">2</span>*cur+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(val, <span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//建立一個會爆掉的二元樹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> up = L,low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[cur]==val)&#123;</span><br><span class="line">        ans+=up-low;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(seg[cur]!=val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&gt;seg[cur])&#123;</span><br><span class="line">            low = seg[cur];</span><br><span class="line">            cur = <span class="number">2</span>*cur+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            up = seg[cur];</span><br><span class="line">            cur = <span class="number">2</span>*cur+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=up-low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        arr[b<span class="number">-1</span>] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">build</span>(arr[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">func</span>(arr[i], <span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>這是正解：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,l,arr[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">0</span>,l&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ind,pos;cin&gt;&gt;pos&gt;&gt;ind;</span><br><span class="line">        arr[ind<span class="number">-1</span>] = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = s.<span class="built_in">insert</span>(arr[i]).first;</span><br><span class="line">        ans+= *<span class="built_in">next</span>(pos)- *<span class="built_in">prev</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="110-01-實作題第四題-飛黃騰達"><a href="#110-01-實作題第四題-飛黃騰達" class="headerlink" title="110/01 實作題第四題 飛黃騰達"></a>110/01 實作題第四題 飛黃騰達</h2><p>這是一題我在考試中根本沒有碰的題目（能力不足），聽到別人是說這是一題經典的LIS，所以寒假就開始了解<a href="https://hackmd.io/ytV5oL34TRyotshCcJHJ2g">動態規劃的題目</a>。這一題關鍵是先把x座標排列好（可以想成是LIS中的數列順序），然後依照y座標做LIS。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        P[i] = <span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(P, P+n);<span class="comment">//利用pair排序，會先依照x排序，如果x相同，則照y排序</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;ans;<span class="comment">//儲存LIS</span></span><br><span class="line">    ans.<span class="built_in">push_back</span>(P[<span class="number">0</span>].second);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> now = P[i].second;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;=ans.<span class="built_in">back</span>())ans.<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ind = <span class="built_in">upper_bound</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),now)-ans.<span class="built_in">begin</span>();</span><br><span class="line">            ans[ind] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note success">
            <p>這裡有一點跟LIS不一樣，它不需要嚴格遞增，因此在第20使用 <strong>&gt;=</strong> ，還有第22行使用<strong>upper_bound</strong>也是因為不需要嚴格遞增（如果要插入的值在LIS裡面就已經有了，兩者都可以保留，所以用<strong>upper_bound</strong>，取第一個大於它的數值更改掉。</p>
          </div></p>
<hr>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>第一次參加APCS拿到4,3的成績，雖然沒有很好（這一次還是比較簡單的題目！），但還是在預期之內。希望透果補足一些不足的地方，下一次會有更好的成績！</p>
<ol>
<li><strong>IDE環境不熟悉</strong><br> 平常都是在mac上打程式，而所有的比賽都只有windows的codeblocks，有時候debug的內容不小被我關掉就叫不出來，耗費許多時間。<br> 解決方法：下載codeblocks來好好熟悉一下</li>
<li><strong>題目練習不夠多</strong><br>在考試之前大多是聽別人講怎麼做，實際練習題目的量太少，所以在實際的競賽中就寫不出東西。<br>解決方法：每週固定寫一個主題的題目，反覆練習讓自己對這個主題更熟悉+寫APCS考古題。</li>
<li><strong>懂得東西太少</strong><br> 本次第三題就是很好的例子，自己寫二元樹出一堆問題，不如用std內建的set還比較快！雖然一直都知道set的存在，但實際的競賽中就不知道怎麼用。<br> 解決方法：資訊之芽好好學！</li>
<li><strong>實戰經驗不足</strong><br> 這應該是參加過的第三場正式的競賽（或檢定），以後就慢慢累積比賽的經驗<br> 解決方法：參加線上程式競賽，練手感。</li>
<li><strong>打字速度太慢</strong><br> 打字速度慢就拖慢整體的寫扣時間，必須加強！<br> 解決方法：每天花10分鐘碰碰鍵盤，利用網路上<a href="https://typing.io/lessons">打字練習</a>加快打字速度。</li>
</ol>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS 2021.09</title>
    <url>/2021/09/05/APCS%202021.09/</url>
    <content><![CDATA[<p>這次沒有報名APCS，因為報名手續有點麻煩，還要在學證明和教師簽名等等，所以就沒有報…。總之，利用ZeroJudge的測資來寫寫看，但在ZJ上面會過不能保證真的去考APCS的測資就一定會過！</p>
<span id="more"></span>
<h2 id="P1-七言對聯"><a href="#P1-七言對聯" class="headerlink" title="P1 七言對聯"></a>P1 七言對聯</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g275">題目連結</a></p>
<p>總共有ABC三種規則，就每一種都比對一次就可以了！</p>
<p><strong>時間複雜度：</strong> 共有 $n$ 組對聯，每一組都 $O(1)$ 檢查，時間 $O(n)$ 。（不過n最大也才50，不論什麼複雜度都可以吧）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> a[N],b[N],f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">7</span>)cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">7</span>)cin&gt;&gt;b[i];</span><br><span class="line">        f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>]==a[<span class="number">4</span>]||a[<span class="number">2</span>]!=a[<span class="number">6</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;A&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[<span class="number">2</span>]==b[<span class="number">4</span>]||b[<span class="number">2</span>]!=b[<span class="number">6</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;A&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">7</span>]!=<span class="number">1</span> || b[<span class="number">7</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;B&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>]==b[<span class="number">2</span>]||a[<span class="number">4</span>]==b[<span class="number">4</span>]||a[<span class="number">6</span>]==b[<span class="number">6</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;C&quot;</span>;f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f)cout&lt;&lt;<span class="string">&quot;None&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="P2-魔王迷宮"><a href="#P2-魔王迷宮" class="headerlink" title="P2 魔王迷宮"></a>P2 魔王迷宮</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g276">題目連結</a></p>
<p>這一題我好像太早寫了，題目還在整修階段，丟上去TLE，發現題目敘述又改了XD，從魔王踩到炸彈爆炸後，「炸彈不會消失」，到「炸彈會消失」，還有範測也有改變。</p>
<p>這一題是去模擬每一個魔王移動的狀況，要特別注意每一輪的國王是同時移動的，沒有先後順序，也就是說一顆炸彈可以炸掉不只一位魔王，如果有多個魔王移動到同一個格子，則他們會一起被炸掉。</p>
<p><strong>時間複雜度：</strong> 有點難估計，因為很難確定每一個魔王的移動狀況次數，不過由於數字範圍不大，且 $k$ 只有到500，因此直接做複雜度是可行的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">bool</span> maze[N][N],bomb[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,s,t;</span><br><span class="line">    <span class="keyword">bool</span> alive;</span><br><span class="line">&#125;mp[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maze));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y;</span><br><span class="line">        cin&gt;&gt;mp[i].s&gt;&gt;mp[i].t;</span><br><span class="line">        mp[i].alive = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> now_alive = k;</span><br><span class="line">    <span class="keyword">while</span>(now_alive)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(bomb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(bomb));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[p].alive == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mp[p].x,j = mp[p].y;</span><br><span class="line">            maze[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[p].alive == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mp[p].x,j = mp[p].y;</span><br><span class="line">            <span class="keyword">int</span> nx = i + mp[p].s;</span><br><span class="line">            <span class="keyword">int</span> ny = j + mp[p].t;</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= n || nx &lt; <span class="number">0</span> || ny &gt;= m ||ny &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                now_alive--;</span><br><span class="line">                mp[p].alive = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maze[nx][ny])&#123;</span><br><span class="line">                now_alive--;</span><br><span class="line">                mp[p].alive = <span class="number">0</span>;</span><br><span class="line">                bomb[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[p].x = nx;</span><br><span class="line">                mp[p].y = ny;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bomb[i][j] == <span class="number">1</span>)</span><br><span class="line">                    maze[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j])ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P3-幸運數字"><a href="#P3-幸運數字" class="headerlink" title="P3 幸運數字"></a>P3 幸運數字</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g277">題目連結</a></p>
<p>以區間最小值作為區分點將數列分成兩半，可以利用線段樹找區間最小值，利用迴圈模擬每一次範圍縮小的情況。</p>
<p>不過這一題比較特別，他的區間範圍一定會越來越小，且區間外的數字也就不需要使用到，因此可以將數列做一次排序，從頭開始找如果遇上區間外的數字則不理他，否則使用它當作區間的分隔點（這一定會是最小值，因為由小到大排序），將區間範圍縮小。</p>
<p>至於挑選左右區間的區間和，則可以透過前綴和 $O(1)$ 算出答案。</p>
<p><strong>時間複雜度：</strong> 如果是一個遞增或遞減的序列，則每一次區間大小只會縮減1，此時複雜度為 $O(n)$，加上最一開始的排序是 $O(n\log n)$，總共為 $O(n\log n)$。</p>
<h3 id="排序作法"><a href="#排序作法" class="headerlink" title="排序作法"></a>排序作法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[N],pref[N];</span><br><span class="line">pii sorted[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;sorted[i<span class="number">-1</span>].x;</span><br><span class="line">        arr[i] = sorted[i<span class="number">-1</span>].x;</span><br><span class="line">        sorted[i<span class="number">-1</span>].y = i;</span><br><span class="line">        pref[i] = pref[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sorted,sorted+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">0</span>,l = <span class="number">1</span>,r = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        <span class="keyword">while</span>(sorted[ind].y &gt; r || sorted[ind].y &lt; l)ind++;</span><br><span class="line">        <span class="keyword">int</span> left = pref[sorted[ind].y<span class="number">-1</span>]-pref[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = pref[r]-pref[sorted[ind].y];</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            r = sorted[ind].y<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = sorted[ind].y+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;arr[l]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="線段樹作法"><a href="#線段樹作法" class="headerlink" title="線段樹作法"></a>線段樹作法</h3><p>如果用線段樹實作，尋找區間最小值，可以在 $O(\log n)$ 的時間內詢問。在最差的情況下，一共會詢問 $n$ 次，因此總時間複雜度一樣是 $O(n\log n)$。實作上也不複雜，建立線段樹以及區間詢問，區間修改和懶標之類的東西。可以比較一下時間：</p>
<p><img src="https://i.imgur.com/JlsbyYf.png" alt=""></p>
<p>線段樹的表現稍微好一點，不過其實是相當接近的！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,arr[N],pref[N];</span><br><span class="line">pii seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立線段樹[l,r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        seg[cur] = &#123;arr[l],l&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span>*cur,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r);</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*cur].x &lt; seg[<span class="number">2</span>*cur+<span class="number">1</span>].x)</span><br><span class="line">        seg[cur] = seg[<span class="number">2</span>*cur];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        seg[cur] = seg[<span class="number">2</span>*cur+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//詢問區間最小值，回傳pair</span></span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l || ql &gt;= r || qr &lt;= l)<span class="keyword">return</span> &#123;INT_MAX,INT_MAX&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)<span class="keyword">return</span> seg[cur];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    pii lft = <span class="built_in">query</span>(<span class="number">2</span>*cur,l,mid,ql,qr);</span><br><span class="line">    pii rgt = <span class="built_in">query</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(lft.x &lt; rgt.x)<span class="keyword">return</span> lft;</span><br><span class="line">    <span class="keyword">return</span> rgt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        pref[i] = pref[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = n+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,l,r).y;</span><br><span class="line">        <span class="keyword">int</span> left = pref[ind<span class="number">-1</span>] - pref[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = pref[r<span class="number">-1</span>] - pref[ind];</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)r = ind;</span><br><span class="line">        <span class="keyword">else</span> l = ind + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;arr[l]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="歐恩作法"><a href="#歐恩作法" class="headerlink" title="歐恩作法"></a>歐恩作法</h3><blockquote>
<p>BY thanksone</p>
</blockquote>
<p>有一種二元樹，我也不知道叫啥，根為全序列最小值，左節點為左邊序列最小值，右節點為右邊序列最小值。</p>
<h4 id="建法"><a href="#建法" class="headerlink" title="建法"></a>建法</h4><p>紀錄每個位置左、右邊離自己最近、比自己小的，爸爸就是兩個之中比較大的那一個。</p>
<p><strong>時間複雜度：</strong> 種樹加跑答案總共 $O(n)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ff first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">array&lt;<span class="keyword">int</span>, 300004&gt; A, S, L, R;</span><br><span class="line">array&lt;pii, 300004&gt; tree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plant</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L[i]] &gt; A[R[i]]) tree[L[i]].ss = i;</span><br><span class="line">        <span class="keyword">else</span> tree[R[i]].ff = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> A[l];</span><br><span class="line">    <span class="keyword">if</span>(S[m - <span class="number">1</span>] - S[l - <span class="number">1</span>] &gt; S[r] - S[m]) <span class="keyword">return</span> <span class="built_in">solve</span>(l, m - <span class="number">1</span>, tree[m].ff);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(m + <span class="number">1</span>, r, tree[m].ss);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    stack&lt;pii&gt; s;</span><br><span class="line">    pii m = &#123;<span class="number">1e9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    s.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; m.ff) m = &#123;A[i], i&#125;;</span><br><span class="line">        S[i] = A[i] + S[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(A[i] &lt; s.<span class="built_in">top</span>().ff)&#123;</span><br><span class="line">            R[s.<span class="built_in">top</span>().ss] = i;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        L[i] = s.<span class="built_in">top</span>().ss;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;A[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">plant</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(<span class="number">1</span>, n, m.ss);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果把範測的笛卡爾樹具象化，大概長這樣：</p>
<blockquote>
<p>8<br>3 9 4 5 1 6 2 8</p>
</blockquote>
<p><img src="https://i.imgur.com/lqvdW31.png" alt=""></p>
<p>大致步驟就是：</p>
<ol>
<li>用<strong>單調隊列</strong>建立函數 $L$ 以及 $R$，表示往左往右看第一個小於自己的數</li>
<li>建立笛卡爾樹（$L[i],R[i]$ 挑大的作為父節點）</li>
<li>從根節點開始走訪，左右節點就會分別是左右區間的最小值</li>
<li>利用前綴和計算區間大小，決定要走左還是右子樹</li>
<li>走訪到區間長度為 $1$ 時即答案！ </li>
</ol>
<div class="note success">
            <p>總共有三個不同的作法，使用到排序、線段樹、笛卡兒樹的作法。其中，他們的間複雜度分別是 $O(n\log n)$、$O(n\log n)$、$O(n)$。</p><ol><li>排序作法：AC (0.1s, 9.5MB)</li><li>線段樹作法：AC (84ms, 20.9MB)</li><li>歐恩作法：AC (82ms, 15.6MB)</li></ol><p>在笛卡兒樹的作法中，對每一個數字尋找兩側第一個小於它的數字（這可以用單調隊列完成），之後把每一個數字的父親節點設為找到的兩端數字中較大的那一個。</p><p>此作法的概念是，假設序列中第 $i$ 個數字找到兩側數字分別是 $l_i$ 以及 $r_i$，當他如果是區間最小時，區間必須在 $[l_i+1:r_i-1]$ 之中，否則它就不會是最小值了。</p><p>至於為何是選擇 $max(A[l_i],A[r_i])$ 當做父節點？則是因為如果選擇較小的那一個，在縮小區間範圍後，無法確定另外一個是否在區間外，如果包含區間內，則 $A[i]$ 便不會是最小值，違反了定義。換言之，選擇了較大的那一個當作父節點，按照定義當走到這個父節點時，它是區間的最小值，將它排除之後，$A[i]$ 就會是下一個區間的最小值！</p>
          </div>
<h2 id="P4-美食博覽會"><a href="#P4-美食博覽會" class="headerlink" title="P4 美食博覽會"></a>P4 美食博覽會</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g278">題目連結</a></p>
<p>對於序列中k個連續的區間，每一個區間滿足區間內的元素皆不重複，區間範圍可以重疊（不過重疊部分只會算一次），找出這k個連續區間所能覆蓋到的最大長度。</p>
<p>感覺跟背包問題的概念有點像，n個物品可以對應到k個區間，重量則對應到這裡的序列中的數字。這題用DP解。</p>
<h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><p>定義 $dp[i][j]$ 為 $i$ 個試吃員，看了前 $j$ 個攤位，最多可以吃到幾個攤位。</p>
<h3 id="轉移式"><a href="#轉移式" class="headerlink" title="轉移式"></a>轉移式</h3><p>維護一個函數 $f[i]$ 表示如果試吃員吃了第 $i$ 個攤位的美食，他所能吃到<strong>最左端的攤位的索引值</strong>。也就是說，試吃員可以吃 $f[i]$ 到 $i$ 攤位的美食。</p>
<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j-1],dp[i-1][f[j]-1]+j-f[j]+1)</script><p>轉移式代表了要使用第 $i$ 的攤位作為右端點，或是不要使用（直接用前一個），取兩者的最大值。後面一串加減是計算區間大小</p>
<h3 id="邊界"><a href="#邊界" class="headerlink" title="邊界"></a>邊界</h3><script type="math/tex; mode=display">dp[i][j] = 0,\text{for all 0≤i≤k,0≤j≤n}</script><p>從轉移式可以看到他空間可以用滾動DP優化！</p>
<div class="note success">
            <p><strong>GREEDY的作法？</strong><br>如果每一次都選擇最大的區間，並將這個區間的值都改成0，做7次，得到答案，是正確的做法嗎？</p><p>最大的區間不一定會被完全選到。以下測資：</p><blockquote><p>12 2<br>5 4 3 2 1 3 4 5 6 4 3 2</p></blockquote><p>如果是Greedy會選擇 $2 \,1\, 3\, 4\, 5\, 6$ ，然後從兩邊挑一邊。答案是 $9$。<br>但是用DP做會是 $5\, 4\, 3\, 2\, 1$ 加上 $5\, 6\, 4\, 3\, 2$，答案是 $10$。</p>
          </div>
<p><strong>時間複雜度：</strong> 兩層迴圈總共是 $O(kn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,dp[<span class="number">2</span>][N],lft[N],arr[N];</span><br><span class="line"><span class="keyword">int</span> mp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(lft,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(lft));</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[arr[i]]!=<span class="number">0</span>)&#123;</span><br><span class="line">            lft[i] = mp[arr[i]]+<span class="number">1</span>;</span><br><span class="line">            mp[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lft[i] = <span class="number">1</span>;</span><br><span class="line">            mp[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        lft[i] = <span class="built_in">max</span>(maxn,lft[i]);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn,lft[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="built_in">max</span>(dp[<span class="number">1</span>][j<span class="number">-1</span>],dp[<span class="number">0</span>][lft[j]<span class="number">-1</span>]+j-lft[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 1 2 1 4 1 7 1 3 8</span></span><br><span class="line"><span class="comment">// 1 1 2 2 4 4 7 7 7 8</span></span><br></pre></td></tr></table></figure>
<h3 id="EXTRA-版本"><a href="#EXTRA-版本" class="headerlink" title="EXTRA 版本"></a>EXTRA 版本</h3><blockquote>
<p>BY thanksone</p>
</blockquote>
<p><img src="https://i.imgur.com/srLyvYy.png" alt=""></p>
<p>熟悉的題目，大的感人的k。如果依照上面$O(nk)$的做法肯定TLE。<br>俗話說得好 : “好的DP定義是AC的一半”<br>因此經過一系列通靈，我們得到了一個非常漂亮的定義</p>
<h4 id="定義-1"><a href="#定義-1" class="headerlink" title="定義"></a>定義</h4><p> $dp[i] =$ 必須選第 $i$ 家，$($能吃最多的攤販數量，需要的人數$) (dp[i]$是一個$pair)$</p>
<h4 id="轉移式-1"><a href="#轉移式-1" class="headerlink" title="轉移式"></a>轉移式</h4><p>維護一個函數 $L[i]$ ，其實就是樓上的 $f[i]$，但是我比較想要叫他 $L$</p>
<script type="math/tex; mode=display">dp[i] = max_{j<L[i]}(dp[j]) + i - L[i] + 1</script><p>$max(a, b) = a, if(a.first &gt; b.first\ or\ (a.first == b.first\  and\ a.second &gt; b.second))$</p>
<h4 id="優化"><a href="#優化" class="headerlink" title="優化"></a>優化</h4><p>Aliens優化 : 利用penalty限制人數<br>每當有一個人加入，便扣除 $p$ 個攤販的業績<br>當總人數超過 $k$，表示 $p$ 不夠大，仍然有太多人利大於弊<br>反之，當總人數小於 $k$，表示 $p$ 太大，有太多人弊大於利<br>看出來了嗎? $p$ 可以二分搜喔!</p>
<p><strong>時間複雜度：</strong> 二分搜加每次DP $O(nlogn)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ff first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">array&lt;<span class="keyword">int</span>, 100004&gt; A<span class="comment">/*num of stands*/</span>, L<span class="comment">/*leftest stand can eat to*/</span>, cnt<span class="comment">/*count of each num*/</span>;</span><br><span class="line">array&lt;pii, 100004&gt; dp;</span><br><span class="line"><span class="function">pii <span class="title">add</span><span class="params">(pii p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    p.ff += v;</span><br><span class="line">    p.ss++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">max</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.ff == b.ff) <span class="keyword">return</span> a.ss &gt; b.ss? a : b;</span><br><span class="line">    <span class="keyword">return</span> a.ff &gt; b.ff ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">DP</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ff = stands visited, ss = people needed</span></span><br><span class="line">    pii ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; L[i]) ans = <span class="built_in">max</span>(ans, dp[l++]);</span><br><span class="line">        dp[i] = <span class="built_in">add</span>(ans, i - L[i] + <span class="number">1</span> + p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; n) ans = <span class="built_in">max</span>(ans, dp[l++]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = -n, r = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(l != r)&#123;</span><br><span class="line">        <span class="comment">//binary search penalty</span></span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DP</span>(mid).ss &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DP</span>(l).ff - l * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">        cnt[A[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(cnt[A[i]] &gt; <span class="number">1</span>) cnt[A[l++]]--;</span><br><span class="line">        L[i] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">BIS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>APCS 2021.11</title>
    <url>/2021/11/07/APCS%202021.11/</url>
    <content><![CDATA[<h2 id="P1-修補圍籬"><a href="#P1-修補圍籬" class="headerlink" title="P1 修補圍籬"></a>P1 修補圍籬</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g595">題目連結</a></p>
<h3 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h3><p>如果在兩端就直接取旁邊的高度，否則取跟左右邊高度的最小值。</p>
<span id="more"></span>
<h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>$O(n)$</p>
<h3 id="AC程式碼"><a href="#AC程式碼" class="headerlink" title="AC程式碼"></a>AC程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;A[i];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[<span class="number">0</span>] == <span class="number">0</span>)ans += A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(A[n<span class="number">-1</span>] == <span class="number">0</span>)ans += A[n<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == <span class="number">0</span>)ans += <span class="built_in">min</span>(A[i<span class="number">-1</span>],A[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY peienwu</p>
</blockquote>
<h2 id="P2-動線安排-魔王題"><a href="#P2-動線安排-魔王題" class="headerlink" title="P2 動線安排(魔王題)"></a>P2 動線安排(魔王題)</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g596">題目連結</a></p>
<h3 id="題解-1"><a href="#題解-1" class="headerlink" title="題解"></a>題解</h3><p>把線分成橫的跟直的就可以好好處理交叉了!</p>
<h3 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>$O(h(n + m))$</p>
<h3 id="AC程式碼-1"><a href="#AC程式碼-1" class="headerlink" title="AC程式碼"></a>AC程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">array&lt;array&lt;<span class="keyword">int</span>, 104&gt;, 104&gt; R, C, I;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    I[r][c] = <span class="number">1</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span>(C[r][c] || R[r][c]) cnt--;</span><br><span class="line">    C[r][c] = R[r][c] = <span class="number">0</span>;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//直下情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[i][c]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[i][c] || R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">            R[i][c]++;</span><br><span class="line">            cnt += C[i][c] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//直上情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[i][c]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[i][c] || R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">            R[i][c]++;</span><br><span class="line">            cnt += C[i][c] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//橫右情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c + <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[r][i]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c + <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[r][i] || C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">            C[r][i]++;</span><br><span class="line">            cnt += R[r][i] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ok = <span class="number">0</span>;     <span class="comment">//橫左情況</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(I[r][i]) ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[r][i] || C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">            C[r][i]++;</span><br><span class="line">            cnt += R[r][i] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    I[r][c] = <span class="number">0</span>;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)&#123;     <span class="comment">//直下情況</span></span><br><span class="line">        <span class="keyword">if</span>(!R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">        R[i][c]--;</span><br><span class="line">        cnt -= C[i][c] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//直上情況</span></span><br><span class="line">        <span class="keyword">if</span>(!R[i][c]) <span class="keyword">break</span>;</span><br><span class="line">        R[i][c]--;</span><br><span class="line">        cnt -= C[i][c] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c + <span class="number">1</span>; i &lt; m; i++)&#123;     <span class="comment">//橫右情況</span></span><br><span class="line">        <span class="keyword">if</span>(!C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">        C[r][i]--;</span><br><span class="line">        cnt -= R[r][i] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//橫左情況</span></span><br><span class="line">        <span class="keyword">if</span>(!C[r][i]) <span class="keyword">break</span>;</span><br><span class="line">        C[r][i]--;</span><br><span class="line">        cnt -= R[r][i] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, r, c, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">    <span class="keyword">while</span>(h--)&#123;</span><br><span class="line">        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            <span class="built_in">pull</span>(r, c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">add</span>(r, c);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY thanksone</p>
</blockquote>
<h2 id="P3-生產線"><a href="#P3-生產線" class="headerlink" title="P3 生產線"></a>P3 生產線</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g597">題目連結</a></p>
<h3 id="差分作法"><a href="#差分作法" class="headerlink" title="差分作法"></a>差分作法</h3><h4 id="題解-2"><a href="#題解-2" class="headerlink" title="題解"></a>題解</h4><p>用差分的想法加值，再用前綴還原，最後再排序。最後利用Greedy的想法，將每一項最小的工作量乘上最大的時間，總和即為答案。</p>
<div class="note success">
            <p><strong>差分</strong></p><p>差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：</p><script type="math/tex; mode=display">b_i = \begin{cases}a_i-a_{i-1}, &\text{if }i\gt 1 \\a_1, & \text{if } i = 1\end{cases}</script><p>差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：</p><ol><li>定義一個新的陣列 $b_i$ 表示每一項差分</li><li>設 $b[l] =  b[l] + v,b[r+1] = b[r+1] - v$</li><li>將差分的每一項加上前一項（做前綴和 $b[i] = b[i]+b[i-1]$），即為原數列</li></ol><p>第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了$O(1)$了！</p>
          </div>
<h4 id="時間複雜度-2"><a href="#時間複雜度-2" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>差分：$O(m)$ 、排序 $O(n\log n)$</p>
<p>總時間複雜度：$O(n\log n + m)$</p>
<h4 id="AC程式碼-2"><a href="#AC程式碼-2" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,A[N],B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(A));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        A[x] += w;</span><br><span class="line">        A[y+<span class="number">1</span>] -= w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;B[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)A[i] = A[i] + A[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">sort</span>(A+<span class="number">1</span>,A+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(B+<span class="number">1</span>,B+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans += A[i] * B[n-i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY peienwu</p>
</blockquote>
<h3 id="線段樹作法"><a href="#線段樹作法" class="headerlink" title="線段樹作法"></a>線段樹作法</h3><p><img src="https://i.imgur.com/hePctby.png" alt=""></p>
<p>很奇怪，最近兩次的APCS第三題都有人想要砸資結，特別是線段樹，可能有些人特別偏愛線段樹吧！</p>
<h4 id="題解-3"><a href="#題解-3" class="headerlink" title="題解"></a>題解</h4><p>線段樹最原本的應該是區間詢問、單點修改，如果要區間修改的話就會用到<a href="https://peienwu.com/2021/08/05/Segment%20Tree/">懶標</a>，所以實作上相對上比較複雜一點。這一題用線段樹的目的是區間加值，加值完過後的排序以及Greedy跟差分的作法是一樣的，用線段樹真的是多此兩舉（實作較複雜、較耗時）！</p>
<p>當然，這一題比較特別只有最後一起做單點查詢，因此不用懶標，最侯直接計算一路去經過的答案也行！下面的程式碼就是把完全包含區間的節點加值，不用使用到懶標，最後一次查詢。</p>
<h4 id="時間複雜度-3"><a href="#時間複雜度-3" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>區間加值 $O(m\log n)$，n個點的詢問 $O(n\log n)$，排序 $O(n\log n)$</p>
<p>總時間複雜度：$O((n+m)\log n)$</p>
<h4 id="AC程式碼-3"><a href="#AC程式碼-3" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,t,A[N],B[N],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>,sz;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[id].sz = r - l;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(id*<span class="number">2</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l || r &lt;= ql || l &gt;= qr)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        seg[id].val += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(id*<span class="number">2</span>,l,mid,ql,qr,val);</span><br><span class="line">    <span class="built_in">modify</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l)<span class="keyword">return</span>;</span><br><span class="line">    ans += seg[id].val;</span><br><span class="line">    <span class="keyword">if</span>(r - l == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; mid)<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>,l,mid,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid,r,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,i);</span><br><span class="line">        A[i] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;B[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(A+<span class="number">1</span>,A + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(B+<span class="number">1</span>,B + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans += A[i] * B[n-i+<span class="number">1</span>];</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P4-真假子圖"><a href="#P4-真假子圖" class="headerlink" title="P4 真假子圖"></a>P4 真假子圖</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=g598">題目連結</a></p>
<h3 id="二分搜尋-DFS作法"><a href="#二分搜尋-DFS作法" class="headerlink" title="二分搜尋+DFS作法"></a>二分搜尋+DFS作法</h3><h4 id="題解-4"><a href="#題解-4" class="headerlink" title="題解"></a>題解</h4><p>一開始看到這題，應該很難通靈出二分搜這個作法（我覺得光把題目看懂就有點難度了）。這題有一個條件要特別注意：</p>
<blockquote>
<p>保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合</p>
<p>這一題每一個觀察員並可看成不是獨立的（假如一個觀察員不產生矛盾，則他回傳的那一些邊都會被沿用），所以題目 $p$ 筆詢問可以聯集一起處理。</p>
</blockquote>
<p>將情報員當成點，合作關係當成邊，那麼合法的圖就會有兩個點集，點集中的點互不相鄰，也就是二分圖。</p>
<p>二分搜第一個使得圖變得不二分的人，把它消失，<strong>最多重複3次</strong>就做完了。</p>
<div class="note info">
            <p><strong>為什麼可以二分搜？</strong><br>二分搜是用來找一串01字串的分界點，並且必須具有單調性才能二分搜。這一題之所以會有單調性是因為，當我查詢觀察員$P_i$的回傳資料是否正確時，會將前面 $1$ 到 $i-1$ 的觀察員回傳的所有邊納入考慮。</p><p>假設有一個觀察員 $P_j(1\le j &lt; i)$ 回傳的資料是錯誤的，這些邊會導致整張圖變成非二分圖，對於 $j$ 後面的所有點來說，都是非二分圖。這樣就有了以 $j$ 為分界點的單調性，即可二分搜。</p>
          </div>
<p>二分圖判斷可以用 DFS 做，DFS 的時候把每個點塗上顏色，如果相鄰的點跟自己顏色一樣就表示這不是一張二分圖。</p>
<h4 id="時間複雜度-4"><a href="#時間複雜度-4" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>$O((n + m + pk)\log p)$</p>
<h4 id="AC程式碼-4"><a href="#AC程式碼-4" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">array&lt;<span class="keyword">bool</span>, 10004&gt; WA;          <span class="comment">//不可行的觀察員編號</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, 20004&gt; vis;          <span class="comment">//DFS是否走訪、二分圖顏色</span></span><br><span class="line">array&lt;vector&lt;e&gt;, 10004&gt; E;      <span class="comment">//每一個觀察員的回傳邊</span></span><br><span class="line">array&lt;vector&lt;<span class="keyword">int</span>&gt;, 20004&gt; G;    <span class="comment">//存進行DFS的圖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span></span>&#123;         <span class="comment">//用DFS塗色、判斷二分圖</span></span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="number">1</span>;</span><br><span class="line">    vis[u] = t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] == t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans &amp;= <span class="built_in">dfs</span>(v, <span class="number">3</span> - t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;               <span class="comment">//檢查第p個觀察員回傳是否正確</span></span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [u, v] : E[i])&#123; <span class="comment">//將觀察員的邊推入G</span></span><br><span class="line">            G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">            G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans &amp;= <span class="built_in">dfs</span>(i, <span class="number">1</span>);        <span class="comment">//將每一個連通塊</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;           <span class="comment">//二分搜觀察員</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(r)) <span class="keyword">return</span>;         <span class="comment">//當邊的連集不會讓圖有問題，則回傳</span></span><br><span class="line">    <span class="keyword">while</span>(l != r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    WA[l] = <span class="number">1</span>;</span><br><span class="line">    E[l].<span class="built_in">clear</span>();                <span class="comment">//剔除一錯誤觀察員</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, p, k, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        E[<span class="number">0</span>].<span class="built_in">pb</span>(&#123;a, b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            E[i].<span class="built_in">pb</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;     <span class="comment">//至多三個觀察員</span></span><br><span class="line">        <span class="built_in">BS</span>(<span class="number">0</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(WA[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY thanksone</p>
</blockquote>
<h3 id="DSU作法"><a href="#DSU作法" class="headerlink" title="DSU作法"></a>DSU作法</h3><blockquote>
<p>Idea From Kennyfs</p>
</blockquote>
<h4 id="題解-5"><a href="#題解-5" class="headerlink" title="題解"></a>題解</h4><p>這一題的題目限制有說最多3個錯誤的情報員，因此我們可以用上面二分搜的方式做三次找到答案。如果題目<strong>不限制錯誤調查員的數量</strong>，也就是用二分搜時間會超時，但是用DSU可以在線性時間內完成！</p>
<p>DSU的目的在處理集合問題，根據下面這個關鍵條件：</p>
<blockquote>
<p>保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合</p>
</blockquote>
<p>我們只要對每一筆詢問看會不會與組長手中的pair矛盾即可。如果每一次都做DFS，會發現時間複雜度是 $O(pn)$，必然超時。</p>
<p>DSU的想法是，我們將組長手中的圖中上每一個連通塊都分別塗上兩種顏色（必為二分圖，因此將兩邊各塗上不同顏色）。接著，把每個顏色當作初始的並查集中的集合，將每一筆觀察員回傳的邊的兩端指向的集合合併起來，過程中如果發生邊的兩端同屬一個集合，表示這是一個錯誤的觀察員。做完每一個觀察員之後，把所有變更過的還原成初始狀態（組長手中的圖）即可。</p>
<div class="note success">
            <p><strong>舉例</strong></p><blockquote><p>8 5<br>0 2 1 3 1 2 4 6 5 6<br>1 2<br>1 4 0 6</p></blockquote><p>整個過程就是下面這張GIF：<br><img src="https://i.imgur.com/gLpSD6p.gif" alt=""></p><p>步驟：</p><ol><li>利用DFS為組長手中的圖上色，每一個連通塊兩色（以編號1,2,3…）</li><li>將每一個顏色當作並查集元素</li><li>觀察員輸入的邊兩端 $(u,v)$非同色，表示不發生矛盾，則將u所在集合與v所在集合的對方（連通塊兩色的另一色）合併</li><li>重複 步驟3 共k次，如果發生$(u,v)$為同一色，則觀察員錯誤。</li></ol>
          </div>
<h4 id="時間複雜度-5"><a href="#時間複雜度-5" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>$O(n + pk\alpha)$</p>
<h4 id="AC程式碼-5"><a href="#AC程式碼-5" class="headerlink" title="AC程式碼"></a>AC程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,p,k;</span><br><span class="line"><span class="keyword">int</span> color[N],boss[N],num[N];</span><br><span class="line"><span class="keyword">bool</span> WA[M],f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="keyword">return</span> (s%<span class="number">2</span>)?s+<span class="number">1</span>:s<span class="number">-1</span>;&#125; <span class="comment">//other為同一連通塊另外一種顏色</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N],change;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;                            <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(color));</span><br><span class="line">    <span class="built_in">memset</span>(WA,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(WA));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> col)</span></span>&#123;           <span class="comment">//對所有點上色</span></span><br><span class="line">    color[id] = col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[id])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])<span class="built_in">dfs</span>(i,<span class="built_in">other</span>(col));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_boss</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;              <span class="comment">//尋找祖先、及路徑壓縮</span></span><br><span class="line">    <span class="keyword">if</span>(boss[id] == id)<span class="keyword">return</span> id;</span><br><span class="line">    change.<span class="built_in">push_back</span>(id);</span><br><span class="line">    <span class="keyword">return</span> boss[id] = <span class="built_in">find_boss</span>(boss[id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        edge[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        edge[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;           <span class="comment">//對所有點上色</span></span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i,now);now += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=now;i++)&#123;boss[i] = i;num[i] = <span class="number">1</span>;&#125;</span><br><span class="line">    cin&gt;&gt;p&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        change.<span class="built_in">clear</span>();                                  <span class="comment">//儲存待更改的點集f = 0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(f)<span class="keyword">continue</span>;</span><br><span class="line">            x = color[x],y = color[y];                   <span class="comment">//尋找邊兩端點的顏色所處的集合</span></span><br><span class="line">            <span class="keyword">int</span> bx =  <span class="built_in">find_boss</span>(x),by = <span class="built_in">find_boss</span>(y);</span><br><span class="line">            <span class="keyword">int</span> ox = <span class="built_in">find_boss</span>(<span class="built_in">other</span>(y)),oy = <span class="built_in">find_boss</span>(<span class="built_in">other</span>(x));</span><br><span class="line">            <span class="keyword">if</span>(bx == by)&#123;WA[i] = <span class="number">1</span>;f = <span class="number">1</span>;<span class="keyword">continue</span>;&#125;     <span class="comment">//位於同一集合，此觀察員是錯的</span></span><br><span class="line">            <span class="comment">//以下是啟發式合併（小的集合並到大的集合）</span></span><br><span class="line">            <span class="keyword">if</span>(num[bx] &lt; num[ox])&#123;</span><br><span class="line">                boss[bx] = ox;num[ox] += num[bx];</span><br><span class="line">                change.<span class="built_in">push_back</span>(bx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                boss[ox] = bx;num[bx] += num[ox];</span><br><span class="line">                change.<span class="built_in">push_back</span>(ox);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num[by] &lt; num[oy])&#123;</span><br><span class="line">                boss[by] = oy;num[oy] += num[by];</span><br><span class="line">                change.<span class="built_in">push_back</span>(by);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                boss[oy] = by;num[by] += num[oy];</span><br><span class="line">                change.<span class="built_in">push_back</span>(oy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : change)&#123;boss[i] = i;num[i] = <span class="number">1</span>;&#125;   <span class="comment">//觀察員的邊結束，看完後復原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)<span class="keyword">if</span>(WA[i])cout&lt;&lt;i&lt;&lt;endl;        <span class="comment">//輸出最後錯誤觀察員答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BY peienwu</p>
</blockquote>
]]></content>
      <categories>
        <category>APCS檢定</category>
      </categories>
      <tags>
        <tag>APCS</tag>
        <tag>競賽筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>計算幾何(Computational Geometry)</title>
    <url>/2021/08/20/Geomertry/</url>
    <content><![CDATA[<p>暑假剩沒多少天了，趕緊追進度啊！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="座標與向量"><a href="#座標與向量" class="headerlink" title="座標與向量"></a>座標與向量</h3><ul>
<li>長度、角度、座標、向量</li>
<li>最常以座標、向量表示<span id="more"></span></li>
<li>Define x first, y second</li>
<li>內積Dot：$A \cdot B = A_xB_x+A_yB_y$</li>
<li>外積Cross：$A \times B = A_xB_y-A_yB_x$</li>
<li>運算子重載：加減乘除、取純量（$abs()$）</li>
</ul>
<h3 id="有向面積"><a href="#有向面積" class="headerlink" title="有向面積"></a>有向面積</h3><ul>
<li>用外積算面積（有正負：有向面積）</li>
<li>逆時針為正、順時針為負</li>
<li>多邊形面積：任選平面上一點A，將所有點與A連線</li>
<li>透過順、逆加總有向面積（p0,p1…pn,其中p0=pn）</li>
<li>AREA = $\frac{1}{2}\sum<em>{i=0}^{N-1}\vec{P_i}\times\vec{P</em>{i+1}}$</li>
</ul>
<h3 id="線段相交"><a href="#線段相交" class="headerlink" title="線段相交"></a>線段相交</h3><ul>
<li>線段不平行：$P_1$ 與$P_2$ 會在線段$P_3$、$P_4$異側（方向函數）</li>
<li>線段平行：檢驗是否共線、並確認某一個點是否在線段上</li>
</ul>
<h3 id="誤差分析：EPS"><a href="#誤差分析：EPS" class="headerlink" title="誤差分析：EPS"></a>誤差分析：EPS</h3><ul>
<li>使用二進位儲存：必產生誤差</li>
<li>精度：float $10^{-7}$, double $10^{-16}$, long double $10^{-19}$</li>
<li>誤差容忍值$eps$，將 $x\pm eps$視為 $x$</li>
<li>重載運算子：==（視為相等）,&gt;,&lt;，加上誤差範圍</li>
<li>Eps大小：多落在 $10^{-6}$到 $10^{-12}$ 之間</li>
<li>誤差：加減法，絕對誤差相加；乘除法，相對誤差相加</li>
<li>下界：數字範圍為V內時，$eps$ 至少要VK 乘上資料型態本身誤差</li>
<li>上界：題目一般會給</li>
<li>避免誤差大法：非到最後關頭，否則都用整數運算！</li>
</ul>
<h3 id="三角函數"><a href="#三角函數" class="headerlink" title="三角函數"></a>三角函數</h3><ul>
<li>泰勒展開式逼近，時間並非O(1)</li>
<li>$atan2(y,x) = \theta$，回傳值域$(-pi,pi]$</li>
<li>回傳long double ：使用$atan2l(y,x)$</li>
<li>常數大，不建議使用</li>
</ul>
<h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><ul>
<li>Sign, Exponent, Mantissa</li>
<li>正負號、指數部分、小數部分</li>
</ul>
<h3 id="極角排序"><a href="#極角排序" class="headerlink" title="極角排序"></a>極角排序</h3><ul>
<li>給定很多點，依照與某特定點（原點）的角度進行排序</li>
<li>Sort by cross，依照內積排序</li>
<li>題目：平面上n個點，問一條直線最多通過幾個點 </li>
</ul>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><ul>
<li>多邊形：簡單多邊形（邊不相交）、凸多邊形（內角都≤180）、凹多邊形（有內角&gt;180）</li>
<li>能包住所有點的凸多邊形</li>
<li>凸包求法：Monotone Chain（二維平面）、DC（三維）</li>
<li><strong>Monotone Chain</strong><ul>
<li>將所有點按照(x,y)排序</li>
<li>把下凸包、上凸包「圍」出來</li>
<li>合併下凸包、上凸包</li>
<li>開一個vector（功能為stack）紀錄當前下半凸包</li>
<li>檢查新加入的點會讓哪些點不再是凸包上的點</li>
</ul>
</li>
</ul>
<h3 id="模擬退火-SA"><a href="#模擬退火-SA" class="headerlink" title="模擬退火(SA)"></a>模擬退火(SA)</h3><ul>
<li>尋找空間中近似最優解</li>
<li>一個隨機算法</li>
<li>例題：給你平面上 N 個點，請你找出一個點，使得這個點連到這 N 個點的距離總和最短</li>
</ul>
<h2 id="計算幾何函式模板"><a href="#計算幾何函式模板" class="headerlink" title="計算幾何函式模板"></a>計算幾何函式模板</h2><p>計算幾何最重要的莫過於座標上的點，實作方式可以用 $std::pair$ 或是自己定義一個類別，將點的資訊以及相關的運算式定義出來。我們總共需要重載點的大於、等於、小於的運算子，以及加法減法、向量外積內積等，同時還有很多功能是可以繼續定義下去，例如向量乘上一個定值，可以繼續加入類別中。</p>
<h3 id="點的模板及運算子重載"><a href="#點的模板及運算子重載" class="headerlink" title="點的模板及運算子重載"></a>點的模板及運算子重載</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-b.x)&lt;=eps &amp;&amp; <span class="built_in">abs</span>(y-b.y)&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上是預設點的x座標y座標都是整數的情況，如果要改成使用自定義型別，可以改用樣板(Template)自定義資料型別，根據題目的要求，使用整數或是浮點數進行運算。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    T x,y;</span><br><span class="line">    <span class="comment">//下方運算子重載與上方相同</span></span><br><span class="line">&#125;</span><br><span class="line">pt&lt;<span class="keyword">int</span>&gt; p[N];        <span class="comment">//點座標宣告為整數</span></span><br><span class="line">pt&lt;<span class="keyword">double</span>&gt; pp[N];    <span class="comment">//點的不同資料型別宣告</span></span><br></pre></td></tr></table></figure></p>
<h3 id="方向函數"><a href="#方向函數" class="headerlink" title="方向函數"></a>方向函數</h3><p>針對 $\vec a$ 以及 $\vec b$ 外積的結果，可以知道兩者之間相對的方向。如果 $\vec a$ 和 $\vec b$ 共線，則回傳0，$\vec a$ 轉向 $\vec b$ 如果是順時針則回傳1，其餘回傳-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;                         <span class="comment">//方向函數</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="點與線段關係"><a href="#點與線段關係" class="headerlink" title="點與線段關係"></a>點與線段關係</h3><p>以下函式可以判斷點o是否在 $\overline{AB}$ 上，首先利用外積是否為0判斷是 $\overline{OA}$ 與 $\overline{OB}$ 是否平行；接著以內積判斷是否在線段中，而非線段的兩側（平行的條件下內積只可能是1或是-1）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;         <span class="comment">//o是否在ab線段上</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);    <span class="comment">//是否平行</span></span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);      <span class="comment">//是否在線段中</span></span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>)&amp;&amp;(dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="線段相交-1"><a href="#線段相交-1" class="headerlink" title="線段相交"></a>線段相交</h3><p>以下函式為給定四個點$A,B,C,D$，判斷 $\overline{AB}$ 是否相交於 $\overline{CD}$。首先是特例的判斷，線段的其中一端點在另一線段上，利用上方點與線段關係的函式完成這個判斷。</p>
<p>特例判斷完成之後，我們需要用到上方方向函式判斷線段兩端點是否在另一條線段的異側，即以下的關係式：</p>
<script type="math/tex; mode=display">dir(A,B,C)\times dir(A,B,D) < 0</script><p>我們要檢查兩條線段，其相乘結果必須皆為負數，表示處於線段的異側！最後是平行線的判斷，如果兩線平行且相交，表示兩線共線，這可以在特例時就被判斷出來。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(pt a, pt b, pt c, pt d)</span></span>&#123;      <span class="comment">//線段ab是否與cd相交</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c)||<span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點c、d是否洽在線段ab上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a)||<span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點a、b是否洽在線段cd上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c)*<span class="built_in">dir</span>(a,b,d)==<span class="number">-1</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a)*<span class="built_in">dir</span>(c,d,b)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">//對於線段兩端點看另外兩端點必須方向相反</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="極角排序-1"><a href="#極角排序-1" class="headerlink" title="極角排序"></a>極角排序</h3><p>在進行全點對線段共線問題的判斷時，使用極角排序通常會比單純暴力枚舉更快速。極角也就是極座標中每一個跟原點的夾角。如果兩個點位在左半平與右半平面，則先將其判斷出來，如此才能確定起始的角度為何。</p>
<p>如果位在同一個左右半平面，則透過外積的方式比較兩個向量的先後順序。以下程式碼是從座標平面270度的地方開始逆時針掃一圈依序經過的點。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f1 = a &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> f2 = b &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)<span class="keyword">return</span> f1 &lt; f2;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆時針將點進行極角排序，從270度開始逆時針</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);     <span class="comment">//以id為原點進行極角排序</span></span><br></pre></td></tr></table></figure>
<h3 id="凸包函數（使用Monotone-Chain）"><a href="#凸包函數（使用Monotone-Chain）" class="headerlink" title="凸包函數（使用Monotone Chain）"></a>凸包函數（使用Monotone Chain）</h3><p>首先先將所有點依照x座標進行排序，之後用掃描線由左而右的將符合要求的點推入維護的單調容器中，維護下凸包，接著利用reverse()函數將所有點逆序，也就是x座標由大到小讓掃描線由右而左掃過一遍，將上凸包也圍起來。時間複雜度為$O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa ^ bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; hull;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;                       <span class="comment">//起點會經過兩次，剛好來算有向面積</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋轉卡尺"><a href="#旋轉卡尺" class="headerlink" title="旋轉卡尺"></a>旋轉卡尺</h3><p>旋轉卡尺可以被應用在尋找最遠點對、面積最大三角形等問題。利用兩條平行的線中間夾著凸包，繞一圈的過程中更新需要求的數值。實作上來說就是使用兩個指針，分別指向旋轉卡尺的平行線所在的兩個點，依照旋轉的方向進行增減的動作！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa = <span class="built_in">abs</span>((a - c)^(b - c));</span><br><span class="line">    <span class="keyword">int</span> bb = <span class="built_in">abs</span>((a - d)^(b - d));</span><br><span class="line">    <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,d = h,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">check2</span>(hull[i],hull[(i+<span class="number">1</span>)%sz],hull[d],hull[(d+<span class="number">1</span>)%sz]))</span><br><span class="line">            d = (d+<span class="number">1</span>)%sz;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,(hull[i]-hull[d]).<span class="built_in">dis</span>());</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,(hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本數學知識"><a href="#基本數學知識" class="headerlink" title="基本數學知識"></a>基本數學知識</h2><p>計算幾何圍繞著幾個主軸，向量運算、內積、外積，利用它們進行角度、共線與否、距離等等的判斷。之前有稍微接觸過向量，不過內積與外積是第一次碰到的主題。</p>
<p>因為目前絕大部分的討論都是在二維平面上進行，因此以下都是以二維平面為前提所進行的討論！</p>
<h3 id="內積（點積）"><a href="#內積（點積）" class="headerlink" title="內積（點積）"></a>內積（點積）</h3><p>內積跟 $\cos\theta$ 有關，因此主要可以幫助我們判斷線段是否垂直（等於零）、以及共線時點位於正向或是反向的判斷（等於正負一）。兩個向量 $\vec u$ 以及 $\vec v$ 的內積可以寫成以下關係式：</p>
<script type="math/tex; mode=display">\vec u\cdot \vec v = |\vec u||\vec v|\cos\theta = u_1v_1 + u_2v_2</script><p>兩個向量做內積的正負號會跟餘弦函數的正負變化相同（如下圖），值域為 $[-|\vec u||\vec v|,|\vec u||\vec v|]$，並且在 $\theta = 0,\pi$ 有最大最小值，$\theta = \frac{\pi}{2},\frac{3\pi}{2}$ 的值為零。</p>
<p><img src="https://i.imgur.com/Si0hlNr.png" alt=""></p>
<h3 id="外積（叉積）"><a href="#外積（叉積）" class="headerlink" title="外積（叉積）"></a>外積（叉積）</h3><p>外積跟 $\sin\theta$ 有關，主要可以判斷兩向量方向關係（順逆時針旋轉）、是否平行、比較角度大小等。外積的應用十分廣泛，找凸包以及旋轉卡尺都會用到外積判斷兩個向量角度關係。兩個向量 $\vec u$ 以及 $\vec v$ 的外積可以寫成以下關係式：</p>
<script type="math/tex; mode=display">\vec u\times \vec v = |\vec u||\vec v|\sin\theta = \begin{bmatrix}u_1&u_2\\v_1&v_2\end{bmatrix}=u_1v_2 - u_2v_1</script><p>用更簡單的方式理解外積 $\vec u\times \vec v$ ，其正負值可以想像成 $\vec u$ 轉向 $\vec v$ 所經的劣弧順逆時鐘方向。順時針為正、逆時針為負。</p>
<p>關於外積的數值變化，與正弦函數的變化是一樣的（下圖），其值域跟內積一樣，不過最大最小值發生在 $\theta = \frac{\pi}{2},\frac{3\pi}{2}$，並在 $\theta = 0,\pi$ 時兩向量叉積為零。</p>
<p><img src="https://i.imgur.com/ozKfaKL.png" alt=""></p>
<h3 id="面積"><a href="#面積" class="headerlink" title="面積"></a>面積</h3><h4 id="測量師公式（行列式）"><a href="#測量師公式（行列式）" class="headerlink" title="測量師公式（行列式）"></a>測量師公式（行列式）</h4><p>這是一個從給定多邊形的座標推得面積的公式，寫成很多個三角形有向面積的總和。以下圖來說，$\triangle FBC$、$\triangle FCD$ 、$\triangle FDE$ 的有向面積皆大於零，而 $\triangle FAB$、$\triangle FEA$ 都會因為有向面積是負的（逆時針旋轉）而被扣除掉，運算的總和即是多邊形 $ABCDE$ 的面積！</p>
<p><img src="https://i.imgur.com/did2OzY.png" alt=""></p>
<p>一般化的公式，多邊形上總共有 $N$ 個點，令第 $N+1$ 個點為第1個點（為了要繞一圈計算面積），多邊形面積為：</p>
<script type="math/tex; mode=display">AREA = \frac{1}{2}\sum_{i=1}^{N}\vec{P_i}\times\vec{P_{i+1}}</script><h4 id="三角形外積面積公式"><a href="#三角形外積面積公式" class="headerlink" title="三角形外積面積公式"></a>三角形外積面積公式</h4><p>三角形面積有非常多算法，不過利用外積的公式還是第一次聽到。以下是公式推導過程：</p>
<p>先從高中三角函數的三角形公式開始：</p>
<script type="math/tex; mode=display">\begin{split}\triangle ABC &= \frac{1}{2}\overline{AB}\,\overline{AC}\cdot\sin A
\\&=\frac{1}{2}\sqrt{\overline{AB}^2\,\overline{AC}^2\,(1-\cos^2A)}
\\&=\frac{1}{2}\sqrt{\overline{AB}^2\,\overline{AC}^2-(\overline{AB}\cdot\overline{AC})^2}
\\&=\frac{1}{2}\sqrt{(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1\,x_2+y_1\,y_2)^2}
\\&=\frac{1}{2}\sqrt{(x_1^2\,y_2^2)+(x_2^2\,y_1^2)-2x_1\,y_2\,x_2\,y_1}
\\&=\frac{1}{2}\sqrt{[(x_1\,y_2)-(x_2\,y_1)]^2}
\\&=\frac{1}{2}|\overrightarrow{AB}\times \overrightarrow{AC}|\end{split}</script><p>將三角形其中一點對另外兩點的向量做外積，除以2即為三角形面積。這個公式會在旋轉卡尺的地方使用到！</p>
<h4 id="平行四邊形面積"><a href="#平行四邊形面積" class="headerlink" title="平行四邊形面積"></a>平行四邊形面積</h4><p>根據上面三角形面積公式的推導，可以相對應得知道兩向量所夾平行四邊形面積公式：</p>
<script type="math/tex; mode=display">AREA = |\overrightarrow{AB}\times \overrightarrow{AC}|</script><p><img src="https://i.imgur.com/9mUdyV6.png" alt=""></p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>計算幾何</category>
      </categories>
      <tags>
        <tag>計算幾何</tag>
        <tag>暑期筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>2020資訊之芽—線段樹(Segment Tree)</title>
    <url>/2021/08/05/Segment%20Tree/</url>
    <content><![CDATA[<p>今年是2021，資芽的二階主題跟2020上的有很多的差別，因此會利用暑假把2020的東西也補一補！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="儲存"><a href="#儲存" class="headerlink" title="儲存"></a>儲存</h3><p>線段樹很多人都用陣列來實作，空間$O(n)$，在處理樹的左右節點也十分的方便。如果以1-base來儲存陣列這棵線段樹，左右節點可以用以下的index來表示。線段樹有一個優點就是它可以用儲存完滿二元樹的方式來儲存，雖然它不一定是完滿但會是平衡的一棵樹。左節點：$2n$，右節點$2n+1$。<br><img src="https://i.imgur.com/PxXXqsl.png" alt=""><br><span id="more"></span></p>
<h3 id="空間大小"><a href="#空間大小" class="headerlink" title="空間大小"></a>空間大小</h3><p>一般來說線段樹的陣列會開$seg[4\times n]$，由以下證明得到的結果：</p>
<div class="note default">
            <p>對於一個有$2^k$的葉節點數的一棵樹，總共的節點共有 $\sum_{i=0}^k 2^i = 2^{k+1}-1$ 個節點。若今天陣列共有n個元素，則代表葉節點共有$2^{\lceil \log_2 n\rceil}$ 個，總節點數量共有$2^{\lceil \log_2 n\rceil+1}-1$ 個。<br>假設$n = 2^k+p,0≤p≤2^k$，則帶入前面公式 $2^{\lceil \log_2 n\rceil}=2^{k+1}$，根據前面推得的總節點數可以知道為 $2^{k+2}-1$，其值恆小於$4n$，因此開$4n$的陣列一定可以容納整個線段樹。</p>
          </div>
<p>由以上推倒可以知道一般都會開$seg[4\times n]$，但是如果n剛好是二的冪次，其實只會用到$2n$的空間，有一半會被浪費掉，不過沒差，因為多開總比少開來得好！<br><a href="https://gist.github.com/peienwu/368723520e3c39e4e0edc27a0823da69">懶標線段樹程式碼連結</a>，懶標這東西實在折磨人，學長寫的一個堪稱不用下推的懶標程式碼，結果他是錯的！！！害我Debug超久，可惡<br><img src="https://i.imgur.com/mEY8cFD.png" alt=""><br>這是學長的query程式碼，可以看到他回傳的是$(r-l)\times lazy[cur]$，這是錯誤的，因為不一定左右兩子樹都會被全部加上懶標的值（可能只會有部分交集），但這份code卻直接加上去，會多算而WA，要注意！<br><img src="https://i.imgur.com/nsd2KVP.png" alt=""><br>更改版，對區間取聯集應該就對了！</p>
<h3 id="實作部分"><a href="#實作部分" class="headerlink" title="實作部分"></a>實作部分</h3><p>這個版本是用struct實作，比起用陣列實作，這個版本更為方便閱讀，容易理解。為了方便索引值查詢左右子樹，使用1-base來儲存線段樹，同時利用一個struct儲存每一個節點。同時，每一個區間採用的是左閉右開 $[l,r)$，區間和的實作如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>            <span class="comment">//線段樹每一個節點</span></span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>,tag=<span class="number">0</span>,sz; <span class="comment">//val原本的值、tag懶標、sz區間大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rv</span><span class="params">()</span></span>&#123;           <span class="comment">//回傳實際節點的值</span></span><br><span class="line">        <span class="keyword">return</span> val+tag*sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br></pre></td></tr></table></figure></p>
<h4 id="建立-Build"><a href="#建立-Build" class="headerlink" title="建立(Build)"></a>建立(Build)</h4><p>分別遞迴建立左右子樹，同時更新每一個節點的大小sz。因為是左閉右開，直接左右相減r-l即可完成更新。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;    <span class="comment">//建立線段樹</span></span><br><span class="line">    seg[cur].sz = r-l;              <span class="comment">//更新節點的大小</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;                 <span class="comment">//空區間回傳</span></span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;                     <span class="comment">//設定當前節點的值</span></span><br><span class="line">        seg[cur].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;                <span class="comment">//分別遞迴建立左右子樹</span></span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].val+seg[<span class="number">2</span>*cur+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="下推-push"><a href="#下推-push" class="headerlink" title="下推(push)"></a>下推(push)</h4><p>懶標真是驚人的想法，在區間修改的時候以$O(logn)$在要修改的區間先懶標標記起來，等到要query的時候把懶標推下去，這樣可以確保區間修改的複雜度是$O(logn)$，同時query的時候順便下推，一來比較好實作、二來複雜度也不會有什麼改變， 因為下推的複雜度是$O(1)$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把id的懶標在query的時候往下推</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    seg[<span class="number">2</span>*id].tag += seg[id].tag;   <span class="comment">//左子樹懶標更新</span></span><br><span class="line">    seg[<span class="number">2</span>*id+<span class="number">1</span>].tag += seg[id].tag; <span class="comment">//右子樹懶標更新</span></span><br><span class="line">    seg[id].val = seg[id].<span class="built_in">rv</span>();     <span class="comment">//更新實際值</span></span><br><span class="line">    seg[id].tag = <span class="number">0</span>;                <span class="comment">//往下推完之後設定為預設</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="區間詢問-query"><a href="#區間詢問-query" class="headerlink" title="區間詢問(query)"></a>區間詢問(query)</h4><p>這裡的重點是下推，如果把懶標下推，可以確保區間修改的時間是$O(logn)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">//空集合直接回傳</span></span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur].<span class="built_in">rv</span>();     <span class="comment">//包含在要詢問的範圍中，回傳實際值</span></span><br><span class="line">    <span class="built_in">push</span>(cur);                                  <span class="comment">//將懶標在遞迴下去的過程中下推</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;                          <span class="comment">//遞迴查詢左右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr)+<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="區點修改-modify"><a href="#區點修改-modify" class="headerlink" title="區點修改(modify)"></a>區點修改(modify)</h4><p>可以這樣理解，在區間修改中，透過遞迴完左右子樹拉上來的過程中，更新樹上較上方的節點的值（用懶標更新）。此時下方節點都還沒有被更新，等到query的時候會往下push順便把值也一起更新。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//區間修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=l||ql&gt;=r||qr&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;</span><br><span class="line">        seg[cur].tag += val;               <span class="comment">//將被完整包含的區間的懶標加上修改值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ql,qr,val);          <span class="comment">//修改左右子樹</span></span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);        <span class="comment">//遞迴完拉上來的過程中把上面的數值更新成有懶標的結果</span></span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].<span class="built_in">rv</span>()+seg[<span class="number">2</span>*cur+<span class="number">1</span>].<span class="built_in">rv</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="單點修改-modify"><a href="#單點修改-modify" class="headerlink" title="單點修改(modify)"></a>單點修改(modify)</h4><p>這一題沒有要求單點修改，所以以下是RMQ的單點修改。概念較為簡單，用$O(logn)$找到要修改的點，直接修改即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ind,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span> &amp;&amp; l==ind)&#123;</span><br><span class="line">        seg[cur]=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind&lt;mid)<span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ind,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ind,val);</span><br><span class="line">    seg[cur] = <span class="built_in">min</span>(seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="動態開點"><a href="#動態開點" class="headerlink" title="動態開點"></a>動態開點</h3><blockquote>
<p>有一個長度是 $10^9$ 的序列，一開始裡面的元素都是$0$，有 $Q$ 筆操作，每一個操作是以下其中兩種：</p>
<ol>
<li>把之間的值都加上$v$ </li>
<li>詢問的區間和</li>
</ol>
</blockquote>
<p>開這麼多點顯然會MLE，既然使用陣列型儲存線段樹會爆，因為這麼大的值域顯然有許多點是不會被使用到的，那就改成使用指標型來開這個線段樹，以下為每一個節點的架構：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node *l;    <span class="comment">//指向左子樹</span></span><br><span class="line">    Node *r;    <span class="comment">//指向右子樹</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//維護區間和</span></span><br><span class="line">    </span><br><span class="line">&#125;;<span class="comment">//注意struct裡面可有struct的指標，但不能有實體</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>線段樹</category>
      </categories>
      <tags>
        <tag>2020資訊之芽</tag>
        <tag>2021暑假筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>2020資訊之芽—最短路徑(Shortest Path)</title>
    <url>/2021/08/15/Shortest_Path/</url>
    <content><![CDATA[<p>今年是2021，資芽的二階主題跟2020上的有很多的差別，因此會利用暑假把2020的東西也補一補！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="路徑與權重"><a href="#路徑與權重" class="headerlink" title="路徑與權重"></a>路徑與權重</h3><ul>
<li>$G=(V,E)$</li>
<li>尋找最短路徑權重和最小</li>
<li>無帶權：BFS直接做(or DFS)</li>
<li>有帶權最短路徑<span id="more"></span>
</li>
</ul>
<h3 id="Floyd-Warshall：全點對最短路徑-All-Pairs"><a href="#Floyd-Warshall：全點對最短路徑-All-Pairs" class="headerlink" title="Floyd-Warshall：全點對最短路徑(All Pairs)"></a>Floyd-Warshall：全點對最短路徑(All Pairs)</h3><ul>
<li>不支援負環</li>
<li>想法：DP轉移（三個迴圈中點、起點、終點依序鬆弛）</li>
<li>$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$</li>
<li>如果改寫成定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路</li>
<li>則轉移：$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$</li>
<li>因此中間點k必須在最外層（不過<a href="https://arxiv.org/pdf/1904.01210.pdf">有論文指出</a>順序顛倒一樣可以得到正確解）</li>
<li>優點：實作容易，缺點：時間 $O(v^3)$ 、無法處理負環（可處理負邊）</li>
</ul>
<h3 id="Dijkstra’s：單點源最短路徑"><a href="#Dijkstra’s：單點源最短路徑" class="headerlink" title="Dijkstra’s：單點源最短路徑"></a>Dijkstra’s：單點源最短路徑</h3><ul>
<li>優點：時間 $O(E+V^2)$、無法處理負邊</li>
<li>想法：Greedy（和DP）</li>
<li>維護：1. 未拜訪的節點集合$U$ 2. $d[i]$ 目前起點到 $i$ 最短路 3. 目前考慮節點 $p$</li>
<li>重複以下動作直到u為空：<ul>
<li>對於所有與 $p$ 連接的節點 $q$，$d[q] = min(d[q],d[p]+weight[p][q])$</li>
<li>當 $p$ 相鄰節點都走過：在 $u$ 中移除 $p$</li>
<li>將 $p$ 更新成U中離起點距離最短的點 $min(d[j])$</li>
</ul>
</li>
<li>可以變成 $O((E+V)logV)$-&gt;邊較為稀疏的圖時有利（使用priority_queue）</li>
<li>不能處理負邊，因為 $d[i]$ 較小的處理完之後就不會再更動了，加入負邊可能更小</li>
<li>拿距離最小的點 $k$ 去更新其他點，不能保證更新後其他點一定是最短路</li>
<li>上一步走完 $k$ 連接所有邊後，從集合 $U$ 中移除，因為沒有負邊， $k$ 必定是最短路</li>
</ul>
<h3 id="Bellman-Ford：單點源最短路徑"><a href="#Bellman-Ford：單點源最短路徑" class="headerlink" title="Bellman-Ford：單點源最短路徑"></a>Bellman-Ford：單點源最短路徑</h3><ul>
<li>可以處理負環</li>
<li>時間：$O(VE)$</li>
<li>想法：Relax鬆弛</li>
<li>一條邊 $\delta(u,v)$ 滿足 $dis[v] = min(dis[v],dis[u]+weight[u][v])$</li>
<li>對每一條邊進行鬆弛，因為鬆弛沒有按照最短路順序，因此要做V-1次</li>
<li>此為暴力作法</li>
<li>執行V-1次的worst case：<ul>
<li>剛好跟最短路徑的順序相反</li>
<li>每次 Relax 後只能優化單一子路徑</li>
<li>共有V個頂點，需要有V-1 條子路徑，每一次一條</li>
<li>檢查負環：做完之後卻有滿足$d[v] &gt; d[u]+w(u,v)$ ，表示有負環</li>
</ul>
</li>
</ul>
<h3 id="優化：SPFA-Shortest-Path-Faster-Algorithm"><a href="#優化：SPFA-Shortest-Path-Faster-Algorithm" class="headerlink" title="優化：SPFA(Shortest Path Faster Algorithm)"></a>優化：SPFA(Shortest Path Faster Algorithm)</h3><ul>
<li>每次只relax更新過的點</li>
<li>使用queue優化，有點像BFS過程<ul>
<li>1.把起點 Push 到 Queue</li>
<li>2.從 Queue 裡 Pop 出一筆資料</li>
<li>3.該筆資料的所有邊進行 Relax</li>
<li>4.有更新到的頂點再 Push 到 Queue</li>
<li>5.重複步驟 2 ~ 4，直到 Queue 為空</li>
</ul>
</li>
<li>時間：$O(VE)$ -&gt;worst case，期望 $O(KE)$ ，K大概是2吧（反正挺快的） </li>
</ul>
<h3 id="DAG-Shortest-Path"><a href="#DAG-Shortest-Path" class="headerlink" title="DAG Shortest Path"></a>DAG Shortest Path</h3><p>首先對所有點進行拓墣排序，花上時間 $O(V+E)$，接著對每一條邊進行鬆弛，時間$O(E)$，因此總時間複雜度是 $O(V+E)$。這個時間複雜度是很快的，但相對的限制也非常多，除了不能有負邊與負環之外，更不能有正環在其中，否則不能進行拓墣排序（在之前筆記<a href="/OYm7TyO2RquZwdUFLx8PFQ">進階圖論（一）</a>）有提到，也就是這一中圖必須是DAG(Directed Acyclic Graph)！</p>
<p>一個有趣的應用：<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%95%AB%E8%A9%95%E6%A0%B8%E8%A1%93">PERT</a></p>
<h3 id="最短路徑樹"><a href="#最短路徑樹" class="headerlink" title="最短路徑樹"></a>最短路徑樹</h3><ul>
<li>紀錄predecessor(樹父節點唯一)</li>
<li>起點到每個點的最短路徑都唯一的話，那把這些路徑疊起來會變成一棵樹</li>
<li>樹：每一點都有唯一來源（最短路）</li>
</ul>
<h3 id="最短路徑比較"><a href="#最短路徑比較" class="headerlink" title="最短路徑比較"></a>最短路徑比較</h3><p>最短路徑問題共有以下求解方式（當然還有一堆），整理比較圖：<br><img src="https://i.imgur.com/uUUmhcL.jpg" alt=""></p>
<h3 id="負環"><a href="#負環" class="headerlink" title="負環"></a>負環</h3><p>上表中的可以處理負環的SPFA和Bellman-Ford是以什麼樣的方式處理？（遇到負環權重應該是$-\infty$）上方所謂負環是指下圖這種情況（當出發點為s，終點為t求最短路徑的問題），因為沒有經過負環，因此 $\delta(s,t)$ 可以被SPFA和Bellman-Ford求出正確的最短路徑為1。我們可以利用從終點回朔最短路徑（利用predecessor紀錄）看是否有重複經過的點，如果有則表示途中有經過負環！</p>
<p><img src="https://i.imgur.com/MJnJXUp.png" alt=""></p>
<p>至於其他的算法，都會求出不正確的數值！</p>
<div class="note default">
            <p><strong>Floyd warshall</strong><br>這個演算法是處理全點對的最短路徑，如果有負環，那一定有任兩點的最短距離是錯誤的。不過我們一樣可以利用Floyd-Warshall演算法判斷圖中是否有負環，只要<font color="#f00">檢查每一個點走到自己的距離是否為負</font> ，即$dis[i][i]<0$ 是否成立，如果成立表示圖中有負環。<br></p><p><strong>Dijkstra</strong><br>這個演算法要求的限制更多，圖中<font color="#f00">不可以有負邊</font>（更別提多個負邊組成的赴環），原因是在Dijkstra求最短路的過程中使用到貪心的想法，當我們從heap裡面取出目前距離最短的點之後，便不會再次被更新。如果有負邊的話，貪心法的過程會發生錯誤，導致得到不正確的答案。</p><p><img src="https://i.imgur.com/Gkg2mex.jpg" alt=""></p><p>此圖中如果邊 $\delta(B,A)$ 為一負邊，當A被移出集合U中便不會有任何再次被更新的機會，但卻因為這條負邊的關係，導致從$s$到$A$的最短距離並不會被正確更新到！</p>
          </div>
<p>以上大概就是最短距離的演算法整理，還有一個全點對最短路徑Johnson’s Algorithm，大概就是對任一點做 Bellman-Ford（順便判斷有沒 有負環)，得到點權之後，用調整完的邊權做 V 次 Dijkstra，可以比Floyd-Warshall有更好的表現，到時候看。</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>最短路徑</category>
      </categories>
      <tags>
        <tag>2020資訊之芽</tag>
        <tag>2021暑期筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>三門問題（蒙提霍爾問題）</title>
    <url>/2021/07/02/%E4%B8%89%E9%96%80%E5%95%8F%E9%A1%8C/</url>
    <content><![CDATA[<h2 id="問題敘述"><a href="#問題敘述" class="headerlink" title="問題敘述"></a>問題敘述</h2><p><a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=47158">資料來源</a><br><a href="https://www.youtube.com/watch?v=iBdjqtR2iK4">影片網址</a><br>在 2008 年上映的美國電影《決勝21點》中，劇中主角班 (Ben Campbell)在非線性代數的課堂上與授課教授米奇(Mickey Rosa) 有一段精彩的對話：</p>
<blockquote>
<p>米奇：「假設你正參加一個遊戲節目，你有機會從三扇不同的門裡選一扇，其中一扇門後面有一輛新車，另外兩扇門後面各有一頭山羊？你要選擇哪一扇門？」</p>
<p>班：  「一號門。」<br><span id="more"></span></p>
<p>米奇：「好！這時節目主持人，順便一提，他知道門後的秘密，他去打開另一扇門，比方說他開了三號門，後面是一頭山羊。這時節目主持人說：「班，你想要堅持選擇一號門，還是換成二號門？」現在問題是–改變選擇(換另一扇門)是否對你有利?」</p>
<p>班：  「是的」</p>
<p>米奇：「記住！主持人知道那輛車在哪裡，你怎麼知道他不是在耍你？……」</p>
<p>班：  「我並不介意，因為我的答案是基於統計學，……，當一開始他讓我選一扇門時，我有 33.3% 的機率是選對的，但當他開其中一扇門時，然後又讓我選時，此刻如果我選擇換一扇門，選對的機率是 66.7%，……。」</p>
</blockquote>
<p>換句話說，假設你正在參加一個游戲節目，你被要求在三扇門中選擇一扇：其中一扇後面有一輛車；其餘兩扇後面則是山羊。你選擇了一道門，假設是一號門，<strong>然後知道門後面有什麼的主持人</strong>，開啟了另一扇後面有山羊的門，假設是三號門。他然後問你：「你想選擇二號門嗎？」轉換你的選擇對你來說是一種優勢嗎？</p>
<hr>
<p>答案：<strong>換門</strong>贏得獎品的機率為$\frac{2}{3}$，<strong>不換門</strong>為$\frac{1}{3}$，因此應該選擇換門</p>
<p>這個問題可以擴展成N門問題，也就是主持人在開了$N-2$道門以後，分析換門與不換門贏得汽車的機率</p>
<h2 id="條件機率—貝式定理"><a href="#條件機率—貝式定理" class="headerlink" title="條件機率—貝式定理"></a>條件機率—貝式定理</h2><p>在條件機率中，以$P(A|B)$表示在B發生的條件下A發生的機率，其值：</p>
<script type="math/tex; mode=display">P(A|B)=\frac{P(A\cap B)}{P(B)}</script><p>我們還可以畫出以下樹狀圖做分析：<br><img src="https://i.imgur.com/nfOcm7U.png" alt=""><br>假設A為得獎的情況，A’為不得獎的情況，B為換門的情況，B’為不換門的情況<br>如果要得獎會發生以下兩種狀況：</p>
<ol>
<li>不換門得獎：$P(A|B’)=\frac{\frac{1}{6}}{\frac{1}{6}+\frac{1}{3}}=\frac{1}{3}\cong 0.33$</li>
<li>換門得獎：$P(A|B)=\frac{\frac{1}{3}}{\frac{1}{6}+\frac{1}{3}}=\frac{1}{3}\cong 0.66$</li>
</ol>
<p>從貝式定律可以得到，換門的機率比較高！</p>
<h2 id="窮舉法（列表觀察）"><a href="#窮舉法（列表觀察）" class="headerlink" title="窮舉法（列表觀察）"></a>窮舉法（列表觀察）</h2><p>我們也可以透過列表得到相同的結論，在下表中假設「選中」為參與者第一次選中的門，「開門」則是主持人打開的有山羊的門，「換門」則是剩下的那個門</p>
<p>這邊可能會有一個疑惑（如果沒有那不要理我XD）：<br>當我第一次選中有車的門時為什麼只有列一次，主持人不是可以選擇打開兩個有山羊的門其中一個，不應是兩種狀況？</p>
<p>只有一種是因為後面有車的門觀眾只會選到一次，不像山羊觀眾可以選兩次，並且主持人打開哪一道門實際是沒有影響，都視為同一種狀況！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>新車</th>
<th>山羊</th>
<th>山羊</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>選中</td>
<td>開門</td>
<td>換門</td>
<td>不換門贏</td>
</tr>
<tr>
<td>換門</td>
<td>選中</td>
<td>開門</td>
<td>換門贏</td>
</tr>
<tr>
<td>換門</td>
<td>開門</td>
<td>選中</td>
<td>換門贏</td>
</tr>
</tbody>
</table>
</div>
<p>從上表可以清楚看出，換門之後贏的機會是$\frac{2}{3}$，不換門則是$\frac{1}{3}$</p>
<h2 id="直覺想法"><a href="#直覺想法" class="headerlink" title="直覺想法"></a>直覺想法</h2><h3 id="錯誤想法-遲到法"><a href="#錯誤想法-遲到法" class="headerlink" title="錯誤想法-遲到法"></a>錯誤想法-遲到法</h3><p>有些人會問：當我從三道門選完之後，主持人打開了一扇門。這時候我請另外一個場外人來看現在的局面：兩扇門關閉，一扇門打開是山羊，那這時候這個局外人選中的機會不就是$\frac{1}{2}$？</p>
<p>這個推論其實是正確的，以一個局外人看到的情況與機率確實是$\frac{1}{2}$，但這樣的思考前提是錯誤的，因為這位局外人<font color="#f00">並沒有參與一開始三門的選擇！</font><br>條件機率有一個重要的概念，也就是一個事件的機率會<font color="#f00">隨著情境的不同（提供訊息的改變）而可能會有所改變</font>，這就是一個很明顯的例子</p>
<h3 id="幫助理解的思考方法"><a href="#幫助理解的思考方法" class="headerlink" title="幫助理解的思考方法"></a>幫助理解的思考方法</h3><blockquote>
<p>1990 年 9 月 9 日，瑪麗蓮‧沃斯‧薩萬特 (Marilyn vos Savant) 在《繽紛遊行》(Parade) 的「請問瑪麗蓮」專欄中，回答讀者提出的三門問題，沃斯‧薩萬特是金氏世界紀錄最高智商 228 的人，她認為選擇換的勝算比較大。為了說服讀者，她請大家想像有 1,000,000 扇門，她說：</p>
<p>你選擇 1 號門，而主持人知道門後有什麼，他總是避開有獎的那扇門，除了 777,777 號門外，把別的門都打開了。這時你會毫不猶豫地換到另一扇門，是吧?」</p>
</blockquote>
<p>從N道門中選擇其中一道門中獎機率$\frac{1}{N}$，不中獎的機率為$\frac{N-1}{N}$，也就是說有$\frac{N-1}{N}$的機率汽車在另外$N-1$道門中。這時候主持人幫你一個大忙，他打開了其中沒有汽車的$N-2$道門，不就是幫助你<font color="#f00">剔除了不可能選中的情況</font>，也就代表把$\frac{N-1}{N}$的中獎機率集中在剩下的那一扇門中！</p>
<p>因此可以得到結論：在$N$門問題中，假設主持人總共會打開$N-2$道門，那換門中獎的機率會是$\frac{N-1}{N}$，不換門中獎則是$\frac{1}{N}$</p>
<h2 id="C-模擬"><a href="#C-模擬" class="headerlink" title="C++模擬"></a>C++模擬</h2><p>如果上面的東西都無法說服你，那就來寫一個程式模擬吧！寫程式最重要的就是要證明模擬是正確的，因此會印出若干組結果看看是否合理！<br>這個程式會亂數幫觀眾選一扇門（隨機選），與中獎的門（也是隨機選），接著主持人打開門後會剩下觀眾選的與一個還沒有被開的門</p>
<h3 id="主持人打開N-2道門（剩2道門做選擇）"><a href="#主持人打開N-2道門（剩2道門做選擇）" class="headerlink" title="主持人打開N-2道門（剩2道門做選擇）"></a>主持人打開N-2道門（剩2道門做選擇）</h3><p>我們取$N=3$ 做例子（當然也可以隨意輸入），第一個3表示門的數量，接下來的100000表示模擬次數<br><img src="https://i.imgur.com/SWsVaD1.png" alt=""></p>
<p>印出前五次的模擬情況作觀察，這個程式在印出未中獎時，換門中獎的事件加一；反之，印出中獎時，不換門中獎的事件加一，模擬結果符合預期！</p>
<p>如果共有10道門，一樣符合預期，換門中獎機率落在$\frac{9}{10}$左右<br><img src="https://i.imgur.com/zWhUjZq.png" alt=""></p>
<h3 id="主持人打開K道門（剩N-K道門做選擇）"><a href="#主持人打開K道門（剩N-K道門做選擇）" class="headerlink" title="主持人打開K道門（剩N-K道門做選擇）"></a>主持人打開K道門（剩N-K道門做選擇）</h3><p>如果給個變化題，主持人想說不要對觀眾那麼好，在未被觀眾選中的$N-1$ 道門中開啟K道後面有羊的門。我們知道會有$\frac{N-1}{N}$的機率會在不是觀眾選的另外$N-1$道門中，但在這$N-1$道門中因為打開了$K$道門，剩下$N-1-K$道門可以選擇，因此可以列出以下式子：</p>
<script type="math/tex; mode=display">\frac{N-1}{N}\times \frac{1}{N-K-1}=\frac{N-1}{N^2-NK-1}</script><p>這就是換門中獎的機率！</p>
<p>我們可以將換門中獎的機率扣掉不換門中獎的機率：</p>
<script type="math/tex; mode=display">\begin{split}\frac{1}{N}\cdot \frac{N-1}{N-K-1}-\frac{1}{N} &=\frac{1}{N}(\frac{N-1}{N-K-1}-1) \\&= \frac{1}{N}\cdot\frac{K}{N-K-1}\end{split}</script><p>已知$N-K\geq2$ 且$K\geq0$，因此無論開多少門（甚至不開），<font color="#f00">換門的中獎機率永不小於不換門的機率！</font></p>
<p>以上為設定9個門，主持人打開5道門，執行一百萬次的結果。<br>根據上面的公式，我們預期會有$\frac{8}{27}\cong 0.2963$的機率換了會中獎，符合模擬的結果</p>
<h3 id="有a輛車，主持人開K道門"><a href="#有a輛車，主持人開K道門" class="headerlink" title="有a輛車，主持人開K道門"></a>有a輛車，主持人開K道門</h3><p>這就比較簡單了，原本只有1輛車，變成a輛車自然中獎的機率就會變a倍，套用上面的公式，換門中獎機率：</p>
<script type="math/tex; mode=display">\frac{a\cdot(N-1)}{N^2-NK-1}</script><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> selected_door,selected[<span class="number">1000000</span>],make_change=<span class="number">0</span>,keep=<span class="number">0</span>,N,M,open;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;open&gt;&gt;M;	<span class="comment">//輸入門的數量N，主持人開門數open，模擬次數M</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;            <span class="comment">//執行M次</span></span><br><span class="line">        selected_door = <span class="built_in">rand</span>()%N;    <span class="comment">//選擇一個門放汽車</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(j==selected_door)selected[j]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> selected[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> audience_selected = <span class="built_in">rand</span>()%N;	<span class="comment">//觀眾選擇一個門</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,ind=<span class="number">0</span>;j&lt;open;ind++)&#123;	<span class="comment">//將K扇門打開</span></span><br><span class="line">          <span class="keyword">if</span>(ind!=audience_selected &amp;&amp; ind!=selected_door)&#123;</span><br><span class="line">              selected[ind]=<span class="number">2</span>;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> change_door = <span class="number">0</span>;	<span class="comment">//要換到的門</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;vec;	<span class="comment">//可以換的選擇</span></span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(j!=audience_selected &amp;&amp; selected[j]!=<span class="number">2</span>)&#123;</span><br><span class="line">              vec.<span class="built_in">push_back</span>(j);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> vec_size = vec.<span class="built_in">size</span>();</span><br><span class="line">        change_door = vec[(<span class="built_in">rand</span>()%vec_size)];</span><br><span class="line">        <span class="keyword">if</span>(change_door == selected_door)make_change++;	<span class="comment">//紀錄換而贏的次數</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(audience_selected == selected_door)keep++;	<span class="comment">//紀錄不換而贏的次數</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">4</span>)&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;次模擬&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;觀眾選擇：&quot;</span>&lt;&lt;audience_selected+<span class="number">1</span>&lt;&lt;<span class="string">&quot; 號門&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;中獎的門為：&quot;</span>&lt;&lt;selected_door+<span class="number">1</span>&lt;&lt;<span class="string">&quot; 號門&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;沒有被主持人打開的門：&quot;</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec_size;j++)cout&lt;&lt;vec[j]+<span class="number">1</span>&lt;&lt;<span class="string">&quot;號門,&quot;</span>;</span><br><span class="line">          cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;觀眾選擇要換的門為：&quot;</span>&lt;&lt;change_door+<span class="number">1</span>&lt;&lt;<span class="string">&quot; 號門&quot;</span>&lt;&lt;endl;</span><br><span class="line">          <span class="keyword">if</span>(audience_selected == selected_door)cout&lt;&lt;<span class="string">&quot;不換門中獎&quot;</span>&lt;&lt;endl;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(change_door == selected_door)cout&lt;&lt;<span class="string">&quot;換門中獎&quot;</span>&lt;&lt;endl;</span><br><span class="line">          <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;換門不換門皆不會中獎&quot;</span>&lt;&lt;endl;</span><br><span class="line">          cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">5</span>);    <span class="comment">//印出機率</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;不換門贏的機率：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)keep/M&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;換了門贏的機率：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)make_change/M&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="警察抓酒鬼問題"><a href="#警察抓酒鬼問題" class="headerlink" title="警察抓酒鬼問題"></a>警察抓酒鬼問題</h2><p>這個問題可以用來比較一下三門問題：</p>
<blockquote>
<p>某酒鬼有90%的日子都會出去喝酒，喝酒只隨機去固定的三家酒吧。今天警察找了其中兩家酒吧都沒有找到酒鬼。問：酒鬼在第三家酒吧的機率？</p>
</blockquote>
<p>我們假設事件$A_1$為酒鬼喝酒的機率、$A_2$為酒鬼在家的機率，$B_1$為酒鬼在前兩個酒吧被抓的機率、$B_2$為酒鬼沒有在前兩個酒吧被抓的機率</p>
<p>我們要找的是酒鬼沒有在前兩個酒吧被抓的條件下喝酒的機率，可以套用貝氏定理：</p>
<script type="math/tex; mode=display">\begin{split}P(A_1|B_2)&=\frac{P(A_1\cap B_2)}{P(B_2)}\\&=\frac{P(A_1)\cdot P(B_2|A_1)}{P(A_1)\cdot P(B_2|A_1)+{P(A_2)\cdot P(B_2|A_2)}}\\&=\frac{\frac{9}{10}\times\frac{1}{3}}{\frac{9}{10}\cdot\frac{1}{3}+\frac{1}{10}\times 1} \\&=\frac{3}{4}=0.75\end{split}</script><p>正解是75%，也可以顯而易見的用$\frac{30\%}{30\%+10\%}=75\%$得到答案</p>
<p>這題想要討論的是，在三門問題中，<font color="#f00">主持人是知道</font>哪一些門是沒有汽車的，所以故意打開；但是在這個問題中，<font color="#f00">警察是不知道哪一個酒吧有酒鬼</font>，兩題本身的前提就不同，不能拿來互相解釋</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在分析完三門問題、程式實際模擬和比較其他題目之後，得到一個結論：三門問題中主持人並不是亂選，而是把沒有車的那些門打開，這根平常直覺的機率想法是不同的！</p>
<p>雖然對大多數人的直覺反應而言，選擇換門與不換門似乎中獎的機率是相同的，但經過上述一連串利用貝氏定理的討論與歸納後，證實了反而換門才是最明智的選擇。「人的認知有兩種，一是先驗的古典機率，一是經驗的機率，前者會干擾後者；鴿子只有後者，在蒙提霍爾問題上，高人一籌。人其實是聰明反被聰明誤。」(曾志朗，2012)</p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>2021暑期筆記</tag>
        <tag>數學</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo 搭配GitHub架設個人部落格</title>
    <url>/2021/08/27/%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<p>暑假常常寫題，都幾乎紀錄在Hackmd上，如果能有屬於自己的部落格、用自己的網址，感覺超酷！來自己架設一個試試看！</p>
<h2 id="網域種類"><a href="#網域種類" class="headerlink" title="網域種類"></a>網域種類</h2><p>架設網站有好多種方法，有時候是看題解看到了很多的網站XD，上網查了資料以及很多人的部落格，發現寫coding部落格的人的網站大多分成以下四類：</p>
<ol>
<li><a href="https://www.blogger.com/">Blogger</a></li>
<li><a href="https://hexo.io/">Hexo</a></li>
<li><a href="https://pages.github.com/">GitHub Pages</a></li>
<li><a href="https://wordpress.org/">WordPress.org</a></li>
</ol>
<span id="more"></span>
<p>每一種部落格都有優勢與劣勢，就看使用者覺得哪一個平台使用起來比較方便！在經過多方嘗試之下，最後我是選擇了使用 Hexo 搭配 Github 來架設我的網站，以下來分析一下我個人在架設的過程中，以一個新手的角度看各個平台使用上的優缺點！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>網站比較</th>
<th>優點</th>
<th>缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Blogger</strong></td>
<td>1. 介面清楚，操作方便<br>2. 一鍵預覽及發布，快速查看文章成果<br>3. 免費！</td>
<td>1. 不支援MarkDown語法<br>2. 對數學式、程式碼支援不便利</td>
</tr>
<tr>
<td><strong>Hexo</strong></td>
<td>1. 支援MarkDown語法<br>2. Mac終端機操作方便<br>3. 免費！</td>
<td>1. 純程式碼呈現，較不直覺<br>2. 修改過程中如果程式碼出錯，造成整個網站掛掉</td>
</tr>
<tr>
<td><strong>GitHub Pages</strong></td>
<td>1. 支援MarkDown語法<br>2. 進行版本控制<br>3. 免費！</td>
<td>1. 單純使用的話操作、修改不方便<br>2. Git操作有一定難度</td>
</tr>
<tr>
<td><strong>WordPress com</strong></td>
<td>1. 跟Blogger相近，操作簡單易上手<br>2. 快速查看文章長相</td>
<td>1. 不支援Markdown<br>2. 免費版限制多、模板不漂亮</td>
</tr>
<tr>
<td><strong>WordPress org</strong></td>
<td>太貴不考慮</td>
<td>上網查必須要先付費才能開始架設<br>費用好像一年3000以上</td>
</tr>
</tbody>
</table>
</div>
<p>經過多方嘗試（花了我好多天），出產了一堆失敗品，最後還是用 Hexo 搭配 GitHub 來架設一個算滿意的網站（至少看起來不錯XD）。以下是我的失敗品網站：</p>
<ol>
<li><a href="https://peienwu1216.blogspot.com/?zx=60407725c2514b18">Blogger</a></li>
<li><a href="https://peienwu.wordpress.com/">WorldPress</a></li>
<li>Github的我已經刪掉了</li>
</ol>
<h2 id="Hexo-安裝"><a href="#Hexo-安裝" class="headerlink" title="Hexo 安裝"></a>Hexo 安裝</h2><p>之前遇上很多軟體對Mac都不友善，不過Hexo卻是對Mac的用戶比較友善的工具。只要在終端機輸入以下命令就可以安裝Hexo：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><br>詳細的安裝步驟可以參考<a href="https://hexo.io/docs/">官方網站</a>，或是網路上的<a href="https://youtu.be/jOJI9ekTzK8">教學影片</a>就可以一步一步的把網站建立起來！</p>
<p>在這過程中，我發現影片上有使用到VS Code，於是我就把它也載下來了。用起來感覺VS Code 對專案製作很有幫助，可以同步的在各個檔案之間進行修改，蠻實用的一個IDE！<br><img src="https://i.imgur.com/eIiT0Pb.png" alt=""></p>
<h2 id="GitHub同步"><a href="#GitHub同步" class="headerlink" title="GitHub同步"></a>GitHub同步</h2><p>將 Hexo 裡面的檔案推送到 Git Hub 裡面的一個Repository中，利用它來將網頁的內容進行發布。在每一次本地修改完成之後，如果本地測試可行，就可以將檔案推送到Github中，在Github將網站進行發布。我使用來架設部落格的<a href="https://github.com/peienwu/peienwu.github.io">Repository在此</a>。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .                //加入</span><br><span class="line">git commit -m &quot;xxx&quot;      //提交</span><br><span class="line">git push                 //推入</span><br><span class="line">git push -f              //強制推入（聽說很危險）</span><br></pre></td></tr></table></figure><br>在提交的後面的字串表示當前版本的一個提示，例如我做了什麼修改就可以顯示在上面，讓別人知道這份檔案被更改的情況。下圖就是在每一次推入時附加的修改資訊，讓我自己可以看到檔案被更改以及提交的狀況!</p>
<p><img src="https://i.imgur.com/kBpX3gp.png" alt=""></p>
<p>Git真是博大精深，版本控制真的有難度，我只會簡單的修改以及推入（之後找時間可以學一下）。</p>
<h2 id="外掛安裝"><a href="#外掛安裝" class="headerlink" title="外掛安裝"></a>外掛安裝</h2><p>做到這一個步驟已經花了我快三小時，出現的是類似以下的畫面：</p>
<p><img src="https://i.imgur.com/a1zD8Qz.png" alt=""></p>
<p>這是 Hexo 預設的樣板，感覺還不錯，不過我的目標是使用另外外掛的模板，看起來比較漂亮XD。於是我就找了<a href="https://github.com/theme-next/hexo-theme-next">Next主題</a>的外掛來安裝，這個模板就感覺舒服很多。這個模板使用的大陸部落格很多，也有一些其他的競程部落格使用了這個主題！</p>
<p><img src="https://i.imgur.com/aP8mwrQ.png" alt=""></p>
<h3 id="Hexo-NexT-美化"><a href="#Hexo-NexT-美化" class="headerlink" title="Hexo NexT 美化"></a>Hexo NexT 美化</h3><p>上網查關鍵字其實有很多美化的資訊可以參考，不論是字體或版面配置都有很多種選項可以選擇。最一開始是設計版面的部分，將網站總共分五個子類別，分別是首頁、檔案、類別、標籤以及關於，這五個經典的配置。接下來就是個人資訊的設定，加入自己的圖片以及說明：<br><img src="https://i.imgur.com/TXykwfE.png" alt=""></p>
<p>以及在網頁瀏覽標籤上方設定icon：<br><img src="https://i.imgur.com/Y2lE6Qp.png" alt=""></p>
<p>當然最重要的就是文章內容，因為是使用Markdown語法，剛好有幾篇筆記就丟上去看看。當然還有很多的優化以及美化，如果有什麼需要改進的地方要跟我說喔！</p>
<h3 id="Disqus-留言板功能"><a href="#Disqus-留言板功能" class="headerlink" title="Disqus 留言板功能"></a>Disqus 留言板功能</h3><p>在每一篇文章下方加入留言板功能，感覺還蠻酷的！</p>
<p><img src="https://i.imgur.com/DAUAz3R.png" alt=""></p>
<h3 id="Google-Analytics-追蹤分析"><a href="#Google-Analytics-追蹤分析" class="headerlink" title="Google Analytics 追蹤分析"></a>Google Analytics 追蹤分析</h3><p>這是酷東西，使用google 帳號生成一組代碼之後，把一些它提供的程式碼埋到網站中，它可以即時的統計網站的瀏覽狀況，以及觸及、感興趣的主題等等。<strong>假設</strong>未來瀏覽的人次比較多的時候（可能根本沒人會看XDD），還可以用它來分析哪一種文章最受人歡迎、哪一種文章最冷門之類的！</p>
<p><img src="https://i.imgur.com/3lPv0uW.png" alt=""></p>
<h3 id="購買個人網址"><a href="#購買個人網址" class="headerlink" title="購買個人網址"></a>購買個人網址</h3><p>昨天終於買到了自己名字的網址了！新的網址名稱是：peienwu.com！在<strong>Godaddy</strong> 上用NT570元買了一年這個網址的使用權限，買完之後到<strong>CloudFlare</strong>設定好Dns之類的，讓這個網址可以指向一個IP位址（這其中的原理有點複雜）。</p>
<p>設定完之後，發現他一直出現錯誤訊息，點開網址也是不可使用的，差點昏倒ww。晚上處理不了了，隔天一早起床就開始著手處理中這個問題，把檔案刪刪改改，終於成功讓GitHub跳出以下訊息：</p>
<p><img src="https://i.imgur.com/Zoe8Aes.png" alt=""></p>
<p>很討厭的，他沒有https，也就是鎖頭，在這種情況下，瀏覽器就會自動設置為<font color="#f00">不安全</font>的網站，接下來早上的時間都拿去處理這個問題。在設定一些SSH以及https的安全性設定之後，終於，在訪問網站時拿到了鎖頭的認證！</p>
<p><img src="https://i.imgur.com/jguOHwH.png" alt=""></p>
<h3 id="留言板更新"><a href="#留言板更新" class="headerlink" title="留言板更新"></a>留言板更新</h3><p>最近重新登入後發現文章底部都是一堆Disqus的廣告，真的有夠討厭，如果要消除廣告的方法只剩下付費，好討厭！於是我決定換一個評論系統，叫做<a href="https://valine.js.org/">Valine</a> 的系統，他的優點是支援Emoji 😉、MarkDown 全语法支持，而且<strong>沒有廣告</strong>！大概的留言就像以下這樣：<br><img src="https://i.imgur.com/xgmM0EX.png" alt=""></p>
<p>支援Markdown的留言真的很酷！</p>
<p>至於留言管理的部分，則是用<a href="https://leancloud.app/">LeanCloud</a> 來實現，可以刪留言之類的XD<br><img src="https://i.imgur.com/Zmtl0u8.png" alt=""></p>
<h3 id="抱怨一下"><a href="#抱怨一下" class="headerlink" title="抱怨一下"></a>抱怨一下</h3><p>今天在用Icloud 的時候，不小心把電腦上所有的檔案全部刪掉了，哭啊，這真是嚴重的事情ＱＱＱ，用到快掛了！當然，我電腦上的所有東西都不見了，也包括這一個部落格的本地程式碼，我用了 google drive 的備份，可惜那很難下載，所以我就用了github原本的備份的東西。</p>
<p>這真是不幸中的大幸，還好github的備份直接下載就可以直接用，不用特別再設定一些奇怪的東西，但所有的 hexo 指令都不見了，git的指令也都不見了，必須要重新設定。</p>
<p>這邊有一個小東西，就是下面這一行警告，就是要你把push設定成你要push的地方，不然只打一個push他並不會知道要push去哪裏，所以設定一下repo的位置就好了。</p>
<blockquote>
<p>git push —set-upstream origin master</p>
</blockquote>
<p>當然還有一堆bug ，只好慢慢爬文嘍，當你看到這一段文字，也就代表我成功找到解決辦法了！</p>
<h3 id="我又來更新了"><a href="#我又來更新了" class="headerlink" title="我又來更新了"></a>我又來更新了</h3><p>這幾天網站一直404 not found 超煩，於是我叫出之前的教學影片，重新看了之後，發現我的分支名稱弄錯了，不是用master而是用gh-pages，搞了好多天QQ</p>
<h2 id="架設心得"><a href="#架設心得" class="headerlink" title="架設心得"></a>架設心得</h2><p>部落格以後會常常更新，最近也會陸續把之前的文章放到部落格上面。整個網站從誕生到現在的結果已經花了15個小時，其中在Debug的時間應該佔了大多數！</p>
<p>遇到了幾個麻煩的問題，首先碰到的是本地的資料無法上傳到Github，終端機冒出來的是：<font color="#f00">Please make sure you have the correct access rights and the repository exists.</font>。這個錯誤超級煩，爬了一堆文結果他要在GitHub上面設定ssh金鑰之類的東西，才能獲取從本地更新的權限。結果網路上的文章說我要開啟一個名叫”.ssh”的資料夾，可是我翻遍了我的電腦也找不到這一個資料夾！後來我是利用終端機，輸入路徑位置硬是把那一個資料夾打開，它是一個透明的資料夾，還是第一次遇到！</p>
<p>接著是終端機跑出一堆error，那時候真的差點崩潰，花了超久架設的東西，竟然跑出這麼多的錯誤！難道全部的東西都付之一炬了嗎？翻了每一個被變更過的資料夾，才發現到在user_name的地方踩了雷，把他變回原本的設定就好了，真是不幸中的大幸，幸好我還能把東西救回來！</p>
<p>最後，終於能用https的前綴連到我的網站：<a href="https://peienwu.com">https://peienwu.com</a> 。如果要打www開頭也是可以連得上，直接打 peienwu.com 也可以順利連上！</p>
]]></content>
      <categories>
        <category>部落格架設</category>
      </categories>
      <tags>
        <tag>個人部落格</tag>
        <tag>網站架設</tag>
      </tags>
  </entry>
  <entry>
    <title>最近點對：不同複雜度之解決方式</title>
    <url>/2021/08/23/%E6%9C%80%E8%BF%91%E9%BB%9E%E5%B0%8D/</url>
    <content><![CDATA[<blockquote>
<p>題目敘述<br>給定二維平面上 $n$ 個點，每一點都有座標 $(x_i,y_i)$ ，求出最近的點對之歐幾里德距離為多少？<br>$dis(p_i,p_j) = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$<br><span id="more"></span></p>
</blockquote>
<p>最近點對有好多種實作方式，從最差的暴力枚舉、稍微優化的掃描線演算法、到分治與隨機，有4種不同的時間複雜度。利用<a href="https://tioj.ck.tp.edu.tw/problems/1500">TIOJ 1500</a>這一題最近點對的裸題，來實測各種不同複雜度下所需要的執行時間。</p>
<h2 id="暴力枚舉"><a href="#暴力枚舉" class="headerlink" title="暴力枚舉"></a>暴力枚舉</h2><h3 id="時間複雜度：-N-2"><a href="#時間複雜度：-N-2" class="headerlink" title="時間複雜度：$N^2$"></a>時間複雜度：$N^2$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262968">Submission</a><br><strong>時間：TLE,10440</strong></p>
<p><img src="https://i.imgur.com/DL0tBBb.png" alt=""></p>
<p>暴力$O(n^2)$將所有點進行枚舉，因為值域是 $n≤50000$ ，平方枚舉會有TLE的問題。</p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        ld d = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                d = <span class="built_in">min</span>(d, <span class="built_in">dis</span>(p[i],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="掃描線算法"><a href="#掃描線算法" class="headerlink" title="掃描線算法"></a>掃描線算法</h2><h3 id="時間複雜度：Worst-Case-O-N-2"><a href="#時間複雜度：Worst-Case-O-N-2" class="headerlink" title="時間複雜度：Worst Case $O(N^2)$"></a>時間複雜度：Worst Case $O(N^2)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262966">Submission</a><br><strong>時間：AC,1668</strong><br><img src="https://i.imgur.com/6iSbet4.png" alt=""></p>
<p>這一種作法是改善過後的暴力枚舉，利用計算幾何中掃描線的概念，先將所有點依照x座標進行排序（y座標隨意）。接著想像一條從左往右掃的掃描線，對於每一條掃描線看右邊的點，如果當前最近點對距離為 $d$，因此只要遇上x座標差距大於 $d$ 的點時，即可繼續下一輪的枚舉。</p>
<p>加上排序的關係，其時間複雜度至少為 $O(n\log n)$，但這種掃描線的方式無法有效過濾所有點都在相同的x座標上的情況，因此最差的時間複雜度會退化成 $O(n^2)$ ，不過聽說平均的狀況下是很快的！</p>
<p><img src="https://i.imgur.com/Ae9k1HR.png" alt=""></p>
<p>上圖為掃描線執行最近點對的一個示意圖，黑線為掃描線，$d$ 為掃描線左邊所有點的最近點對距離，我們只要每一輪枚舉這個點與右邊x座標差在 $d$ 以內的所有點，即可進行下一輪的更新！</p>
<h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p,p+n);</span><br><span class="line">        ld d = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j].x &gt; p[i].x + d)<span class="keyword">break</span>;</span><br><span class="line">                d = <span class="built_in">min</span>(d, <span class="built_in">dis</span>(p[i],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="掃描線算法（優化後）"><a href="#掃描線算法（優化後）" class="headerlink" title="掃描線算法（優化後）"></a>掃描線算法（優化後）</h2><h3 id="時間複雜度：-O-N-log-N"><a href="#時間複雜度：-O-N-log-N" class="headerlink" title="時間複雜度：$O(N\log N)$"></a>時間複雜度：$O(N\log N)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/278456">Submission</a><br><strong>時間：AC,148</strong></p>
<p>原本以為上面的掃描線就是他的極限了，沒想到上面的worst case還可以透過set優化成 $O(n\log n)$！簡單來說，方法一樣是想像一條掃描線由左而右，一樣照上面的想法，把x座標差大於d的點排除，之後利用set二分搜找出y座標在範圍內的點進行枚舉更新答案。</p>
<ol>
<li>將點輸入並且排序，X座標為主，Y座標為輔。</li>
<li>使用set，並以Y座標為排序基準（pair的首項），以儲存第 $i$ 點的左方、水平距離小於等於d的點。</li>
<li>右掃描線依序窮舉各點作為右端點。<br>　(1) Erase與右端點水平距離大於d的點們（左掃描線右移）<br>　(2) 用二分搜找出與第 $i$ 點垂直距離小於d的點，並嘗試更新<br>　(3) 將第 $i$ 點加入set中。</li>
</ol>
<p><img src="https://i.imgur.com/yMs369S.png" alt=""></p>
<h3 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;pii&gt; p;</span><br><span class="line">set&lt;pii&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;p[<span class="number">0</span>].y,p[<span class="number">0</span>].x&#125;);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;ld ans = <span class="number">5e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">ceil</span>(ans);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; i &amp;&amp; p[l].x &lt; p[i].x - d)&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(&#123;p[l].y,p[l].x&#125;);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it_l = s.<span class="built_in">lower_bound</span>(&#123;p[i].y - d,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">auto</span> it_r = s.<span class="built_in">upper_bound</span>(&#123;p[i].y + d,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = it_l;it != it_r;it++)&#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,<span class="built_in">dis</span>(&#123;it-&gt;y,it-&gt;x&#125;,p[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(&#123;p[i].y,p[i].x&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="時間複雜度：-O-N-log-N-1"><a href="#時間複雜度：-O-N-log-N-1" class="headerlink" title="時間複雜度：$O(N\log N)$"></a>時間複雜度：$O(N\log N)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262111">Submission</a><br><strong>時間：AC,196</strong></p>
<p><img src="https://i.imgur.com/aOV2MWE.png" alt=""></p>
<p>分治做最近點對的基本想法，先將所有點依照x座標排序，利用遞迴得到分割點左右兩邊所有點的最短距離（兩點並不會跨過中間分隔線），枚舉所有會橫跨兩側且有可能更新最短距離的點對。</p>
<p><img src="https://i.imgur.com/2NGuJc5.png" alt=""></p>
<p>從兩半邊的遞迴得到目前的最近點對距離 $d = min(d_l,d_r)$ ，將分隔線附近x座標差距小於$d$的點通通都枚舉一遍。可能會有一個疑問，我們是不是可以縮小枚舉的範圍，否則點的數量可能會太多導致複雜度爆炸？除了x座標可以做點的篩選之外，在枚舉的過程中，我們會利用將所有點對y座標排序，將y座標直線距離大於 $d$ 的情況剔除，所剩下真的需要枚舉點也只會剩下常數個，因此可以放心枚舉。</p>
<p><strong>複雜度分析：</strong> 腦海中想像遞迴樹的長相，會發現每一層都需要都需要對y座標進行排序，時間為$O(n\log n)$ ，每一次都將n的值除以2，因此共有$O(\log n)$ 層，總共的時間複雜度為 $O(n\log^2n)$。（不過實際上應該會比這個快，因為並不是要對所有點都進行排序）。</p>
<script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2})+O(n\log n) = O(n\log^2n)</script><p>如果要做得更快，可以在y座標排序的地方稍微動動手腳。既然每一層都要對y座標進行排序，排序好的東西再排序一次其實沒有什麼意義，因此就可以用）<a href="/N9zvIzP_Se-hpWZSaMv-sQ">合併排序（merge sort）</a>的方式，將所有已經排序好的兩個左右序列進行$O(n)$的合併（可以用std::merge()完成），如此一來，就不須要每一層花到 $O(n\log n)$ 的ㄕˊ間進行排序，使總複雜度降低為 $O(n\log n)$！</p>
<script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2})+O(n) = O(n\log n)</script><h3 id="程式碼-3"><a href="#程式碼-3" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF1 100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;pii&gt; p,temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1 = a.x-b.x,y1 = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x1 * x1 + y1 * y1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間[l,r]</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>,mid_pos = p[mid].x;;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="built_in">min</span>(<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r));</span><br><span class="line">    </span><br><span class="line">    temp.<span class="built_in">assign</span>((r-l+<span class="number">1</span>),&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">merge</span>(</span><br><span class="line">        p.<span class="built_in">begin</span>() + l, p.<span class="built_in">begin</span>() + mid + <span class="number">1</span>,</span><br><span class="line">        p.<span class="built_in">begin</span>() + mid + <span class="number">1</span>, p.<span class="built_in">begin</span>() + r + <span class="number">1</span>,</span><br><span class="line">        temp.<span class="built_in">begin</span>(), cmp</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r)p[i] = temp[i-l];</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, l, r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p[i].x - mid_pos) &lt;= ans)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = temp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, i+<span class="number">1</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dis</span>(temp[i],temp[j]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(temp[i].y-temp[j].y) &gt; ans)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隨機算法"><a href="#隨機算法" class="headerlink" title="隨機算法"></a>隨機算法</h2><h3 id="時間複雜度：期望-O-N"><a href="#時間複雜度：期望-O-N" class="headerlink" title="時間複雜度：期望 $O(N)$"></a>時間複雜度：期望 $O(N)$</h3><p><a href="https://tioj.ck.tp.edu.tw/submissions/262969">Submission</a><br><strong>時間：AC,488</strong></p>
<p><img src="https://i.imgur.com/X756Jf4.png" alt=""></p>
<p>用隨機算法做最近點對的期望複雜度是 $O(n)$ ，也就是說如果一開始進行的Random_shuffle有做好的話，期望可以在線性時間解決這個問題。基本的想法如下：</p>
<ol>
<li>將最近點對距離設為d，初始為第一、二個點之間的距離</li>
<li>將每一個點的座標塞入以 $\frac{d}{2}$ 為邊長的網格中</li>
<li>將點加入網格中，查看要加入的網格是否已經有點在其中</li>
<li>一個網格不可容納兩個點，否則必須更新最近點對的距離</li>
<li>在更新最近點對距離之後，將前面的點的網格座標以新的$d$進行更新</li>
</ol>
<p>這個算法用到隨機的因子，因此如果在一開始有將所有點進行均勻的打散的話，可以做到期望複雜度 $O(n)$。</p>
<p><strong>複雜度分析：</strong><br>考慮加入第i+1個點時出現新的最近點對，發生的機率為：在$C_2^{i+1}$個配對中跟i+1個點產生最近點對共有i種可能因此機率為$\frac{2}{i+1}$。</p>
<p>當機率發生的時候，必須將所有的點都刪掉重新來一遍（r變小，重新推入i+1個點），需要付出$O(i+1)$的時間，相乘起來加入每一個點期望的複雜度為$O(1)$，因此總時間複雜度為$O(n)$。</p>
<h3 id="程式碼-4"><a href="#程式碼-4" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000LL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swift 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ld r,d,ans;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">25</span>] = &#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">25</span>] = &#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Grid</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,ind;</span><br><span class="line">&#125;point[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函式實作</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.<span class="built_in">clear</span>();</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Grid</span><span class="params">(<span class="keyword">int</span> ind)</span></span>&#123; <span class="comment">//input網格座標</span></span><br><span class="line">    <span class="keyword">int</span> x = point[ind].x/r;</span><br><span class="line">    <span class="keyword">int</span> y = point[ind].y/r;</span><br><span class="line">    <span class="keyword">return</span> x*INF+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">dis</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x,y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(<span class="number">0</span>),<span class="number">0</span>));m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(<span class="number">1</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ind = <span class="number">2</span>;ind &lt; n;ind++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = point[ind].x/r,y = point[ind].y/r,better=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(nx*INF+ny);</span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">double</span> distance = <span class="built_in">dis</span>(point[it-&gt;second],point[ind]);</span><br><span class="line">                <span class="keyword">if</span>(distance&lt;d)&#123;</span><br><span class="line">                    better = <span class="number">1</span>;</span><br><span class="line">                    ans = <span class="built_in">dis</span>(point[it-&gt;second],point[ind]);</span><br><span class="line">                    d = distance;</span><br><span class="line">                    r = d/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(better)&#123;</span><br><span class="line">            m.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=ind;i++)m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(i),i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Grid</span>(ind), ind));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            x+=swift;y+=swift;</span><br><span class="line">            point[i].x = x;point[i].y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">random_shuffle</span>(point, point+n);</span><br><span class="line">        <span class="keyword">int</span> smalln = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        ans = <span class="built_in">dis</span>(point[<span class="number">0</span>],point[<span class="number">1</span>]);</span><br><span class="line">        d = <span class="built_in">dis</span>(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=smalln;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=smalln;j++)&#123;</span><br><span class="line">                d = <span class="built_in">min</span>(d,<span class="built_in">dis</span>(point[i], point[j]));</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,<span class="built_in">dis</span>(point[i],point[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r = d/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相關題目"><a href="#相關題目" class="headerlink" title="相關題目"></a>相關題目</h2><ul>
<li>[ ] <a href="https://neoj.sprout.tw/problem/795/">NEOJ 最近點對</a></li>
<li>[ ] <a href="https://tioj.ck.tp.edu.tw/problems/1105">TIOJ 最遠點對</a></li>
</ul>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>最近點對</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>暑假筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>生日問題（生日悖論）</title>
    <url>/2021/07/05/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C/</url>
    <content><![CDATA[<p>有同學問我生日問題的機率感覺蠻好玩的，決定好好研究一番。生日悖論其實不是一個悖論，只是有點違背直覺而已，並非數學中定義的悖論！這一篇會用蒙地卡羅模擬來進行與理論的比較</p>
<h2 id="問題敘述"><a href="#問題敘述" class="headerlink" title="問題敘述"></a>問題敘述</h2><p>題目：一個房間要多少人，則兩個人的生日相同的機率要大於50%？</p>
<p>答案是<font color="#f00">23</font>人。<br><span id="more"></span><br>如果想要看<a href="https://gist.github.com/peienwu/bd6edf34416f352ba97b94c67d5acb52">1到100人有同一天的機率可以點這裡</a></p>
<h2 id="機率與人數的關係"><a href="#機率與人數的關係" class="headerlink" title="機率與人數的關係"></a>機率與人數的關係</h2><h3 id="兩種理解方式"><a href="#兩種理解方式" class="headerlink" title="兩種理解方式"></a>兩種理解方式</h3><p>對於生日問題可能會有兩種理解方式：</p>
<ol>
<li>題意：<font color="#f00">「23人之中兩兩之間存在生日相同」</font><br> 對於原本題目要闡述的意義可以列出以下數學式：<script type="math/tex; mode=display">\begin{split}p(n)&=1-p'(n) \\&= 1-(1\times\frac{364}{365}\times\frac{363}{365}\times\cdots\frac{365-(n-1)}{365})\end{split}</script></li>
<li>錯誤理解：<font color="#f00">「其他22人與你的生日相同的機率」</font><br> 這樣的理解會造成算出來的機率大為減少（用全部扣掉皆不相同）：<script type="math/tex; mode=display">q(n) = 1-(\frac{364}{365})^n</script></li>
</ol>
<p>有了以上兩個關係式，就可以進行圖表的繪製。x軸表示人數，y軸表示機率，可以看出來兩種理解方式會造成機率有很大的差別！<br><img src="https://i.imgur.com/NcIRKE7.png" alt=""></p>
<p>畫圖程式碼：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Possibility to Number of people&quot;</span>, fontsize=<span class="number">20</span>) <span class="comment">#圖表標題</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of people&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#x軸標題</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Possibility&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#y軸標題</span></span><br><span class="line"></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line">p = <span class="number">1</span></span><br><span class="line">x = []</span><br><span class="line">y1 = []</span><br><span class="line">y2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">365</span>):</span><br><span class="line">    y1.append(<span class="number">1</span>-p)</span><br><span class="line">    p = p*d</span><br><span class="line">    d = d-(<span class="number">1</span>/<span class="number">365</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">365</span>,<span class="number">400</span>):</span><br><span class="line">    y1.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">d2 = <span class="number">364</span>/<span class="number">365</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">400</span>):</span><br><span class="line">    x.append(i)</span><br><span class="line">    y2.append(<span class="number">1</span>-d2)</span><br><span class="line">    d2 = d2*(<span class="number">364</span>/<span class="number">365</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x,y1,<span class="string">&#x27;red&#x27;</span>,label=<span class="string">&#x27;p(n)&#x27;</span>)</span><br><span class="line">plt.plot(x,y2,<span class="string">&#x27;blue&#x27;</span>,label=<span class="string">&#x27;q(n)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show() <span class="comment">#顯示繪製的圖形</span></span><br></pre></td></tr></table></figure></p>
<p>這張圖表還可以告訴我們，任兩個人生日相同的機率很高，但相對的，即使有400個人，要有人跟你的生日相同的機率比6成高一點而已，告訴我們「全部的日期至少有一人生日」的機率其實不高！</p>
<h3 id="其他人與你的生日相同的機率"><a href="#其他人與你的生日相同的機率" class="headerlink" title="其他人與你的生日相同的機率"></a>其他人與你的生日相同的機率</h3><p>如果在看更仔細一點，對於「其他人與你的生日相同的機率」作圖會呈現下方的圖形<br><img src="https://i.imgur.com/DHu0F0g.png" alt=""></p>
<p>因為生日是隨機的，因此在很大量數據測試下，我們可以期望共有365人的時候會出現第一個與自己生日相同日期的人！實際以亂數模擬，所得到的期望值次數與理論是相符的！<br><img src="https://i.imgur.com/UdjoCdI.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> birthday[<span class="number">400</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,t = <span class="number">5000000</span>,times = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(birthday,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(birthday));</span><br><span class="line">        <span class="keyword">int</span> target = <span class="built_in">rand</span>()%<span class="number">365</span>,ind=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            ind = <span class="built_in">rand</span>()%<span class="number">365</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==ind)&#123;</span><br><span class="line">                sum+=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> birthday[ind] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;平均於第：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)sum/t&lt;&lt;<span class="string">&quot;次&quot;</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot;會出現第一個與自己生日相同的人&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="至少k個人生日相同機率"><a href="#至少k個人生日相同機率" class="headerlink" title="至少k個人生日相同機率"></a>至少k個人生日相同機率</h2><p>對於至少k人生日相同的機率要大於50%，需要的人數如下表：<br><img src="https://i.imgur.com/Nwpe6aH.jpg" alt=""><br>用程式驗證看看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">k</th>
<th style="text-align:left">共N人</th>
<th style="text-align:left">機率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">23</td>
<td style="text-align:left">0.506949</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">88</td>
<td style="text-align:left">0.511169</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">187</td>
<td style="text-align:left">0.502883</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">313</td>
<td style="text-align:left">0.501057</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">460</td>
<td style="text-align:left">0.502686</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">623</td>
<td style="text-align:left">0.503298</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">798</td>
<td style="text-align:left">0.500304</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">985</td>
<td style="text-align:left">0.501191</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">1181</td>
<td style="text-align:left">0.500178</td>
</tr>
</tbody>
</table>
</div>
<p>根據<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.8298&amp;rep=rep1&amp;type=pdf">這一篇</a>提供的公式，在$k≤20$的情況下$n\cong47(k-1.5)^{\frac{3}{2}}$，這是這篇作者把k還是很小的時候進行近似，但實際的公式我還不是很了解:cry:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> birthday[<span class="number">400</span>],power[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,t = <span class="number">10000000</span>,times = t;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">23</span>,<span class="number">88</span>,<span class="number">187</span>,<span class="number">313</span>,<span class="number">460</span>,<span class="number">623</span>,<span class="number">798</span>,<span class="number">985</span>,<span class="number">1181</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">        times = t;sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(birthday,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(birthday));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[j];i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> ind = <span class="built_in">rand</span>()%<span class="number">365</span>;</span><br><span class="line">                birthday[ind]+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(birthday[ind]&gt;=j+<span class="number">2</span>)&#123;</span><br><span class="line">                    sum+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">7</span>);</span><br><span class="line">        cout&lt;&lt;(<span class="keyword">double</span>)sum/t&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="機率證明"><a href="#機率證明" class="headerlink" title="機率證明"></a>機率證明</h2><h3 id="公式推討"><a href="#公式推討" class="headerlink" title="公式推討"></a>公式推討</h3><p>生日問題可以理解成：<font color="#f00">至少兩人生日相同的機率</font> 這個問題，而否定這個問題即為：「沒有人生日相同的機率」。因為這兩個事件的聯集即為樣本空間，可以用扣的方式得到答案！</p>
<p>對於房間裡有n人的情況，定義 $p(n)$ 為「至少兩人生日相同的機率」、$p’(n)$ 為「沒有人生日相同的機率」，在不考慮特殊強況（閏年等），並假設生日會平均分佈的狀況下：</p>
<script type="math/tex; mode=display">\begin{split}p(n)&=1-p'(n) \\&= 1-(1\times\frac{364}{365}\times\frac{363}{365}\times\cdots\frac{365-(n-1)}{365})\\\\&=1-\frac{365!}{365^n\cdot(365-n)!}\end{split}</script><p>簡單解釋一下，對於每一個加入房間的人都有365種可能，因此分母皆為365；對於第i個加入的人要避開前i-1個人的生日，因此分子為365-(i-1)。經過整理可以得到這個有階乘又有次方的很難看的一個公式！:neutral_face:</p>
<p>這時候我們可以引入泰勒公式：</p>
<script type="math/tex; mode=display">\begin{split}e^x&=\sum_{k=0}^\infty\frac{x^k}{k!}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}\cdots\end{split}</script><p>為什麼要引入這個公式？是因為我們想要構造出上面機率計算中的每一項 $1-\frac{x}{365}$ ，因為泰勒公式是一個無窮級數，我們可以適度的做一些取捨，例如只取第一項與第二項（在下去都是小數點4,5位以上了)，得到以下：</p>
<script type="math/tex; mode=display">e^x\cong1+x\to e^{-\frac{x}{365}}\cong1-\frac{x}{365}</script><p>接著就可以把每一項替換成多項式的型態：</p>
<script type="math/tex; mode=display">\begin{split}p'(n)&=1\times\frac{364}{365}\times\frac{363}{365}\times\cdots\frac{365-n+1}{365}\\&\cong1\times e^{-\frac{1}{365}}\times e^{-\frac{2}{365}}\times\cdots\times e^{-\frac{n-1}{365}}\\&=e^{-\frac{1+2+\cdots+(n-1)}{365}}\\&=e^{-\frac{n(n-1)/2}{365}}\\&=e^{-\frac{n^2-n}{730}}\end{split}</script><p>接著就可以算出正確的機率了！</p>
<script type="math/tex; mode=display">\begin{split}p(n) &= 1-p'(n)\\&\cong1-e^{-\frac{n^2-n}{730}}\end{split}</script><h3 id="實際機率"><a href="#實際機率" class="headerlink" title="實際機率"></a>實際機率</h3><p>我利用程式實際運算求出機率，並跟公式解做比較如下：<br><img src="https://i.imgur.com/NEJMnOa.png" alt=""><br>發現到誤差會隨著人數增加而有變大的趨勢，不過都是在小數點後三位的事情，誤差不到1%，所以公式解其實是可以用的！其實可以觀察到一個現象，對於$p’(n)$的理論解都會比實際值高，因為多加了幾項被我們省略掉的數字，因此計算出來的公式解會比實際機率低一些！</p>
<h2 id="生日攻擊"><a href="#生日攻擊" class="headerlink" title="生日攻擊"></a>生日攻擊</h2><p>生日攻擊就是利用生日問題的特性在 $\sqrt{H}$ 的時間暴力破解找出碰撞。<a href="https://www.thenewslens.com/article/62378">Google破解SHA1實現碰撞攻擊</a>，如果有人可以讓兩個不同的檔案得出相同雜湊值，讓攻擊者可能偷偷把惡意的程式碼放進檔案，但得出來的雜湊值跟原本的檔案一樣，使人在沒有防備的情況下誤以為危險檔案安全，這可以達到生日攻擊（也就是找到碰撞）</p>
<h3 id="雜湊演算法"><a href="#雜湊演算法" class="headerlink" title="雜湊演算法"></a>雜湊演算法</h3><p>最近有學雜湊相關東西，那剛好生日問題其實跟雜湊很有關係，因為生日可以被當作雜雜湊空間大小，空間越大雖然消耗記憶體較大但發生碰撞的機會會越小。換作是雜湊演算法中，我們想要討論的就是開的空間大小與發生碰撞的嘗試次數的關係。</p>
<p>首先計算生日問題人數的期望值，也就是在加入第幾個人之後，會發生有兩人生日同一天的情況，以下為模擬的情形：<br><img src="https://i.imgur.com/m6Wiwdh.png" alt=""><br>透過公式的計算，可以得到不同人數對應到的機率，假設共i人的情況下機率為f(i)，則f(i)-f(i-1)為加入第i人時恰好有人生日相同的機率，就可以根據期望值的公式算出期望在共有幾人時發生碰撞。以下是計算結果：<br><img src="https://i.imgur.com/mnyAbWk.png" alt=""><br>兩者的誤差極小，可以推論出在平均約在加入第24.617個人的時候會發生碰撞！</p>
<p>我們已經計算出對於n人的情況下任兩人生日相同的機率，這時候可以推廣到不只是365天，也就代表在雜湊空間大小為d的時候發生碰撞的機率如下：</p>
<script type="math/tex; mode=display">\begin{split}p(n) &= 1-p'(n)\\p(n,d)&\cong1-e^{-\frac{n^2-n}{2d}}\end{split}</script><p>因此我寫了一個實際模擬的程式跟這個公式模擬的結果做比較，根據空間大小分別為365與1000做討論，結果如下：<br><img src="https://i.imgur.com/3nuhPHI.png" alt=""><br><img src="https://i.imgur.com/fKVI4QB.png" alt=""></p>
<p>由模擬的結果可以看出，若一年有1000天（假設而已！）則在38個人的團體中任兩人生日同天的機率已經超過50%，跟直覺相差挺大的！</p>
<h3 id="給定機率預測最多數量"><a href="#給定機率預測最多數量" class="headerlink" title="給定機率預測最多數量"></a>給定機率預測最多數量</h3><p>在上面的做法是人數計算機率，可以換一個方式，給定碰撞機率求最多的人數為多少。可以從上面的公式來推，以下n,H分別代表數量與空間大小：</p>
<script type="math/tex; mode=display">\begin{split}p(n,H)&\cong1-e^{-\frac{n^2-n}{2H}}\cong1-e^{-\frac{n^2}{2H}}\\&\to e^{-\frac{n^2}{2H}}=1-p\\&\to e^{\frac{n^2}{2H}}\frac{1}{1-p}\\&\to\frac{n^2}{2H}=\ln\frac{1}{1-p}\\&\to n(p,H)\cong \sqrt{2H\ln\frac{1}{1-p}}\end{split}</script><p>因為我們把$n^2-n$當成$n^2$，所以在小範圍估計的時候會有比較大的誤差，不過當n很大的時候，量級就會是$n^2$，因此可以忽略一次方的$n$</p>
<h3 id="首次碰撞的期望值次數"><a href="#首次碰撞的期望值次數" class="headerlink" title="首次碰撞的期望值次數"></a>首次碰撞的期望值次數</h3><p>在上面有做一次期望值的估計，不過過程蠻麻煩的，要先算出每一個數量機率的差，再乘上數量並加總。這邊有一個公式是提供在範圍很大時的一個估計公式：</p>
<script type="math/tex; mode=display">Q(H)\cong\sqrt{\frac{\pi}{2}H}</script><p>這導出一個重要的結論：對於n位密碼共有$2^n$種可能組合，確僅僅需要期望$2^{\frac{n}{2}}$次嘗試就可以遇到碰撞！以下嘗試H=800000筆與H=1500000筆數據，會有一點誤差，可能的原因是測試的樣本數不夠(100萬次)</p>
<p><img src="https://i.imgur.com/z5Z0cvr.png" alt=""><br><img src="https://i.imgur.com/Xh0yowN.png" alt=""></p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><p>實作的概念就是開一個$O(n)$的陣列紀錄，如果遇到之前出現過的就記錄下來<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> hash_map[<span class="number">2000006</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> N,M;cin&gt;&gt;N&gt;&gt;M;	<span class="comment">//N筆輸入,空間大小M</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> times = t,sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(times--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(hash_map,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(hash_map));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">rand</span>()%M;</span><br><span class="line">            <span class="keyword">if</span>(hash_map[temp]==<span class="number">0</span>)hash_map[temp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;對於輸入筆數共有：&quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot;、空間大小為：&quot;</span>&lt;&lt;M&lt;&lt;endl&lt;&lt;<span class="string">&quot;第一次發生碰撞次數平均值為：&quot;</span>&lt;&lt;(<span class="keyword">double</span>)sum/t&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;理論預測次數：&quot;</span>&lt;&lt;<span class="built_in">sqrt</span>(M_PI_2*M)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//	cout&lt;&lt;&quot;理論預測：&quot;&lt;&lt;1-exp(-(N*(N-1)/(double)(2*M)))&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Cheryl’s-birthday"><a href="#Cheryl’s-birthday" class="headerlink" title="Cheryl’s birthday"></a>Cheryl’s birthday</h2><p>這一題跟生日問題沒啥關係，但既然都提到「生日」，就來看一題有趣的</p>
<blockquote>
<p>艾伯特和柏納剛認識雪莉兒，想要知道雪莉兒的生日，雪莉兒列出了十個可能的日期：<br>5月15日、5月16日、5月19日、6月17日<br>6月18日、7月14日、7月16日、8月14日<br>8月15日、8月17日<br>接著雪莉兒分別告訴艾伯特及柏納她生日的月及日，以下是艾伯特和柏納的回應</p>
<p>艾伯特：我不知道雪莉兒的生日是哪一天，但我知道柏納也不知道<br>柏納：一開始我不知道雪莉兒的生日，但現在我知道了<br>艾伯特：那我也知道雪莉兒的生日了<br>請問雪莉兒的生日是那一天？</p>
<p>[註：艾伯特的第一句話他確定柏納100%不知道生日是哪一天]</p>
</blockquote>
<p>解答點此：<br><img src="https://i.imgur.com/FxwNYkb.png =400x" alt=""></p>
<ol>
<li><p>第一句話中，柏納若要知道明確的生日日期，唯一的可能是生日日期的日在十個可能日期中只出現過一次，也就是18日和19日。但艾伯特說<font color="#f00">他知道柏納也不知道生日是哪一天</font>，因此可以可以排除5月和6月的所有日期（如果是5月或6月有一定的機會艾伯特無法確定柏納不知道是哪一天）</p>
</li>
<li><p>根據第一句話柏納可以推測月份是7月或8月，而他已經知道生日是哪一天，表示他知道的日是在7月或8月中只出現過一次的日，因此可以排除7月及8月可能生日中都有出現的14日，柏納知道的日可能是15日、16日或17日。</p>
</li>
<li><p>目前還有可能的生日是7月16日、8月15日及8月17日，而艾伯特在聽完第二句話就可以知道生日是哪一天，表示他知道的月份在7月16日、8月15日及8月17日中只出現一次。因此他知道的月份是7月，生日是7月16日。</p>
</li>
</ol>
<font color="#f00">答案是7月16日。</font>


<p>這一題跟生日問題其實沒什麼關係，就當作是一個「生日」有關的有趣邏輯推理的題目吧！</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>整理以上提到的公式吧</p>
<h3 id="已知人數推算機率"><a href="#已知人數推算機率" class="headerlink" title="已知人數推算機率"></a>已知人數推算機率</h3><script type="math/tex; mode=display">\begin{split}p(n)&=1-\frac{365!}{365^n\cdot(365-n)!}\end{split}</script><script type="math/tex; mode=display">\begin{split}p(n) \cong1-e^{-\frac{n^2-n}{730}}\end{split}</script><h3 id="已知機率預測數量（也就是人數）"><a href="#已知機率預測數量（也就是人數）" class="headerlink" title="已知機率預測數量（也就是人數）"></a>已知機率預測數量（也就是人數）</h3><script type="math/tex; mode=display">\begin{split}n(p,H)\cong \sqrt{2H\ln\frac{1}{1-p}}\end{split}</script><h3 id="首次碰撞的期望值"><a href="#首次碰撞的期望值" class="headerlink" title="首次碰撞的期望值"></a>首次碰撞的期望值</h3><script type="math/tex; mode=display">Q(H)\cong\sqrt{\frac{\pi}{2}H}</script><p>沒想到生日問題可以衍伸出如此多、如此繁雜的數學公式，不僅僅是數學領域，在資安上面也扮演了一個非常重要的角色，也就是雜湊空間為H的時，根據公式我們可以期望在$\sqrt{H}$的嘗試內找到碰撞，也就是所謂的Birthday Attack！</p>
<h2 id="附錄"><a href="#附錄" class="headerlink" title="附錄"></a>附錄</h2><h3 id="一些數學證明"><a href="#一些數學證明" class="headerlink" title="一些數學證明"></a>一些數學證明</h3><p><img src="https://i.imgur.com/eKXfAI7.jpg =400x" alt=""></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://iter01.com/603052.html">密碼學系列之：生日攻擊</a><br><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C">維基百科：生日問題</a><br><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.8298&amp;rep=rep1&amp;type=pdf">Diaconis and Mosteller 1989 - methods for studying coincidences</a></p>
]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>2021暑期筆記</tag>
        <tag>數學</tag>
      </tags>
  </entry>
  <entry>
    <title>錯排問題（Derangements）</title>
    <url>/2021/07/10/%E9%8C%AF%E6%8E%92%E5%95%8F%E9%A1%8C/</url>
    <content><![CDATA[<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>錯排問題是組合數學中的問題之一。考慮一個有n個元素的排列，若一個排列中<font color="#f00">所有的元素都不在自己原來的位置上</font>，那麼這樣的排列就稱為原排列的一個錯排。<br>n個元素的錯排數記為$D_n$或$!n$。 研究一個排列錯排個數的問題，叫做錯排問題或稱為更列問題。<br><span id="more"></span></p>
<h2 id="規律與公式"><a href="#規律與公式" class="headerlink" title="規律與公式"></a>規律與公式</h2><h3 id="反面枚舉"><a href="#反面枚舉" class="headerlink" title="反面枚舉"></a>反面枚舉</h3><p>前幾項可以用取捨原理（或窮舉所有可能）求得：</p>
<script type="math/tex; mode=display">D_1 = 0 \\ D_2 = 1\\D_3 = 2 \\ D_4 = 9</script><div class="note default">
            <p><strong>三個元素的錯排，以下共兩種：</strong><br><img src="https://i.imgur.com/24cJS8t.png =500x" alt=""></p><p><strong>四個元素的錯排，以下共9種：</strong></p><blockquote><p>4123<br>3421<br>3142<br>4312<br>2413<br>2341<br>4321<br>3412<br>2143</p></blockquote>
          </div>
<p>如下面的文氏圖可以看到，以三個元素的錯排為例，我們要求的就是綠色區域的數量，透過排容原理（取捨原理）來算。<br><img src="https://i.imgur.com/4cSFDiw.png =400x" alt=""></p>
<script type="math/tex; mode=display">\begin{split}D_3 = 3!-C^3_1\cdot2!+C^3_2\cdot1!-C^3_3\cdot0! =2\end{split}</script><p>如果要求 $!4$ 也是一樣的作法：</p>
<script type="math/tex; mode=display">D_4 = 4!-C^4_1\cdot3!+C^4_2\cdot2!-C^4_3\cdot1!+C^4_4\cdot0! = 9</script><p>這邊可以觀察到一個重要的規律，階乘的遞減、C取的數字遞增以及正負交替，這些性質會被用在等一下的一般化推導！</p>
<h3 id="遞迴解"><a href="#遞迴解" class="headerlink" title="遞迴解"></a>遞迴解</h3><p>第一個公式是高中數學利用遞迴的概念得到的：</p>
<script type="math/tex; mode=display">D_n=(n-1)(D_{n-1}+D_{n-2})</script><div class="note success">
            <p><strong>證明：</strong><br>在原本 $n-1$ 個元素當中取一個元素跟新加入的元素（第n個元素）做交換，共有$C^{n-1}_1$ 種取法，假設取到的元素是K，則K有以下兩種情況：</p><ol><li>K本身即不在原本的位置上，跟新加入的元素調換亦是錯排</li><li>K在原本的位置上，跟新加入的元素調換後形成錯排<br><img src="https://i.imgur.com/k7l4Srr.png" alt=""></li></ol><p>綜合以上兩種狀況，可以推得上面的公式 </p>
          </div>
<p>第二個是維基百科上面的公式：</p>
<script type="math/tex; mode=display">D_n = nD_{n-1}+(-1)^n</script><p>這一個公式可以由等一下的一般式的公式（下面的公式解）推討過來：</p>
<script type="math/tex; mode=display">\begin{split}D_n&=n!\sum_{k=0}^{n}\frac{(-1)^k}{k!}\\&=n(n-1)!\sum_{k=0}^{n-1}\frac{(-1)^k}{k!}+n!\cdot\frac{(-1)^n}{n!}\\&=nD_{n-1}+(-1)^n\end{split}</script><p>用這兩個遞迴式可以推得第n項的數值，不過時間複雜度依然是$O(n)$，想要求得的是$O(1)$的公式解</p>
<h3 id="公式解"><a href="#公式解" class="headerlink" title="公式解"></a>公式解</h3><p>公式解可以利用取捨原理求得，寫成一般化的形式。對於第n項的錯排數可以利用之前觀察到排容原理的規律整理出以下式子：</p>
<script type="math/tex; mode=display">\begin{split}D_n&=n!-C^n_1(n-1)!+C^n_2(n-2)!-\cdots+C^n_n0!\\&=\sum^n_{k=0}C^n_k(n-k)!\cdot(-1)^k\\&=\sum_{k=0}^{n}\frac{n!}{k!(n-k)!}\cdot(n-k)!\cdot(-1)^k\\&=n!\sum^{n}_{k=0}\frac{(-1)^k}{k!}\end{split}</script><p>這個就是錯排數的一般化公式，如果想要把sigma消掉，還可以用以下處理：</p>
<script type="math/tex; mode=display">\begin{split}D_n&=n!\sum^{n}_{k=0}\frac{(-1)^k}{k!}\\&=n![1-\frac{1}{1!}+\frac{1}{2!}-\cdots+(-1)^n\frac{1}{n!}]\end{split}</script><p>根據泰勒公式（$R_n$為修正項）</p>
<script type="math/tex; mode=display">\begin{split}e^{-1}&=1+\frac{(-1)^1}{1!}+\frac{(-1)^2}{2!}+\cdots+(-1)^n\frac{1}{n!}+R(n)\\&=[1-\frac{1}{1!}+\frac{1}{2!}-\cdots+(-1)^n\frac{1}{n!}]+R(n)\end{split}</script><p>因為泰勒公式，中括號內的數值在n越大時會越接近$e^{-1}$，因此可以改寫成以下式子：</p>
<script type="math/tex; mode=display">\begin{split}D_n \cong n!\cdot e^{-1}\to\frac{D_n}{n!}\cong e^{-1}\end{split}</script><p>這就是n樣物品錯排的機率，那因為這只是近似值，由於正負交替，數值會在$e^{-1}$ 的地方震盪。為了要求出確切的$D_n$的解，我們要在後面加上一個修正項（泰勒展開餘項$R_n$），經過整理發現這個餘項 $\frac{1}{n+1}$ 會嚴格小於 $0.5$，因此得到以下的一般項公式：</p>
<script type="math/tex; mode=display">D_n=\lfloor\frac{n!}{e}+0.5\rfloor</script><p>以上就是對於一般項$D_n$ 的一般項公式！</p>
<h2 id="實際模擬"><a href="#實際模擬" class="headerlink" title="實際模擬"></a>實際模擬</h2><p>利用ggb的模擬做出震盪的效果，我是直接輸入一般化的公式，但討論n不是正整數的情況其實沒有意義，不過程式還是可以跑出一個數值如下：<br><img src="https://i.imgur.com/0mTp7jo.png" alt=""></p>
<p>最後會趨近於$e^{-1}\cong0.36787944$<br>因為我們討論的都是整數解的狀況，利用python 模擬出正整數解的情況：<br><img src="https://i.imgur.com/VE4q8gh.png" alt=""></p>
<p>印出n從一到20的跟$e^{-1}$的差距，可以看到有正負交替的情況，且每一次的差距都越來越小：<br><img src="https://i.imgur.com/dloPsbD.png" alt=""></p>
<p>以上都是近似的情況，因為公式是一個無窮級數，只會越來越接近理論的機率 $e^{-1}$ ，但永遠都會有一個微小的差距，也就是無限逼近的概念！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">const = np.exp(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">l[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    l[i] = l[i-<span class="number">1</span>]*i</span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">21</span>):</span><br><span class="line">    a[i]= (a[i-<span class="number">1</span>]+a[i-<span class="number">2</span>])*(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    x.append(i)</span><br><span class="line">    y.append((a[i]/l[i]))</span><br><span class="line">    <span class="built_in">print</span>((a[i]/l[i])-const)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Possibility to N&quot;</span>, fontsize=<span class="number">20</span>) <span class="comment">#圖表標題</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;N&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#x軸標題</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Possibility&quot;</span>, fontsize=<span class="number">16</span>) <span class="comment">#y軸標題</span></span><br><span class="line"></span><br><span class="line">plt.xticks([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>])</span><br><span class="line">plt.yticks([<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show() <span class="comment">#顯示繪製的圖形</span></span><br></pre></td></tr></table></figure>
<h2 id="題目—P3182-HAOI2016-放棋子"><a href="#題目—P3182-HAOI2016-放棋子" class="headerlink" title="題目—P3182 [HAOI2016]放棋子"></a>題目—P3182 [HAOI2016]放棋子</h2><p><a href="https://www.luogu.com.cn/problem/P3182">題目連結</a><br>題目敘述是這樣：</p>
<blockquote>
<p>給你一個 N×N 的矩陣，每行有一個障礙，數據保證任意兩個障礙不在同一行，任意兩個障礙不在同一列，要求你在這個矩陣上放 N 枚棋子（障礙的位置不能放棋子），要求你放 N 個棋子也滿足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少種方案。<br>第一行一個N，接下來一個N*N的矩陣。n≤200，0 表示沒有障礙，1 表示有障礙，輸出一個整數，即合法的方案數。</p>
</blockquote>
<p>這一題是在整理錯排相關公式的時候發現這一題，很明顯的，障礙物代表原來的位置，所以其實要求的就是n個元素的錯排種類。因為這一題的n≤200，$D<em>n$的值會接近$200!$的量級，<a href="https://www.wolframalpha.com/input/?i=floor%28%28200%21%2Fe%29%2B0.5%29">大約是$10^{374}$ 這麼多</a>，對大數加法乘法來說卻是輕而易舉！<br>可以用 $D_n = nD</em>{n-1}+(-1)^n$ ，時間複雜度$O(n)$的時間（把大數運算當作O(1)但其實它的常數算大）求出答案！</p>
<p>如果想看從3個元素到200個元素的錯排總數，<a href="https://gist.github.com/peienwu/7a7b5e72e8fd5cb0bc02977938eedc69">可以點這裡！</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,c[<span class="number">1000</span>],lenc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> s,string x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenn = x.<span class="built_in">size</span>(),product[lenc+lenn+<span class="number">10</span>],brr[lenn+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(product,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(product));</span><br><span class="line">    <span class="built_in">memset</span>(brr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(brr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenn;i++)brr[i] = x[lenn-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenn;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenc;j++)&#123;</span><br><span class="line">            product[i+j] += brr[i]*c[j];</span><br><span class="line">            <span class="keyword">if</span>(product[i+j] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                product[i+j+<span class="number">1</span>] += product[i+j]/<span class="number">10</span>;</span><br><span class="line">                product[i+j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lenc+lenn+<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(product[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            lenc = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenc;i++)c[i] = product[i];</span><br><span class="line"></span><br><span class="line">    c[<span class="number">0</span>] += <span class="built_in">power</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="number">10</span>)&#123;</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        c[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[ind]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            c[ind+<span class="number">1</span>]+=<span class="number">1</span>;c[ind] = <span class="number">0</span>;</span><br><span class="line">            ind++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">        c[<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[ind]&lt;=<span class="number">-1</span>)&#123;</span><br><span class="line">            c[ind+<span class="number">1</span>]-=<span class="number">1</span>;c[ind]=<span class="number">9</span>;</span><br><span class="line">            ind++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;lenc=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            string temp = <span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="built_in">calculate</span>(i,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lenc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;c[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>整理一下上面提到錯排數的公式：</p>
<h3 id="遞迴"><a href="#遞迴" class="headerlink" title="遞迴"></a>遞迴</h3><script type="math/tex; mode=display">D_n = (n-1)(D_{n-1}+D_{n-2})\quad,n\ge3\\D_n = nD_{n-1}+(-1)^n\quad,n\ge2</script><h3 id="一般項公式解"><a href="#一般項公式解" class="headerlink" title="一般項公式解"></a>一般項公式解</h3><script type="math/tex; mode=display">D_n=\lfloor\frac{n!}{e}+0.5\rfloor\quad,n\ge1\\D_n=n!\sum^{n}_{k=0}\frac{(-1)^k}{k!}\quad,n\ge1</script><p>分析錯排問題所用到的指數函數與泰勒展開會在以後學到的時候把相關東西補起來，在這之前就先接受結論吧！<br><strong>歐拉：「錯排問題組合數學中的一個奇妙問題」</strong>，實際查找資料發現到高中教錯排也只是淺淺的帶過公式，並沒有很深刻的對這個問題做討論（也算超出範圍啦），就想說對這個主題做更深入的一些探討！</p>
<h2 id="附錄"><a href="#附錄" class="headerlink" title="附錄"></a>附錄</h2><p>一些的數學證明：<br><img src="https://i.imgur.com/oMHPwZR.jpg" alt=""></p>
<p>要用python 繪圖之前要先在mac終端安裝一些東西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip install numpy</span><br><span class="line">python3 -mpip install matplotlib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>數學筆記</category>
      </categories>
      <tags>
        <tag>2021暑假筆記</tag>
        <tag>數學</tag>
      </tags>
  </entry>
  <entry>
    <title>2020資訊之芽—線段樹例題</title>
    <url>/2021/08/06/Segment_Tree_problem/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>NEOJ 80 RMQ練習</li>
<li>NEOJ 249 最大連續和？</li>
<li>ZJ d799 區間求和</li>
<li>NEOJ 367 RMQ˙改</li>
<li>TIOJ 1224 矩形覆蓋面積計算<span id="more"></span>
</li>
</ul>
<h3 id="RMQ練習"><a href="#RMQ練習" class="headerlink" title="RMQ練習"></a>RMQ練習</h3><p><a href="https://neoj.sprout.tw/problem/80/">題目連結</a><br>RMQ = Range minimun query，也就是詢問一個區間的最小值。分析一下兩種不同作法的複雜度：<br><div class="note default">
            <p>對於數列 $a_n$ 共n項，k筆詢問，每一次詢問區間$[l,r]$的最大、最小值</p><p><strong>1. 暴力做</strong><br>時間複雜度：<font color="#f00">詢問$O(n)$</font><br>對於每一筆詢問都暴力搜索，最多掃過n個數字，時間複雜度$O(kn)$，對於數字大一點的情況就會TLE<br><br> </p><p><strong>2. 分塊算法</strong><br>可以參見 <a href="https://hackmd.io/@peienwu/rkCDKEcjd">這篇文章</a></p><p><strong>3. 線段樹</strong><br>時間複雜度：<font color="#f00">預處理 $O(n)$、詢問$O(logn)$</font><br>首先是預處理建立線段樹，線段樹上約有$2n$個節點，因此空間複雜度是$O(n)$，也就表示預處理是$O(n)$，之後便可$O(logn)$查詢每一筆詢問。以下是各種操作複雜度：</p><ul><li><strong>初始建構</strong>：所有節點恰會建構一次，每個節點 $O(1)$，配合節點樹可得為 $O(𝑛)$</li><li><strong>單點修改</strong>：該點的所有祖先節點都會被修改到，其他都不會被修改到，$𝑂(logn)$</li><li><strong>區間查詢</strong>：每筆詢問最多詢問到深度為 $O(logn)$ 的節點。在一次詢問中，每一層不會有超過2個節點被詢問，總複雜度為$𝑂(log𝑛)$<br><br> </li></ul><p><strong>4. 稀疏表(Sparse Table)</strong><br>時間複雜度：<font color="#f00">預處理 $O(nlogn)$、詢問$O(1)$</font><br>參考 <a href="https://hackmd.io/@peienwu/H1W1Y18Gt">這篇文章</a></p>
          </div></p>
<p>這一題就是基礎的要有支援區間查詢、單點修改的線段樹，也是最簡單的一種！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> seg[<span class="number">4</span> * N],arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;</span><br><span class="line">        seg[cur] = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur] = <span class="built_in">min</span>(seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//單點修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ind,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span> &amp;&amp; l==ind)&#123;</span><br><span class="line">        seg[cur]=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind&lt;mid)<span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ind,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ind,val);</span><br><span class="line">    seg[cur] = <span class="built_in">min</span>(seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr),<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x+<span class="number">1</span>,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">2</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大連續和？"><a href="#最大連續和？" class="headerlink" title="最大連續和？"></a>最大連續和？</h3><p><a href="https://neoj.sprout.tw/problem/249/">題目連結</a><br>這題題結果我是WA在INF太大可能會溢位的問題，把INF調整成 $5\times 10^{14}$ 是差不多的</p>
<p>這一題要維護區間最大連續和，跟dp的最大連續和差了「區間」兩字，整個實作的方式跟複雜度就不一樣了。DP的作法如果直接套用在這一題的話，複雜度約為：$O(QN)$，絕對會炸裂，因此只能用線段樹維護這個東西。</p>
<div class="note primary">
            <p><strong>區間最大連續和</strong><br>在分治法的單元有提到分治法最重要的是假定左右兩側（對應過來就是兩子樹）是維護好的，也就是符合定義，要想的是要如何處理橫跨左右子樹的情況。<br>要如何知道橫跨中間的最大值呢？這時候我們可以維護4個數值，來更新每一個線段樹上的節點的數值。</p><ol><li><strong>總和(sum)</strong><br>$cur.sum = left.sum+right.sum$</li><li><strong>最大前綴和(lmax)</strong><br>$cur.lmax = max(left.lmax,left.sum+right.lmax)$</li><li><strong>最大後綴和(rmax)</strong><br>$cur.rmax = max(right.rmax,right.sum+left.rmax)$</li><li><strong>區間最大連續和(tmax)</strong><br>$cur.tmax = max(left.tmax,right.tmax,left.rmax+right.lmax)$</li></ol>
          </div>
<p>維護最大後綴跟最大前綴和（首跟末有被取到的情況），就可以$O(1)$ 維護每一個節點的區間最大連續和，複雜度：詢問$O(logn)$，因此總時間$O(Qlogn)$就可以AC了!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 500000000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;    <span class="comment">//區間總和</span></span><br><span class="line">    <span class="keyword">int</span> lmax;   <span class="comment">//最大前綴和</span></span><br><span class="line">    <span class="keyword">int</span> rmax;   <span class="comment">//最大後綴和</span></span><br><span class="line">    <span class="keyword">int</span> tmax;   <span class="comment">//區間連續最大和</span></span><br><span class="line">&#125;seg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//求當下的區間連續最大和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node &amp;cur,Node &amp;left,Node &amp;right)</span></span>&#123;</span><br><span class="line">    cur.sum = left.sum+right.sum;</span><br><span class="line">    cur.lmax = <span class="built_in">max</span>(left.lmax,left.sum+right.lmax);</span><br><span class="line">    cur.rmax = <span class="built_in">max</span>(right.rmax,right.sum+left.rmax);</span><br><span class="line">    cur.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(left.tmax,right.tmax),left.rmax+right.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立線段樹：[l,r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;</span><br><span class="line">        seg[cur] = &#123;arr[l],arr[l],arr[l],arr[l]&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(mid,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">modify</span>(seg[cur],seg[<span class="number">2</span>*cur],seg[<span class="number">2</span>*cur+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問：[l,r)</span></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> &#123;-INF,-INF,-INF,-INF&#125;;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">2</span>*cur,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">query</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">    Node temp;</span><br><span class="line">    <span class="built_in">modify</span>(temp,left,right);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,l,r+<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(ans.tmax,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="d799區間求和"><a href="#d799區間求和" class="headerlink" title="d799區間求和"></a>d799區間求和</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d799">題目連結</a><br>這一題要求兩個操作，區間加值跟區間查詢，這時候就必須用到<strong>懶標(lazy tags)</strong> 輔助求和。</p>
<blockquote>
<p>範例測資：<br>10<br>1 2 3 4 5 6 7 8 9 10<br>3<br>2 2 4<br>1 3 6 3<br>2 2 4</p>
</blockquote>
<p><img src="https://i.imgur.com/MJMDQE9.jpg" alt=""><br>左邊是整棵線段樹，右邊則是懶標，可以看到3要往下推，但學長的程式碼中並沒有執行這個步驟，這樣會導致query的時候發生錯誤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>            <span class="comment">//線段樹每一個節點</span></span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>,tag=<span class="number">0</span>,sz; <span class="comment">//val原本的值、tag懶標、sz區間大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rv</span><span class="params">()</span></span>&#123;           <span class="comment">//回傳實際節點的值</span></span><br><span class="line">        <span class="keyword">return</span> val+tag*sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;    <span class="comment">//建立線段樹</span></span><br><span class="line">    seg[cur].sz = r-l;              <span class="comment">//更新節點的大小</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;                 <span class="comment">//空區間回傳</span></span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;                     <span class="comment">//設定當前節點的值</span></span><br><span class="line">        seg[cur].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;                <span class="comment">//分別遞迴建立左右子樹</span></span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].val+seg[<span class="number">2</span>*cur+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把id的懶標在query的時候往下推</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    seg[<span class="number">2</span>*id].tag += seg[id].tag;   <span class="comment">//左子樹懶標更新</span></span><br><span class="line">    seg[<span class="number">2</span>*id+<span class="number">1</span>].tag += seg[id].tag; <span class="comment">//右子樹懶標更新</span></span><br><span class="line">    seg[id].val = seg[id].<span class="built_in">rv</span>();     <span class="comment">//更新實際值</span></span><br><span class="line">    seg[id].tag = <span class="number">0</span>;                <span class="comment">//往下推完之後設定為預設</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=l||ql&gt;=r||qr&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;</span><br><span class="line">        seg[cur].tag += val;               <span class="comment">//將被完整包含的區間的懶標加上修改值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ql,qr,val);          <span class="comment">//修改左右子樹</span></span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);        <span class="comment">//遞迴完拉上來的過程中把上面的數值更新成有懶標</span></span><br><span class="line">    seg[cur].val = seg[<span class="number">2</span>*cur].<span class="built_in">rv</span>()+seg[<span class="number">2</span>*cur+<span class="number">1</span>].<span class="built_in">rv</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">//空集合直接回傳</span></span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur].<span class="built_in">rv</span>();     <span class="comment">//包含在要詢問的範圍中，回傳實際值</span></span><br><span class="line">    <span class="built_in">push</span>(cur);                                  <span class="comment">//將懶標在遞迴下去的過程中下推</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;                          <span class="comment">//遞迴查詢左右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr)+<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RMQ˙改"><a href="#RMQ˙改" class="headerlink" title="RMQ˙改"></a>RMQ˙改</h3><p><a href="https://neoj.sprout.tw/problem/367/">題目連結</a><br>這一題是Range Maximum Query搭配區間加值，如果直接套用前面RMQ或是區間和的模板就輕鬆許多。這一題主要跟前面題目的不同在於它的sz要維護成1，有別於求區間和要乘上區間大小，每一個值不需要乘上區間大小，因此設成0。</p>
<p>這題第二筆測資明顯就是要卡暴力解法。<br><img src="https://i.imgur.com/tC2Wucw.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e14</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>            <span class="comment">//線段樹每一個節點</span></span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>,tag=<span class="number">0</span>,sz=<span class="number">0</span>; <span class="comment">//val原本的值、tag懶標、sz區間大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rv</span><span class="params">()</span></span>&#123;           <span class="comment">//回傳實際節點的值</span></span><br><span class="line">        <span class="keyword">return</span> val+tag*sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;    <span class="comment">//建立線段樹</span></span><br><span class="line">    seg[cur].sz = <span class="number">1</span>;                <span class="comment">//更新節點的大小</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l)<span class="keyword">return</span>;                 <span class="comment">//空區間回傳</span></span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;                     <span class="comment">//設定當前節點的值</span></span><br><span class="line">        seg[cur].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;                <span class="comment">//分別遞迴建立左右子樹</span></span><br><span class="line">    <span class="built_in">build</span>(l,m,<span class="number">2</span>*cur);</span><br><span class="line">    <span class="built_in">build</span>(m,r,<span class="number">2</span>*cur+<span class="number">1</span>);</span><br><span class="line">    seg[cur].val = <span class="built_in">max</span>(seg[<span class="number">2</span>*cur].val,seg[<span class="number">2</span>*cur+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把id的懶標在query的時候往下推</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    seg[<span class="number">2</span>*id].tag += seg[id].tag;   <span class="comment">//左子樹懶標更新</span></span><br><span class="line">    seg[<span class="number">2</span>*id+<span class="number">1</span>].tag += seg[id].tag; <span class="comment">//右子樹懶標更新</span></span><br><span class="line">    seg[id].val = seg[id].<span class="built_in">rv</span>();     <span class="comment">//更新實際值</span></span><br><span class="line">    seg[id].tag = <span class="number">0</span>;                <span class="comment">//往下推完之後設定為預設</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=l||ql&gt;=r||qr&lt;=l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;</span><br><span class="line">        seg[cur].tag += val;               <span class="comment">//將被完整包含的區間的懶標加上修改值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>,l,mid,ql,qr,val);          <span class="comment">//修改左右子樹</span></span><br><span class="line">    <span class="built_in">modify</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr,val);        <span class="comment">//遞迴完拉上來的過程中把上面的數值更新成有懶標</span></span><br><span class="line">    seg[cur].val = <span class="built_in">max</span>(seg[<span class="number">2</span>*cur].<span class="built_in">rv</span>(),seg[<span class="number">2</span>*cur+<span class="number">1</span>].<span class="built_in">rv</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//區間詢問</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=l || ql&gt;=r || qr&lt;=l)<span class="keyword">return</span> -INF;      <span class="comment">//空集合直接回傳</span></span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l &amp;&amp; qr&gt;=r)<span class="keyword">return</span> seg[cur].<span class="built_in">rv</span>();     <span class="comment">//包含在要詢問的範圍中，回傳實際值</span></span><br><span class="line">    <span class="built_in">push</span>(cur);                                  <span class="comment">//將懶標在遞迴下去的過程中下推</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;                          <span class="comment">//遞迴查詢左右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(cur*<span class="number">2</span>,l,mid,ql,qr),<span class="built_in">query</span>(cur*<span class="number">2</span>+<span class="number">1</span>,mid,r,ql,qr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> p;cin&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>,x,y+<span class="number">1</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1224-矩形覆蓋面積計算"><a href="#1224-矩形覆蓋面積計算" class="headerlink" title="1224 . 矩形覆蓋面積計算"></a>1224 . 矩形覆蓋面積計算</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1224">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/261541">Submission2:AC</a></p>
<blockquote>
<p>題意：給你平面上n個矩形，請求出它們覆蓋的總表面積。</p>
</blockquote>
<p>這一題所使用的技巧是<font color="#f00">掃描線</font>以及<font color="#f00">線段樹</font>，下圖中的水平藍色線即為掃描線，由y=0開始往上掃描，當遇到了矩形的邊，利用線段樹查詢區間內當前的矩形寬度，乘上兩掃描線的高度差即為面積。當然，掃描線也可以使用垂直方向的線段由左而右的掃描，實作細節是一樣的。</p>
<p><img src="https://i.imgur.com/pAsHmXd.jpg" alt=""></p>
<h4 id="線段樹維護"><a href="#線段樹維護" class="headerlink" title="線段樹維護"></a>線段樹維護</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>我們可以定義線段樹$seg[cur]$為區間$[l,r]$中有被<strong>矩形覆蓋的大小</strong>有多大，也就是圖中當前掃描線對應到的區域的寬度。這樣子維護有一個問題，當我們直接用$seg[cur]$儲存答案，我們在修改的時候沒有辦法確切知道這段區間被覆蓋的情況。</p>
<p>下圖為一種模擬的情況，每一個區間的數字代表著非0的數字個數，也就是它的寬度。今天我們要對區間$[4,6]$加減值，將區間拆成$[4,4]$跟$[5,6]$，這時候區間$[3,4]$的數值是1，我們卻不知道到底是3還是4是有被覆蓋到的，必須要遞迴下去到葉節點才能得到完整的覆蓋情況，這時候每一次加減值的複雜就會提升到$O(n)$，因此不能以這種方式維護。</p>
<p><img src="https://i.imgur.com/DOeuFyx.png" alt=""></p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>有別於第一種方法對$seg[id]$進行維護，我們可以多開一個區間 $tag$ 來紀錄被矩形覆蓋的情況。下圖有3個矩形，其中的數字代表每一塊區域被覆蓋的情況，這邊使用了$tag$來紀錄（他是附在區間上的，不會像圖中一樣的方式呈現）。tag的數值為非負整數，紀錄當前區間有多少矩形覆蓋在上面，用$tag$來輔助維護$seg[id]$可以在$O(logn)$的時間進行修改與查詢。</p>
<p><img src="https://i.imgur.com/xGuEmB4.jpg" alt=""></p>
<p>以下程式碼是是 $tag$ 的轉移，當大的區間的tag值不為0，代表有一個矩形曾完整覆蓋這個區間，這時候可以直接回傳區間大小，否則即回傳左右節點的$sed[left],seg[right]$的數值。</p>
<p>這邊定義$seg[id]$為：「考慮 id 的子孫們（不含 id 本身）的所有 tag 值，假設這些子孫只有被tag值作用過，共有多少非0的數字」。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">seg[cur].val = (seg[<span class="number">2</span>*cur].tag?mid-l:seg[<span class="number">2</span>*cur].val)</span><br><span class="line">              +(seg[<span class="number">2</span>*cur+<span class="number">1</span>].tag?r-mid:seg[<span class="number">2</span>*cur+<span class="number">1</span>].val);</span><br></pre></td></tr></table></figure>
<h4 id="實作方法"><a href="#實作方法" class="headerlink" title="實作方法"></a>實作方法</h4><h5 id="矩形維護"><a href="#矩形維護" class="headerlink" title="矩形維護"></a>矩形維護</h5><p>首先是維護矩形的方法。我們一個矩形總共要維護四個東西：矩形左界x1、矩形右界x2、矩形上下界的y座標（分上下兩條），這兩條邊是下界或是上界val。為什麼要水平方向要分兩條討論？是因為下界代表進入，當掃描線掃到這一條邊的時候表示我們要新增區間 $[x1,x2)$ 進入線段樹；反之如果掃到了上界，則表示離開這個矩形，在線段樹中扣掉區間 $[x1,x2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>    <span class="comment">//每一個矩陣分成上下兩條邊</span></span><br><span class="line">    <span class="keyword">int</span> x1;     <span class="comment">//矩形左界x1</span></span><br><span class="line">    <span class="keyword">int</span> x2;     <span class="comment">//矩形右界x2</span></span><br><span class="line">    <span class="keyword">int</span> y;      <span class="comment">//矩形y座標（分上下兩邊）</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//val = ±1(進入代表1、離開代表-1)</span></span><br><span class="line">    </span><br><span class="line">&#125;arr[<span class="number">2</span>*N];</span><br></pre></td></tr></table></figure>
<p>上下界我們利用val維護，當 $val=1$ 時表示是矩形的下界； $val=-1$ 則是矩形上界，這兩個搭配在一起剛好就可以用線段樹區間加值的方式進行操作！總共有 $n$ 個矩形，因此我們要掃描線總共掃描 $2n$ 條線段。</p>
<h5 id="線段樹"><a href="#線段樹" class="headerlink" title="線段樹"></a>線段樹</h5><p>一樣對值域（這題是1000000）的4倍開了線段樹，同時維護一個非負整數 $tag$ 表示區間被覆蓋的情況。當每一次修改完成之後，我們可以直接取用根節點 $seg[1]$ 的數值表示寬度（非0的個數）！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//seg[i]表示i的左右兩子樹的區間非0的個數</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>    <span class="comment">//建立線段樹</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//維護非0個數</span></span><br><span class="line">    <span class="keyword">int</span> tag;    <span class="comment">//使用tag紀錄區間被覆蓋次數</span></span><br><span class="line">&#125;seg[<span class="number">4</span>*M];</span><br></pre></td></tr></table></figure><br>接下來就是在程式執行的過程中將 $2n$ 條邊依照y座標進行排序 $O(nlogn)$，接著依序使用掃描線搭配線段樹的修改，計算矩形的面積。最後就是輸出加起來的答案。</p>
<div class="note info">
            <p><strong>Debug 小錯誤</strong><br><a href="https://tioj.ck.tp.edu.tw/submissions/261512">Submission1:WA</a><br>可以看到有一筆測資過不了，95分QQQ</p><p><img src="https://i.imgur.com/1UNrejV.png" alt=""></p><p>後來debug之後發現到，因為我是對每一個矩形先輸入下界之後才是上界，當我在排序的過程中，上界有可能有機會跑到下界之前，造成 $tag$ 被扣到負的情況，但在定義中可以清楚知道 $tag$ 是非負整數造成錯誤。因此只要把排序的過程改成 stable_sort() 即可！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(arr,arr+(n&lt;&lt;<span class="number">1</span>),cmp);</span><br></pre></td></tr></table></figure>
          </div>
<p>最後終於是程式碼的部分，以下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lld long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>    <span class="comment">//每一個矩陣分成上下兩條邊</span></span><br><span class="line">    <span class="keyword">int</span> x1;     <span class="comment">//矩形左界x1</span></span><br><span class="line">    <span class="keyword">int</span> x2;     <span class="comment">//矩形右界x2</span></span><br><span class="line">    <span class="keyword">int</span> y;      <span class="comment">//矩形y座標（分上下兩邊）</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//val = ±1(進入代表1、離開代表-1)</span></span><br><span class="line">    </span><br><span class="line">&#125;arr[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//seg[i]表示i的左右兩子樹的區間非0的個數</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>    <span class="comment">//建立線段樹</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//維護非0個數</span></span><br><span class="line">    <span class="keyword">int</span> tag;    <span class="comment">//使用tag紀錄區間被覆蓋次數</span></span><br><span class="line">    </span><br><span class="line">&#125;seg[<span class="number">4</span>*M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//對區間[ql,qr)進行加值val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l || ql &gt;= r || qr &lt;= l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;</span><br><span class="line">        seg[cur].tag += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">2</span>*cur,l,mid,ql,qr,val);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">2</span>*cur+<span class="number">1</span>,mid,r,ql,qr,val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左右節點如有tag表示被完全覆蓋，直接加上區間大小，否則加上seg[左右子樹]</span></span><br><span class="line">    seg[cur].val = (seg[<span class="number">2</span>*cur].tag?mid-l:seg[<span class="number">2</span>*cur].val)</span><br><span class="line">                  +(seg[<span class="number">2</span>*cur+<span class="number">1</span>].tag?r-mid:seg[<span class="number">2</span>*cur+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="built_in">memset</span>(seg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(seg));</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;                                   <span class="comment">//依序輸入左右下上：x1,x2,y1,y2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;y1&gt;&gt;y2;</span><br><span class="line">        arr[i] = (Node)&#123;x1,x2,y1,<span class="number">1</span>&#125;;          <span class="comment">//插入矩形下邊，帶入val = 1</span></span><br><span class="line">        arr[i+<span class="number">1</span>] = (Node)&#123;x1,x2,y2,<span class="number">-1</span>&#125;;       <span class="comment">//上邊要val = -1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stable_sort</span>(arr,arr+(n&lt;&lt;<span class="number">1</span>),cmp);          <span class="comment">//依照y座標由小到大排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> y0 = <span class="number">0</span>,val = <span class="number">0</span>;                       <span class="comment">//有下而上的枚舉所有水平邊</span></span><br><span class="line">    lld ans = <span class="number">0LL</span>;                            <span class="comment">//上一條y的座標，計算高，val為矩形結合起來的寬</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i++)&#123;                <span class="comment">//枚舉2n條y的邊</span></span><br><span class="line">        ans += (lld)(arr[i].y-y0)*val;        <span class="comment">//計算面積（寬*高）</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">0</span>,M,arr[i].x1,arr[i].x2,arr[i].val);</span><br><span class="line">        y0 = arr[i].y;</span><br><span class="line">        val = seg[<span class="number">1</span>].val;                     <span class="comment">//修改後（下一輪）的矩陣寬度</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>線段樹</category>
      </categories>
      <tags>
        <tag>2020資訊之芽</tag>
        <tag>2021暑假筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>字串演算法 (String)</title>
    <url>/2021/09/04/String/</url>
    <content><![CDATA[<p>這個暑假看了動態規劃(1),(2)，線段樹、最短路徑、計算幾何、字串演算法，這一篇的完成算是暑假的一個里程吧！接下來繼續學習不同的主題，再把筆記更新到部落格中！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><ul>
<li>定義<ul>
<li>大寫 $\Sigma$ 表示字元集</li>
<li>字串：有限個字元集組成</li>
<li>$|\Sigma|$ 字元集大小、|S|字串長度</li>
<li>S[a:b]表示連續從字元a到b<span id="more"></span></li>
</ul>
</li>
<li>子字串：S[a:b]</li>
<li>前綴：S[0:b]</li>
<li>後綴：S[a:|S|-1]</li>
</ul>
<h3 id="字典樹Trie"><a href="#字典樹Trie" class="headerlink" title="字典樹Trie"></a>字典樹Trie</h3><ul>
<li>定義<ul>
<li>例題：字串出現次數</li>
<li>一顆由根、邊一綠往下指的有向樹</li>
<li>每個邊為字元、每一點代表字串</li>
<li>每經過一條邊，字串加上邊的字元</li>
<li>根節點為空字串！</li>
</ul>
</li>
<li>操作<ul>
<li>查詢字串：$O(L)$，由根順著邊往下找</li>
<li>插入字串：$O(L)$，不斷往下走直到空節點，在Trie加入一個節點</li>
<li>節點必須記錄當前是否為有效字串</li>
<li>Trie結構中包含：字串、紀錄字串出現次數</li>
</ul>
</li>
</ul>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><ul>
<li>功能：進行字串匹配</li>
<li>例題：字串S在字串T哪些位置出現<ul>
<li>暴力匹配：時間 $O(|S|\times|T|)$</li>
</ul>
</li>
<li>F[i]表示當配對成功A[0:i]後即配對失敗，將A[F[i]]對齊原本A[i]的位置</li>
<li>搭配F[i]調整在串移動的長度</li>
<li>匹配：複雜度 $O(|T|)$，建立F函數：$O(|S|)$</li>
</ul>
<h3 id="漢明距離-Hamming-distance"><a href="#漢明距離-Hamming-distance" class="headerlink" title="漢明距離(Hamming distance)"></a>漢明距離(Hamming distance)</h3><ul>
<li>兩個等長字符串對應位置的不同字符的個數</li>
</ul>
<h3 id="Z-value"><a href="#Z-value" class="headerlink" title="Z-value"></a>Z-value</h3><ul>
<li>z[i] 是指由 s[i] 開始的字串，與 s[0] 開始的字串可以匹配到多長</li>
<li>S[0:k-1] = S[i:i+k-1]</li>
<li>z[0] = 0</li>
</ul>
<h3 id="Rolling-Hash"><a href="#Rolling-Hash" class="headerlink" title="Rolling Hash"></a>Rolling Hash</h3><ul>
<li>之前隨機講過</li>
</ul>
<h3 id="後綴數組（Suffix-Array）"><a href="#後綴數組（Suffix-Array）" class="headerlink" title="後綴數組（Suffix Array）"></a>後綴數組（Suffix Array）</h3><ul>
<li>將一個字串的所有後綴進行排序</li>
<li>基數排序（Radix Sort）</li>
</ul>
<h3 id="最長共同前綴（LCP-Longest-Common-Prefix）"><a href="#最長共同前綴（LCP-Longest-Common-Prefix）" class="headerlink" title="最長共同前綴（LCP,Longest Common Prefix）"></a>最長共同前綴（LCP,Longest Common Prefix）</h3><ul>
<li>兩字串的最長共同前綴</li>
<li>將最長共同前綴轉換成區間最小值問題</li>
</ul>
<h2 id="字串演算法主題"><a href="#字串演算法主題" class="headerlink" title="字串演算法主題"></a>字串演算法主題</h2><h3 id="字典樹Trie-1"><a href="#字典樹Trie-1" class="headerlink" title="字典樹Trie"></a>字典樹Trie</h3><p>字典樹是以指標型態建立的一棵樹，邊代表一個字元、節點代表從根一路走來的邊形成的字串，從根節點開始（根節點為空），每經過一條邊，就把字串加上那一條邊對應的字元，直到找出要匹配的字串。如果有多筆獨立的詢問，只要加上Delete函數就可以了！</p>
<h4 id="Trie結構"><a href="#Trie結構" class="headerlink" title="Trie結構"></a>Trie結構</h4><p>實作上的陣列c指向個別的字元，不一定要用cnt，根據題目的所求調整不同的變數設定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span>        <span class="comment">//利用指標建立一棵樹</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];    <span class="comment">//對應a-z每一條邊</span></span><br><span class="line">    <span class="keyword">int</span> cnt;        <span class="comment">//字串出現次數</span></span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">cnt</span>(<span class="number">0</span>)&#123; <span class="comment">//初始設定</span></span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie* root;</span><br></pre></td></tr></table></figure>
<h4 id="Insert函數"><a href="#Insert函數" class="headerlink" title="Insert函數"></a>Insert函數</h4><p>在插入的過程中言錄新增路徑，一樣嘢可以根據題目要求在過程中進行變數紀錄等。如<strong>NEOJ 267 自動完成系統</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;           <span class="comment">//從根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])     <span class="comment">//如果樹上無此字元則new</span></span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*s)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];   <span class="comment">//繼續造訪Trie</span></span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;cnt += <span class="number">1</span>;              <span class="comment">//字串出現次數(字串對應唯一葉節點)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查詢函數"><a href="#查詢函數" class="headerlink" title="查詢函數"></a>查詢函數</h4><p>一個字串對應到唯一的路徑，從根節點根據每一個字元決定路徑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;              <span class="comment">//查找字串s</span></span><br><span class="line">    Trie *ptr = root;           <span class="comment">//根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;                  <span class="comment">//無此字串，回傳次數0</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];</span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;cnt;            <span class="comment">//回傳字串出現次數</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Delete函數"><a href="#Delete函數" class="headerlink" title="Delete函數"></a>Delete函數</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Trie *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;c[i])&#123;</span><br><span class="line">            <span class="built_in">clear</span>(s-&gt;c[i]);</span><br><span class="line">            <span class="keyword">delete</span> s-&gt;c[i];</span><br><span class="line">            s-&gt;c[i] = <span class="literal">nullptr</span>;    <span class="comment">//很重要</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h3><p>首先要求出Failure Function，它可以在 $O(|S|)$ 建立。失敗函數的定義是：</p>
<blockquote>
<p>$F[i]$ 表示當成功配對 $A[0:i]$ 之後，配對失敗時，我們會將 $A[ F[i]]$ 對齊原本 $A[i]$ 的位置</p>
</blockquote>
<p>如果寫成數學式的定義：</p>
<script type="math/tex; mode=display">F_A(J)=\left\{
\begin{array}{l}
-1,&&\text{if j = 0}\\
max\{p:A_{0...p} = A_{j-p...j} \text{ and 0≤p<j}\},&&\text{otherwise}\\
\end{array} \right.</script><p>這個函式以中文來說就是「<strong>最大前綴後綴</strong>」！</p>
<p>這個函數可以讓我們知道，當配對在較短字串 $S$ 在第 $i$ 位配對失敗時，要找到第 $F[i]$ 去繼續比對。從比較直觀的角度去理解，就是把字串要往右移幾格才能正確匹配上，如果配對失敗，則尋找更前面更短的子字串試試看。</p>
<p>以比較數學的角度看到底要怎麼建立Failure Function，可以從以下推導得知：</p>
<div class="note info">
            <p>假設 $F[i] = x, x≠-1$，根據上面的定義有這樣的等式：$A[0:x] = A[i-x:i]$<br>分成以下兩種情況做討論：</p><ul><li><p>$A[x+1] = A[i+1]$<br>這種情況就是兩邊的下一個字串都相同，直接將繼承前面的長度為x的子字串，因此有關係式$F[i+1] = x+1$</p></li><li><p>$A[x+1] ≠ A[i+1]$<br>這種情況比較棘手，我們無法繼續使用之前長度為x的子字串，因此我們要尋找前面更短的字串進行匹配。假設我們找到 $K$ 滿足 k&lt;x，同時 $A[0:k] = A[i-k:i]$ ，這時候我們只需確認 $A[k+1]=A[i+1]$ 是否成立即可，如果不成立則繼續尋找比 $K$ 更短的子字串。</p></li></ul><p><br></p><p>從剛剛的關係式，我們可以繼續寫下去： $A[0:k] = A[i-k:i]=A[x-k:x]$，理由是i的後綴與x後綴相同，因此 k的後綴就會和x的後綴相同。由失敗函式的定義推斷，我們要找的 $k$ 就會是 x 的失敗函式，$K = F[x]$。</p><p>如果找到的k不滿足 $A[k+1]=A[i+1]$ ，則會繼續尋找下一個更小的 $k$ 值直到滿足條件或是 $k=-1$ 為止。</p>
          </div>
<p>再來則是KMP MATCH，能在時間複雜度 $O(|T|)$ 內將匹配出來的位置找出來。具體的方法與建立Failure Function 相近，如果 $A[p+1]≠A[i+1]$，則尋找更小的字串長度 $k&lt;F[i]$ 看能否繼續匹配。當匹配成功，記得把p設為F[p]，因為匹配完成其實也可以看作是下一個字元匹配失敗（$S$ 的空字元對上 $T$ 的下一個）。</p>
<p>至於時間複雜度的部分，分析一下while迴圈總共會執行的次數，當每執行一次，p的值一定會遞減，而p只會在每一個迴圈最多加上一，因此p的增加會是字串長度 $|T|$ 的常數倍，使總複雜度為 $O(|T|)$。</p>
<h4 id="Build-Function"><a href="#Build-Function" class="headerlink" title="Build Function"></a>Build Function</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(|S|)要配對的字串以及Fail Function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_build</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = F[<span class="number">0</span>] = <span class="number">-1</span>;              <span class="comment">//初始設定為-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;          <span class="comment">//1到接下來字元</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=S[i])</span><br><span class="line">            p = F[p];               <span class="comment">//無法繼續配對，尋找更短字串</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == S[i])          <span class="comment">//配對成功(如都沒有一樣的就-1)</span></span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        F[i] = p;                   <span class="comment">//設定F[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Match-Function"><a href="#Match-Function" class="headerlink" title="Match Function"></a>Match Function</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">KMP_match</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F,<span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;            <span class="comment">//回傳匹配相同地方</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;                 <span class="comment">//紀錄短字串有多少被匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)&#123;      <span class="comment">//每一迴圈都讓T[i]被匹配到</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=T[i])</span><br><span class="line">            p = F[p];           <span class="comment">//使T[i]一定可以被匹配到</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == T[i])</span><br><span class="line">            p += <span class="number">1</span>;             <span class="comment">//T的第i個與S的p+1可以匹配</span></span><br><span class="line">        <span class="keyword">if</span>(!S[p+<span class="number">1</span>])&#123;            <span class="comment">//S[p]已經匹配完成</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-p); <span class="comment">//回推匹配開頭</span></span><br><span class="line">            p = F[p];           <span class="comment">//繼續下一輪匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hash-Robin-Karp-Algorithm"><a href="#Hash-Robin-Karp-Algorithm" class="headerlink" title="Hash (Robin-Karp Algorithm)"></a>Hash (Robin-Karp Algorithm)</h3><p>雜湊算法的核心概念就是以下公式，可以透過它進行字串比對等等。</p>
<script type="math/tex; mode=display">H(s[1:n]) = \sum_{i=0}^n S_i\times C^{n-i}</script><p>詳細內容可以參閱這一篇：<a href="https://hackmd.io/@peienwu/random">隨機演算法</a></p>
<h3 id="Z-Algorithm-Gusfield’s-Algorithm"><a href="#Z-Algorithm-Gusfield’s-Algorithm" class="headerlink" title="Z Algorithm (Gusfield’s Algorithm)"></a>Z Algorithm (Gusfield’s Algorithm)</h3><p>Z函數的定義是對於字串長度 $n$ 的字串 $S$ ，$z[i]$ 函數代表 $S[0:n-1]$ 和 $S[i:n-1]$ 的<strong>最長共同前綴</strong>，也就是LCP長度。定義 $z[0] = 0$。</p>
<p>有講義上面寫Z Function很簡單，但我覺得有夠難，難度跟KMP的理解差不多。根據Z函數的定義，我們可以$O(N^2)$建立z函數，顯然時間有些太多了。如果我們算 $Z[i]$ 的值可以用 $Z[0:i-1]$ 轉移過來，會省下許多時間，把時間降成 $O(N)$。</p>
<h4 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h4><p>整個算法的核心概念就是利用前面已經算好的Z Function去推現在的值，有點像動態規劃的概念。在整個過程中我們會維護右端點最大的匹配段（與前綴匹配），其表示為 $[l:l+Z[l]]$，也可以寫作 $[l:r]$，保證 $l ≤ r$。在計算 $Z[i]$ 的過程中，分別討論以下三種情形：</p>
<ol>
<li><p>$i ≤ r$<br>根據定義，因為區間 $[l:r]$ 本身是前綴，因此當 $i$ 在區間中間時會將區間分成左右兩半邊，將正個區間往前平移會讓 $i$ 對應到 $i-l$ 的位置，又此時區間為 $[0:r-l]$ ，因此$z[i] = min(z[i-l],r-i)$。</p>
<ul>
<li>$z[i-l] ≤ r-i$<br>已經知道 $z[i-l] &lt; r-i$ 表示在前後兩區間（分別從0,i開始）在一樣的情況下做多不超過 $z[i-l]$ 長度的匹配，因此第 $z[i-l]$ 的下一個字元必定無法繼續匹配成前綴。</li>
<li>$z[i-l] &gt; r-i$<br>在這種情況下已知 $s[0:r-l] = s[l:r]$，根據定義 $s[i-l:r-l] = s[i:r]$。因為 $z[i-l] &gt; r-i$，$z[i-l]$ 右端的範圍會超過 $r$ ，也就是說超過 $r$ 之後這個性質 $s[i-l:r-l] = s[i:r]$ 就不會成立，但可以確定 $z[i]$ 至少為 $r-i$。接著就暴力枚舉即可！</li>
</ul>
</li>
</ol>
<p>上面的內容可以用下圖解釋，兩條紅線段是一樣的，$x=i-l$ ，接著討論$Z[x]$ 的長度就可以知道該如何更新。<br><img src="https://i.imgur.com/6WU1JWG.png" alt=""></p>
<ol>
<li>$i &gt; r$<br>這種情況我們可以直接暴力跟前綴匹配。</li>
</ol>
<h4 id="程式實作1"><a href="#程式實作1" class="headerlink" title="程式實作1"></a>程式實作1</h4><p>程式碼中 $bst$ 表示的是左界 $l$，右界則是 $bst+Z[bst]$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo1</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *Z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bst = <span class="number">0</span>;                            <span class="comment">//相當於左界，大小為z[bst]</span></span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[bst]+bst &lt; i)Z[i] = <span class="number">0</span>;         <span class="comment">//直接暴力枚舉</span></span><br><span class="line">        <span class="keyword">else</span> Z[i] = <span class="built_in">min</span>(Z[i-bst],bst+Z[bst]-i);</span><br><span class="line">        <span class="keyword">while</span>(S[Z[i]]==S[i+Z[i]])Z[i]++;    <span class="comment">//依序暴力枚舉</span></span><br><span class="line">        <span class="keyword">if</span>(Z[i]+i &gt; bst+Z[bst])bst = i;     <span class="comment">//更新更遠的右界</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="程式實作2"><a href="#程式實作2" class="headerlink" title="程式實作2"></a>程式實作2</h4><p>這個實作超級短，沒有幾行就解決了，但他的效果卻是一樣的！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo2</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *Z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;                       <span class="comment">//左右界</span></span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[i-l],r-i),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(S[i+Z[i]] &amp;&amp; S[Z[i]] == S[i+Z[i]])&#123;</span><br><span class="line">            r = i+Z[i];               <span class="comment">//更新右界</span></span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;<span class="comment">//保證當Z[i]從Z[i-l]轉移時不會被更新！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>根據以上兩個程式碼可以發現，右界 $r$ 或是 $bst+Z[bst]$ 在過程中是不斷增大的，且r必定不會超過n，因此迴圈跑下來複雜度會是 $O(N)$。</p>
<h3 id="LPS-Manacher’s-Algorithm"><a href="#LPS-Manacher’s-Algorithm" class="headerlink" title="LPS (Manacher’s Algorithm)"></a>LPS (Manacher’s Algorithm)</h3><p>LPS (Longest Palindromic Substring)就是最長回文子字串，Naive的作法是每次 $O(n)$ 向兩側擴展，時間是 $O(n^2)$。</p>
<p>Manacher’s Algorithm這個演算法的概念和Z Alogorithm相近，可以在 $O(n)$ 的時間內找出以每一個點為中心之最長回文長度。回文的定義是無論從正序或是逆序看一個字串都是一樣的，分為兩種：一種是奇數的對稱，也就是以一個字元為對稱中心往兩側擴展；另一種則是以字元間的空格為對稱中心向兩側對稱。</p>
<p>這兩個的性質很不同，在處理的時候我們也不知道到底是呈現怎麼樣對稱的狀況，因此可以使用一種手法：將每一個字元中間插入同樣沒有出現過的字元，如此一來不論是偶數或是奇數長度的字串，在加入這個沒有出現過的字元之後，都會變成奇數長度的回文了！</p>
<p>定義 $z[i]$ 為以 $s[i]$ 為中心，最長的回文長度LPS（如果字元i是自己回文，定義Z[i] = 0]）。以字串abba來說就是以下情況：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>編號</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>原字串</td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>變更後</td>
<td>.</td>
<td>a</td>
<td>.</td>
<td>b</td>
<td>.</td>
<td>b</td>
<td>.</td>
<td>a</td>
<td>. </td>
</tr>
<tr>
<td>Z函數</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>跟Z Alogrithm 一樣，維護一個右界最遠的區間 $[l,r]$，作為在算 $z[i]$ 時能使用到的 $z[0:i-1]$ 的最大值，令他為 $r$。取j滿足 $j+z[j]$ 有最大值，分成以下兩個條件做討論：</p>
<p><strong>1. r &lt; i</strong><br>這種情況就表示不能用之前算的東西去更新現在的值，因此只能暴力枚舉 $s[i]$ 的左右兩側，看最長回文的長度為何。</p>
<p><strong>2. r &gt; i</strong><br>分成三種情況討論（比z algorithm多了一個），首先因為 $r &gt; i$，右界覆蓋了 $i$，表示我們可以從 $j$ 的另外一端映射出與 $s[i]$ 相同的 $s[i’]$（以 $j$ 為中心回文呈現兩側對稱），映射的索引值為 $2j-i$，如下圖：</p>
<p><img src="https://i.imgur.com/Pf1S21i.png" alt=""></p>
<p>因為 $z[i’]$ 已經計算過了，因此可以將 $r-i$ 以及 $z[i’]$ 的大小分成三種情況討論：</p>
<ul>
<li><p>$z[i’] &lt; r-i$<br>這種情況表示 $z[i’]$ 無法繼續往右邊更新，因為 $i$ 與 $i’$ 都是在以 $j$ 為中心的回文中，兩邊是一樣的，代表 $z[i] = z[i’]$ 且不可能再被更新成更大的範圍。</p>
</li>
<li><p>$z[i’] = r-i$<br>這種情況下是要枚舉的，從兩側映射的關係知道 $z[i]$ 的長度至少為 $r-i-1$，因此將 $z[i]$ 設為 $r-i$ 繼續枚舉就可以了！</p>
</li>
<li><p>$z[i’] &gt; r-i$<br>由下圖觀察發現，$z[i]$ 不可能比 $r-i$ 還要大，直接將值設為 $r-i$ 即可。<br><img src="https://i.imgur.com/zsb6blx.png" alt=""></p>
</li>
</ul>
<h4 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>觀察到while迴圈執行的狀況，只有當 $r &lt; i$ 以及 $z[i’] = r-i$ 時右界才有被更新的可能，兩種情況都會讓右界 $r$ 遞增，範圍最大到 $n$ ，因為不會減小的關係，總時間複雜度為線性的 $O(n)$！</p>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Longest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(T);m = <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(S,<span class="string">&#x27;.&#x27;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)S[<span class="number">2</span>*i+<span class="number">1</span>] = T[i];    <span class="comment">//間隔插入沒出現過字元</span></span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">1</span>;                               <span class="comment">//計算時使用右開區間</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;                        <span class="comment">//維護最大右界左右界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[<span class="number">2</span>*l-i],r-i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i-Z[i]&gt;=<span class="number">0</span> &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="後綴數組"><a href="#後綴數組" class="headerlink" title="後綴數組"></a>後綴數組</h3><p>一些基本定義，我們定義 $suf[i]$ 是字串 $S$ 從 $i$ 開始的後綴，也就是 $S[i:n-1]$。將一個字串所有的後綴取出來按照字典序進行排序，就是<strong>後綴數組</strong>。總共有三個複雜度：$O(n^2\log n)$、$O(n\log^2 n)$、$O(n\log n)$ 分別是使用暴力、倍增、基數排序的優化。</p>
<h4 id="暴力解-O-N-2-log-n"><a href="#暴力解-O-N-2-log-n" class="headerlink" title="暴力解 $O(N^2\log n)$"></a>暴力解 $O(N^2\log n)$</h4><p>$O(n)$ 的字串比對，排序 $O(n\log n)$，因此時間複雜度為 $O(n^2\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">10</span>] = <span class="string">&quot;algorithm&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(S+a,S+b) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> SA[<span class="number">10</span>];</span><br><span class="line">    n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)SA[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(SA,SA+n,cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cout&lt;&lt;SA[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="倍增-Quick-Sort"><a href="#倍增-Quick-Sort" class="headerlink" title="倍增+Quick Sort"></a>倍增+Quick Sort</h4><p>使用倍增可以讓複雜度做到 $O(n\log^2 n)$，其原理主要是讓比較的時間併入排序，同時多做 $O(\log n)$ 層的排序。定義 $sa[i]$ 為將後綴排序後第 $i$ 小的後綴編號；$rk[i]$ 表示後綴 $i$ 的排名。</p>
<p>倍增顧名思義，跟將數量乘上兩倍有關，因此會帶一個log。下圖就是一個排序的示例，首先按這字典序初始每一個字元的排名 $rk[i]$，進行 $O(\log n)$ 層，每一層用 $O(n\log n)$ 的時間進行排序。倍增讓原本的字串比較 $O(n)$ 降到 $O(\log n)$ 。</p>
<p>接下來的每一層的每一個字元 $s[i]$，在比較大小的時候，將 $rk[i]$ 以及 $rk[i+k]$ 組成一個 $pair$ 進行排序，從第一層開始，每一層的 $k$ 都會增加為2倍（倍增的概念）。pair的first就好比倍增時前 $s[i:i+k]$ 的排名、second就是 $s[i+k+1:i+2k]$ 的排名，搭配字典序是按照由前到後進行排名，比完fisrt才會比second，如此一來我們可以利用倍增的性質，也就是已經排名好的較短長度的字串，直接利用排好的名次進行下一輪的排序，這就導致我們不需要對每一個字元都看過一遍！</p>
<p><img src="https://i.imgur.com/l1aGK8f.png" alt=""><br><a href="https://oi-wiki.org/string/sa/">圖片出處</a>圖中的黑線岔開距離都會因為每一層而越岔越開（乘上2倍），也就是「倍增」所代表的意義！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);<span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;                <span class="comment">//進行O(lgn)次</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)            <span class="comment">//倍增pair的second</span></span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搭配-Radix-Sort"><a href="#搭配-Radix-Sort" class="headerlink" title="搭配 Radix Sort"></a>搭配 Radix Sort</h4><p>基數排序 (Raddix sort) 以及計數排序 (Counting sort) 兩者是有點從屬的關係，計數排序是基數排序的子程序，也就是說基數排序是透過對每一位進行計數排序完成的！</p>
<p>首先，我們需要 $O(n)$ 的空間進行每一輪的計數排序，對每一個元素進行排名（從1到n-1），如此一來才能確保不會有溢位的問題。先對第二個關鍵字進行排序，排完之後再按照第一個關鍵字排序。Raddix Sort 是穩定的，相同元素為在前面在排序之後一定會在前面。</p>
<p>有幾個地方有實作上進行基數排序的限制，首先第一輪會按照個別字母的字典序進行排序，用快排等基於比較的排序方法可以順利完成，但可惜基數排序不行，一定要乖乖的按照 1 到 n-1 順序進行排名。因此在第一輪會先使用 $std::sort$ 排名，之後進行raddix_sort！</p>
<p>最後一個小小的地方，就是當第二個 key 的值為 -1的情況（倍增超出範圍），在比較時可以直接push進去答案裡面，因為並沒有一個box的index 是-1，同時他們也是最小，丟進去即可。</p>
<p><strong>時間複雜度：</strong> 每一層進行 $O(n)$ 排序，因為倍增共有 $O(\log n)$ 層，因此總時間複雜度為 $O(n)\times O(\log n) = O(n\log n)$！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raddix_sort</span><span class="params">(vector&lt;pt&gt; &amp;cur)</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i].y == <span class="number">-1</span>)temp.<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">        <span class="keyword">else</span> box[cur[i].y].<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)box[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        box[temp[i].x].<span class="built_in">push_back</span>(temp[i]);</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])cur.<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最長共同前綴-LCP-Kasai’s-Algorithm"><a href="#最長共同前綴-LCP-Kasai’s-Algorithm" class="headerlink" title="最長共同前綴 LCP (Kasai’s Algorithm)"></a>最長共同前綴 LCP (Kasai’s Algorithm)</h3><p>最長共同前綴，以現在字串演算法中，假設 $lcp(i,j)$ 為後綴 $i$ 與 $j$ 的最長共同前綴。在<a href="https://www.geeksforgeeks.org/%C2%AD%C2%ADkasais-algorithm-for-construction-of-lcp-array-from-suffix-array/">這篇文章</a>中給出這個定義：</p>
<blockquote>
<p>A value lcp[i] indicates length of the longest common prefix of the suffixes inexed by suffix[i] and suffix[i+1]</p>
</blockquote>
<p>定義 $lcp[i]$ 為後綴 $i$ 與後綴 $i+1$ 的最長共同前綴，其中 $lcp[n-1]$ 沒有定義。再複習一下，$rk[i]$ 為第 $i$ 個後綴數組的排名$rk[i]$、$sa[i]$ 為排名為 $i$ 的字串所對應到的從 $sa[i]$ 開始的後綴數組。</p>
<p>到底我們要求的LCP是什麼？如果只是給兩個字串要求出共同最長前綴，那我們只要 $O(min(L_A,L_B))$ 就好，是可以接受的複雜度。但Kasai’s Algorithm不是要求這個。一般都在講到後綴字串之後講到LCP，為的就是要求出所有的後綴數組中，任兩個字串的共同最長前綴為何。以一個字串長度為 $l$ 來說，後綴的配對數量共有 $O(l^2)$ 組，暴力肯定會TLE。</p>
<p>求出 $lcs$ 需要有兩個引理：</p>
<ul>
<li><strong>第一個引理</strong><script type="math/tex; mode=display">lcp[rk[i]] ≥ lcp[rk[i-1]]-1</script>其中 $i$ 為<strong>尚未經過排序</strong>的從 $i$ 開始的後綴字串。</li>
</ul>
<p><strong>說明：</strong> 將後綴數組排序之後有點像將相似的字串排在一起（按字典序由小排到大），鄰近的字串其實代表著一個意義，兩者相似程度越高。因此 $lcp[rk[i-1]]$ 某種意義代表著與 $i-1$ 開始的後綴數組（簡稱後綴 $i-1$）跟其他字串最大的共同前綴長度。</p>
<p>接著我們看 $lcp[rk[i]]$ ，後綴 $i$ 就是後綴 $i-1$ 刪掉一個前綴字元的結果。我們假設跟後綴 $i-1$ 相近的那個字串叫做 $T$ （其實就是後綴 $rk[i-1]+1$），把 $T$ 刪除一個前綴字元之後所形成的字串（也就是比 $T$ 再短一字元的後綴）也就可以跟後綴 $i$ 進行匹配，其長度因為被刪掉一個前綴字元所以少一，因此得到了以上式子。</p>
<p>聽說很難證明，不過至少可以情感上的接受這件事是對的！</p>
<ul>
<li><strong>第二個引理</strong><script type="math/tex; mode=display">lcp(S_i,S-j) = min_{i≤k<j}(S_k,S_{k+1})</script></li>
</ul>
<p>為什麼可以算出最近的排名的LCP即可得到最長的LCP？從這個定理可以看出來，對於後綴 $i$ 以及後綴 $j$ ，取 $min$ 的原因是要確保所有的中間後綴 $k$ 都包含了下界 $k$ ，也就是說每個在 $i$ 與 $j$ 中間的人都至少跟前一個人相同個字元。</p>
<hr>
<p>以下以字串 $aabaabc$ 作為範例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>後綴</th>
<th>RK</th>
<th style="text-align:left">String</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td style="text-align:left">aabaabc</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td style="text-align:left">abaabc</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td style="text-align:left">baabc</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td style="text-align:left">aabc</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td style="text-align:left">abc</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td style="text-align:left">bc</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td style="text-align:left">c</td>
</tr>
</tbody>
</table>
</div>
<p>以下是SA與對應的String</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>RK</th>
<th>SA</th>
<th>String</th>
<th>LCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>aabaabc</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>aabc</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>abaabc</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>abc</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>baabc</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>bc</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>c</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>以下是找LCP流程：</p>
<ul>
<li>首先從後綴0開始，找到對應的下一個rk，也就是後綴3，得到LCP為3</li>
<li>接下來看後綴1，查表得到RK為2，找到RK為3的找LCP，得到2</li>
<li>看後綴2，與RK為4,5名找LCA，得到1</li>
<li>後綴3，看RK 1,2，LCA為1</li>
<li>接下來以此推累</li>
</ul>
<p>接下來有兩種不同設定方法，端看要採用的是上表還是下表的字串排序方法。我以上表為例，程式執行時印出順序：$3211000$；也可以採用後綴數組排序後的結果（一般都採用此方法），直接對應出順序（對照的是下表）：$3120100$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">LCP</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n,<span class="number">0</span>)</span>,<span class="title">lcp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)rk[sa[i]] = i;      <span class="comment">//利用sa反函數得到rk</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        <span class="keyword">if</span>(rk[i] == n<span class="number">-1</span>)<span class="keyword">continue</span>;   <span class="comment">//rk[n-1]未定義</span></span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]+<span class="number">1</span>];        <span class="comment">//下一名後綴從何開始</span></span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;</span><br><span class="line">        lcp[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>時間複雜度：</strong> 主要觀察 $k$ 的變化，$k$ 最多就是n，最少是0，最差的情況是 $k$ 被減掉 $n$ 次，加上 $2n$ 次，因此複雜度是線性 $O(n)$！</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>字串演算法</category>
      </categories>
      <tags>
        <tag>字串</tag>
        <tag>演算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字串演算法例題</title>
    <url>/2021/09/05/String_problems/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>NEOJ 266 溫力的故事</li>
<li>NEOJ 265 欸迪的字串</li>
<li>NEOJ 267 自動完成系統</li>
<li>NEOJ 264 欸迪的字串</li>
<li>ZJ d518: 文字抄寫 II</li>
<li>TIOJ 1306 字串中的字串</li>
<li>TIOJ 1321 好多回文 ndromePali</li>
<li>ZJ d978: 最长回文字串</li>
<li>TIOJ 1725 Massacre at Camp Happy</li>
<li>TIOJ 1497 喝醉的宿主 The drunk host</li>
<li>TIOJ 1515 Problem E. 似曾相識<span id="more"></span>
</li>
</ul>
<h3 id="NEOJ-266-溫力的故事"><a href="#NEOJ-266-溫力的故事" class="headerlink" title="NEOJ 266 溫力的故事"></a>NEOJ 266 溫力的故事</h3><p><a href="https://neoj.sprout.tw/problem/266/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179031/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你n個字串m筆詢問一個字串，對每一筆詢問輸出詢問在n個字串中出現的次數。</p>
</blockquote>
<p>這一題在<strong>隨機算法</strong>做過，今天用字典樹Trie做一次。在隨機算法中，透過Rolling Hash的公式，對每一個字串生成一個值，利用這個值查詢出現的次數。如果我們用Trie的話，則是建立一棵指標樹，透過走法這一棵字典樹得知詢問字串出現的次數！</p>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span>        <span class="comment">//利用指標建立一棵樹</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];    <span class="comment">//對應a-z每一條邊</span></span><br><span class="line">    <span class="keyword">int</span> cnt;        <span class="comment">//字串出現次數</span></span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">cnt</span>(<span class="number">0</span>)&#123; <span class="comment">//初始設定</span></span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie* root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">char</span> temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;           <span class="comment">//從根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])     <span class="comment">//如果樹上無此字元則new</span></span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*s)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];   <span class="comment">//繼續造訪Trie</span></span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;cnt += <span class="number">1</span>;              <span class="comment">//字串出現次數(字串對應唯一葉節點)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;              <span class="comment">//查找字串s</span></span><br><span class="line">    Trie *ptr = root;           <span class="comment">//根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;                  <span class="comment">//無此字串，回傳次數0</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];</span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;cnt;            <span class="comment">//回傳字串出現次數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">105</span>];cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">105</span>];cin&gt;&gt;s;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">find</span>(s)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NEOJ-265-欸迪的字串"><a href="#NEOJ-265-欸迪的字串" class="headerlink" title="NEOJ 265 欸迪的字串"></a>NEOJ 265 欸迪的字串</h3><p><a href="https://neoj.sprout.tw/problem/265/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179036/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你字串S和字串T，求出S在T中出現的位置</p>
</blockquote>
<p>這一題在<strong>隨機演算法</strong>也有出現過，當時是用Rolling Hash的方式透過扣掉Hash的方法比對字串是否相同（推一下公式就知道）。現在要用的是<strong>KMP演算法</strong>，很複雜不好想。</p>
<p>比較一下隨機跟KMP的時間，下方為KMP，上方則是隨機算法，兩者時間差了將近1倍，雖然兩者都可以在O(|T|)時間內進行匹配，但是建立Rolling Hash的常數是比較大的！<br><img src="https://i.imgur.com/a7CPjyi.png" alt=""></p>
<h4 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">KMP_match</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F,<span class="keyword">char</span> *T)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;            <span class="comment">//回傳匹配相同地方</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;                 <span class="comment">//紀錄短字串有多少被匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)&#123;      <span class="comment">//每一迴圈都讓T[i]被匹配到</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=T[i])</span><br><span class="line">            p = F[p];           <span class="comment">//使T[i]一定可以被匹配到</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == T[i])</span><br><span class="line">            p += <span class="number">1</span>;             <span class="comment">//T的第i個與S的p+1可以匹配</span></span><br><span class="line">        <span class="keyword">if</span>(!S[p+<span class="number">1</span>])&#123;            <span class="comment">//S[p]已經匹配完成</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(i-p); <span class="comment">//回推匹配開頭</span></span><br><span class="line">            p = F[p];           <span class="comment">//繼續下一輪匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(|S|)要配對的字串以及Fail Function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_build</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = F[<span class="number">0</span>] = <span class="number">-1</span>;              <span class="comment">//初始設定為-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;          <span class="comment">//1到接下來字元</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=S[i])</span><br><span class="line">            p = F[p];               <span class="comment">//無法繼續配對，尋找更短字串</span></span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == S[i])          <span class="comment">//配對成功(如都沒有一樣的就-1)</span></span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        F[i] = p;                   <span class="comment">//設定F[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">char</span> S[N],T[N];     <span class="comment">//詢問短字串、長在串</span></span><br><span class="line">    <span class="keyword">int</span> F[N];           <span class="comment">//失敗函數</span></span><br><span class="line">    cin&gt;&gt;S&gt;&gt;T;</span><br><span class="line">    <span class="built_in">KMP_build</span>(S,F);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">KMP_match</span>(S,F,T);</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,ans.<span class="built_in">size</span>()<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NEOJ-267-自動完成系統"><a href="#NEOJ-267-自動完成系統" class="headerlink" title="NEOJ 267 自動完成系統"></a>NEOJ 267 自動完成系統</h3><p><a href="https://neoj.sprout.tw/problem/267/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179148/">Submission</a></p>
<blockquote>
<p>題目敘述<br><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2015/round-1/problems/B">點這裡</a>有FB Hacker Cup的原題連結，簡單來說就是想像手機的自動填入系統，每加入一個字串會記錄到資料庫中，當資料庫裡面沒有相同前綴的字串時就輸出前綴長度。</p>
</blockquote>
<p>用字典樹Trie插入每一個字串，插入過程中返回從頭到開始new新的節點之間經過的節點樹，代表需要輸入多少個字元才能觸發自動完成系統。這一題是基礎的Trie應用。</p>
<h4 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie *root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(*S)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f)step++;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*S)])&#123;</span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*S)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*S)];</span><br><span class="line">        S++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Trie *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;c[i])&#123;</span><br><span class="line">            <span class="built_in">clear</span>(s-&gt;c[i]);</span><br><span class="line">            <span class="keyword">delete</span> s-&gt;c[i];</span><br><span class="line">            s-&gt;c[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;S;</span><br><span class="line">            step +=<span class="built_in">insert</span>(S);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;step&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NEOJ-264-欸迪的字串"><a href="#NEOJ-264-欸迪的字串" class="headerlink" title="NEOJ 264 欸迪的字串"></a>NEOJ 264 欸迪的字串</h3><p><a href="https://neoj.sprout.tw/problem/264/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/179060/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你字串S，求一個最短字串T的長度，滿足經由複製若干次後接起來會是字串S。</p>
</blockquote>
<p>這一題在一開始看到感覺好難，不過在慢慢理解 Z_Algorithm 之後，在講義中發現到這個問題也可以用這個演算法來解決！因為Z函數是滿足從i開始的最長前綴，因此當 $i$ 為 字串長度 $n$ 的因數的時候，只要 $i+Z[i+1]=n$ 成立，就必定可以用 $S[1:i]$ 組成字串 $S$ 。實作上要注意字串是0-base，i+1就相等於字串第i個位置，處理上要特別注意！</p>
<h4 id="程式碼-3"><a href="#程式碼-3" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *Z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(Z[i-l],r-i));</span><br><span class="line">        <span class="keyword">while</span>(S[Z[i]]&amp;&amp;S[Z[i]] == S[i+Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">char</span> s[N];cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> Z[N],n = <span class="built_in">strlen</span>(s),ans = n;</span><br><span class="line">    <span class="built_in">Z_algo</span>(s,Z);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span> &amp;&amp; i+Z[i]==n)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-d518-文字抄寫-II"><a href="#ZJ-d518-文字抄寫-II" class="headerlink" title="ZJ d518: 文字抄寫 II"></a>ZJ d518: 文字抄寫 II</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d518">題目連結</a></p>
<blockquote>
<p>題目敘述<br>若這個字串之前已經出現過，則輸出的出現號碼，若沒有則輸出它將被編寫的號碼.</p>
</blockquote>
<p>裸題Trie，不過要注意每一次要重置，將所有的實體Delete掉。</p>
<h4 id="程式碼-4"><a href="#程式碼-4" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    Trie* c[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> ind;</span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">ind</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie* root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">char</span> temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Trie *cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;c[i])&#123;</span><br><span class="line">            <span class="built_in">clear</span>(cur-&gt;c[i]);</span><br><span class="line">            <span class="keyword">delete</span>[] cur-&gt;c[i];</span><br><span class="line">            cur-&gt;c[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    Trie *ptr = root;           <span class="comment">//從根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])     <span class="comment">//如果樹上無此字元則new</span></span><br><span class="line">            ptr-&gt;c[<span class="built_in">ch</span>(*s)] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];   <span class="comment">//繼續造訪Trie</span></span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;ind = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;              <span class="comment">//查找字串s</span></span><br><span class="line">    Trie *ptr = root;           <span class="comment">//根節點尋找</span></span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;                  <span class="comment">//無此字串，回傳次數0</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;c[<span class="built_in">ch</span>(*s)])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ptr = ptr-&gt;c[<span class="built_in">ch</span>(*s)];</span><br><span class="line">        s += <span class="number">1</span>;                 <span class="comment">//字串下一個字元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;ind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans,cur_id = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">char</span> s[N];<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">            ans = <span class="built_in">find</span>(s);</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;New! %d\n&quot;</span>,cur_id);</span><br><span class="line">                <span class="built_in">insert</span>(s,cur_id);</span><br><span class="line">                cur_id += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Old! %d\n&quot;</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1306-字串中的字串"><a href="#TIOJ-1306-字串中的字串" class="headerlink" title="TIOJ 1306 字串中的字串"></a>TIOJ 1306 字串中的字串</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1306">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/263572">Submission</a></p>
<blockquote>
<p>題目敘述<br>裸字串匹配。對於每個詢問輸出 $S$ 在 $T$ 中出現過幾次。</p>
</blockquote>
<p>裸KMP字串匹配，統計出現次數。可以嘗試不要看資料自己寫一次，會更了解KMP算法！</p>
<h4 id="程式碼-5"><a href="#程式碼-5" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n,F[N];;</span><br><span class="line"><span class="keyword">char</span> T[N],S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP_match</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">char</span> *T,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=T[i])</span><br><span class="line">            p = F[p];</span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == T[i])</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!S[p+<span class="number">1</span>])&#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            p = F[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_build</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> *F)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = F[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;S[i];i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span> &amp;&amp; S[p+<span class="number">1</span>]!=S[i])</span><br><span class="line">            p = F[p];</span><br><span class="line">        <span class="keyword">if</span>(S[p+<span class="number">1</span>] == S[i])</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        F[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(F));</span><br><span class="line">        cin&gt;&gt;S;</span><br><span class="line">        <span class="built_in">KMP_build</span>(S,F);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">KMP_match</span>(S,T,F)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;T&gt;&gt;n;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1321-好多回文-ndromePali"><a href="#TIOJ-1321-好多回文-ndromePali" class="headerlink" title="TIOJ 1321 好多回文 ndromePali"></a>TIOJ 1321 好多回文 ndromePali</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1321">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/263962">Submission</a></p>
<blockquote>
<p>題目敘述<br>給一個長度 ≤ $10^6$ 的字串 A，問有幾種把該字串的某前綴搬到最後面的方法，使得最後的字串為回文。<br>(提示:可以用類似 Z 函數的概念計算出以某字元為中心的最長回文長度。)</p>
</blockquote>
<p>這一題搞得我快掛了QQQ。為什麼呢？看看以下照片就知道了：</p>
<p><img src="https://i.imgur.com/i8Gx5Yo.png" alt=""></p>
<p>根據上面的「提示」，要用類似Z函數的概念把以某點為中心的最長回文算出來。一個Naive裸的作法，把用 $O(n)$ 枚舉每一個點為分割點，把分割點前面的子字串接到後面，用 $O(n)$ 的時間看是否為一回文字串。如此一來時間複雜度為 $O(n^2)$ ，對這一題來說顯然是不可行的，因為字串長度達到 $10^6$！</p>
<p>當我們用Manacher’s Algorithm $O(n)$ 的時間每一個字元的最大回文之後，就可以枚舉每一個可以作為分割點的地方，檢查回文的狀況。討論分割點在前半部分的情況下，也就是把短的（長度小於一半）前綴搬到後面的狀況。當分割的索引值為 $i$ ，必須保證 $s[0:i]$ 跟 $s[i:2i]$ 對稱，移到字串尾巴才能成為回文。除此之外，也必須滿足 $Z[mid+i] = mid-i$ 的情況，以就是剩下不是分割點兩側的字串必須是回文，把前綴接到後面之後才能對稱！</p>
<p>實作上很多細節，我DEBUG超久最後才想到不能枚舉所有字元，會出事（就像上面的三色WA），只要枚舉以 $’.’$ 為分割點的情況（分割在字元上就不行），還有很多細節，WA很多次才會知道XD</p>
<h4 id="程式碼-6"><a href="#程式碼-6" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,Z[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">2</span>*N],T[N];</span><br><span class="line"><span class="comment">//T原字串、S插入點字串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Longest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(T);m = <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(S,<span class="string">&#x27;.&#x27;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)S[<span class="number">2</span>*i+<span class="number">1</span>] = T[i];</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[<span class="number">2</span>*l-i],r-i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i-Z[i]&gt;=<span class="number">0</span> &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="built_in">Longest</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)Z[i]--;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (m<span class="number">-1</span>)/<span class="number">2</span>,i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Z[mid] == mid)ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;mid;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[i] == i &amp;&amp; Z[mid+i] == mid-i)&#123;</span><br><span class="line">            ans[(i/<span class="number">2</span>)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;m;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z[i] == m-i<span class="number">-1</span> &amp;&amp; Z[i-mid] == i-mid)&#123;</span><br><span class="line">            ans[(i/<span class="number">2</span>)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(ans[i])sum++;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;none&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(ans[i])cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-d978-最长回文字串"><a href="#ZJ-d978-最长回文字串" class="headerlink" title="ZJ d978: 最长回文字串"></a>ZJ d978: 最长回文字串</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d978">題目連結</a></p>
<blockquote>
<p>題目敘述<br>題目即題意，給你一個字串，求出最長的回文字串長度為何？</p>
</blockquote>
<p>一題LPS的裸題，用Manacher’s Algorithm可以將時間複雜度做到 $O(n)$！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,Z[<span class="number">2</span>*N],t;</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">2</span>*N],T[N];</span><br><span class="line"><span class="comment">//T原字串、S插入點字串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Longest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(T);m = <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(S,<span class="string">&#x27;.&#x27;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)S[<span class="number">2</span>*i+<span class="number">1</span>] = T[i];</span><br><span class="line">    Z[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(Z[<span class="number">2</span>*l-i],r-i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i-Z[i]&gt;=<span class="number">0</span> &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;</span><br><span class="line">            l = i;r = i+Z[i];</span><br><span class="line">            Z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;T;</span><br><span class="line">        <span class="built_in">Longest</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> z = (Z[i]<span class="number">-1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,z);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1725-Massacre-at-Camp-Happy"><a href="#TIOJ-1725-Massacre-at-Camp-Happy" class="headerlink" title="TIOJ 1725 Massacre at Camp Happy"></a>TIOJ 1725 Massacre at Camp Happy</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1725">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/264017">Submission</a></p>
<blockquote>
<p>題目敘述：<br>定義字串 A 和 B「k-幾乎相同」代表把字串 A 的前 k 字元搬到最後面時，與 B 恰有一個字元相異。給你兩個長度 ≤ $10^6$ 的字串 A 和 B，求所有使 A 和 B「k-幾乎相同」成立的 k 值。</p>
</blockquote>
<p>這一題好特別，一樣要用 $O(n)$ 的時間求出答案，對於每一個操作將前k個字元搬到後面，只能用 $O(1)$ 算出來到底符不符合一字元相異的條件。<br>以兩個相等長度的字串 $A,B$ 為例，長度為 $l$，假設 $A=aabba,B = aacba$，兩者相差一個字元的情況下，必定會滿足$l = LCP(A,B)+LCP(rev(A),rev(B))+1$，其中rev函數表示reverse。</p>
<p>我們要做的就是在 $O(1)$ 的時間內求出LCP，因為題目的字串 $A$ 要求不同的起始位置，因此我們假設一個非常特別的字串 $B@AA$ ，其中@為任意沒出現過的字元。只要計算這一個字串的Z函數，就表示了 $A$ 和 $B$ 的最長共同前綴，需要兩個A的原因是因為模擬不同的k-位移下情形。</p>
<p><img src="https://i.imgur.com/5Ir8Hjt.png" alt=""></p>
<div class="note success">
            <p><strong>實作小細節</strong><br>程式碼的第42行可以試著推推看逆序之後的尾巴的索引值為何。我是利用列出幾個數字之後推出來的，不過應該可以寫成比較嚴謹的數學證明！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Z1[n+<span class="number">1</span>+i]+Z2[<span class="number">2</span>*n-i+<span class="number">1</span>]+<span class="number">1</span> == n</span><br></pre></td></tr></table></figure></p>
          </div>
<h4 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h4><p>$O(n)$ 建立z函數，$O(n)$ 枚舉每一個起始點，總時間為 $O(n)$。</p>
<h4 id="程式碼-7"><a href="#程式碼-7" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,Z1[<span class="number">3</span>*N],Z2[<span class="number">3</span>*N];</span><br><span class="line"><span class="keyword">char</span> A[<span class="number">3</span>*N],B[<span class="number">3</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z_algo</span><span class="params">(<span class="keyword">int</span> *z,<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        z[i] = <span class="built_in">max</span>(<span class="built_in">min</span>(z[i-l],r-i),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(S[i+z[i]] &amp;&amp; S[z[i]] == S[i+z[i]])&#123;</span><br><span class="line">            l = i;r = i+z[i];</span><br><span class="line">            z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    m = <span class="number">3</span>*n+<span class="number">1</span>;</span><br><span class="line">    B[n] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    <span class="comment">//正常序列求Z value</span></span><br><span class="line">    <span class="built_in">rep</span>(i,n+<span class="number">1</span>,<span class="number">2</span>*n)B[i] = A[i-n<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">3</span>*n)B[i] = A[i<span class="number">-2</span>*n<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">Z_algo</span>(Z1,B);</span><br><span class="line">    <span class="comment">//逆序求Z value</span></span><br><span class="line">    <span class="built_in">reverse</span>(B,B+n);<span class="built_in">reverse</span>(B+n+<span class="number">1</span>,B+m);</span><br><span class="line">    <span class="built_in">Z_algo</span>(Z2,B);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Z1[n+<span class="number">1</span>+i]+Z2[<span class="number">2</span>*n-i+<span class="number">1</span>]+<span class="number">1</span> == n)vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TAK&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NIE&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[0,n-1][n,n][n+1,2n][2n+1,3n]</span></span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1497-喝醉的宿主-The-drunk-host"><a href="#TIOJ-1497-喝醉的宿主-The-drunk-host" class="headerlink" title="TIOJ 1497 喝醉的宿主 The drunk host"></a>TIOJ 1497 喝醉的宿主 The drunk host</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1497">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/264189">Submission</a></p>
<blockquote>
<p>題目敘述<br>裸後綴數組。</p>
</blockquote>
<p>後綴數組我看了好久（大概有4天吧），一直對著它發呆，不知道它的精髓到底在哪裡。。剛好又遇到開學，不能整天快樂寫題XD</p>
<h4 id="倍增優化"><a href="#倍增優化" class="headerlink" title="倍增優化"></a>倍增優化</h4><p>對著螢幕發呆的日子終於結束了，直到我看了<a href="https://oi-wiki.org/string/sa/">這一篇</a>（雖然說我前幾天也有看但看不懂，可能是消化的天數不夠多吧），尤其是裡面的一張圖，深刻說明了倍增的精髓。</p>
<p>後綴數組求法就不多解釋（上面有），放幾個實作上的小細節。</p>
<div class="note primary">
            <p><strong>實作小細節</strong><br>我們要求進行 $O(\log n)$ 層的倍增，可以使用C++內建的log10()再用ceil去處理，但顯然有點慢，如果套用以下函數，它會回傳數字二進位之後最大的1前面總共有多少個0（前綴0的數量），與32相減（32是long long的關係）就是我們要的log的次數。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lg = __builtin_clz(n)</span><br></pre></td></tr></table></figure><p>另外一個小小細節，就是在字串的後半部分，如果跟前面一樣倍增一個比較大的數字，有可能會超出範圍，這時候初始值就很重要了！初始設定rk[n] = -1，導致任何只要超出範圍的都會取到這個-1，表示只要後面沒有字串、如果前面都相同但長度比較長的字串比起來，較短的會排在比較前面的位置！</p>
          </div>
<p>這個算法是 $O(n\log^2 n)$，TIOJ這一題可以過，不過到<a href="https://www.spoj.com/problems/SARRAY/">SPOJ</a>就會被卡TLE</p>
<blockquote>
<p>$O(n^2 log(n))$ is expected to score about 20-30. (Naive sorting all suffixes)<br>$O(n log^2(n))$ is expected to score about 40. (OK for most programming contest problems)<br>$O(n log n)$ is expected to score about 60-70. (Use counting sort for small alphabet size)<br>$O(n)$ without tweaks is expected to score about 80-90.<br>$O(n)$ with tweaks is expected to score 100. (This is meant for fun only :)</p>
</blockquote>
<p>越後面就越毒瘤XD</p>
<blockquote>
<p>test 1 - AC (score=0.000000, sig=0, time=0.009123, mem=5372)<br>test 2 - AC (score=0.000000, sig=0, time=0.006427, mem=5508)<br>test 3 - AC (score=0.000000, sig=0, time=0.014975, mem=5468)<br>test 4 - AC (score=0.000000, sig=0, time=0.031332, mem=5536)<br>test 5 - AC (score=0.000000, sig=0, time=0.026948, mem=5456)<br>test 6 - AC (score=0.000000, sig=0, time=0.023113, mem=5396)<br>test 7 - TLE (score=0.000000, sig=0, time=0.210000, mem=7340)<br>test 8 - TLE (score=0.000000, sig=0, time=0.210000, mem=7152)<br>test 9 - AC (score=0.000000, sig=0, time=0.170094, mem=7284)<br>test 10 - AC (score=0.000000, sig=0, time=0.140098, mem=7340)</p>
</blockquote>
<h4 id="程式碼-8"><a href="#程式碼-8" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==b.x &amp;&amp; y==b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一位、第二位比較以及後綴編號</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);</span><br><span class="line">    <span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    string S;<span class="built_in">getline</span>(cin,S);</span><br><span class="line">    <span class="built_in">suffix_array</span>(S);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Radix-Sort-優化"><a href="#Radix-Sort-優化" class="headerlink" title="Radix Sort 優化"></a>Radix Sort 優化</h4><p><a href="https://tioj.ck.tp.edu.tw/submissions/264407">Submission</a></p>
<p>比較一下 $O(n\log^2 n)$ 以及 $O(n\log n)$ 的時間，兩者花了近兩倍的時間差距。看了一下這一題的TopCoder，竟然可以做到十位數毫秒！如果要繼續優化成線性 $O(n)$ 的複雜度，就會使用到 DC3 的演算法，雖然好像很複雜不實用QQ</p>
<p><img src="https://i.imgur.com/tQph2uA.png" alt=""></p>
<p><img src="https://i.imgur.com/1wcKazZ.png" alt=""></p>
<p><img src="https://i.imgur.com/i4WSvw8.png" alt=""></p>
<p>使用 $O(n\log^2n)$ 的算法會TLE第八、九筆測資，不過使用基數排序就可以AC了！</p>
<blockquote>
<p>test 1 - AC (score=0.000000, sig=0, time=0.006565, mem=6048)<br>test 2 - AC (score=0.000000, sig=0, time=0.006594, mem=6300)<br>test 3 - AC (score=0.000000, sig=0, time=0.012431, mem=7860)<br>test 4 - AC (score=0.000000, sig=0, time=0.012267, mem=7208)<br>test 5 - AC (score=0.000000, sig=0, time=0.011158, mem=6804)<br>test 6 - AC (score=0.000000, sig=0, time=0.012057, mem=7892)<br>test 7 - AC (score=0.000000, sig=0, time=0.140876, mem=17720)<br>test 8 - AC (score=0.000000, sig=0, time=0.077631, mem=21952)<br>test 9 - AC (score=0.000000, sig=0, time=0.074905, mem=21340)<br>test 10 - AC (score=0.000000, sig=0, time=0.076732, mem=30160)</p>
</blockquote>
<h4 id="程式碼-9"><a href="#程式碼-9" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==b.x &amp;&amp; y==b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一位、第二位比較以及後綴編號</span></span><br><span class="line">vector&lt;pt&gt; temp,box[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)box[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raddix_sort</span><span class="params">(vector&lt;pt&gt; &amp;cur)</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i].y == <span class="number">-1</span>)temp.<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">        <span class="keyword">else</span> box[cur[i].y].<span class="built_in">push_back</span>(cur[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)box[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        box[temp[i].x].<span class="built_in">push_back</span>(temp[i]);</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : box[i])cur.<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);<span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        rk[cur[i].id] = (cur[i]==cur[i<span class="number">-1</span>])?rk[cur[i<span class="number">-1</span>].id]:i;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;rk[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;                <span class="comment">//進行O(lgn)次</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">raddix_sort</span>(cur);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)            <span class="comment">//倍增pair的second</span></span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">raddix_sort</span>(cur);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    string S;<span class="built_in">getline</span>(cin,S);</span><br><span class="line">    <span class="built_in">suffix_array</span>(S);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1515-Problem-E-似曾相識"><a href="#TIOJ-1515-Problem-E-似曾相識" class="headerlink" title="TIOJ 1515 Problem E. 似曾相識"></a>TIOJ 1515 Problem E. 似曾相識</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1515">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/264483">Submission</a></p>
<blockquote>
<p>題目敘述<br>裸後綴數組 LCP。</p>
</blockquote>
<p>這題我想好久，一直想不通轉移的條件以及k-1的原因，不過最後還是想通了！這一題只要把 $lcp$ 求出來之後，找最大值就是題目要求的答案。</p>
<h4 id="程式碼-10"><a href="#程式碼-10" class="headerlink" title="程式碼"></a>程式碼</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==b.x &amp;&amp; y==b.y)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一位、第二位比較以及後綴編號</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_array</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lg = <span class="number">32</span>-__builtin_clz(n);</span><br><span class="line">    <span class="comment">//回傳第一個1之前0的個數（二進位）</span></span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">cur</span><span class="params">(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cur[i] = &#123;S[i],<span class="number">0</span>,i&#125;;</span><br><span class="line">    <span class="built_in">rep</span>(p,<span class="number">0</span>,lg)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span> &lt;&lt; p;         <span class="comment">//現在倍增的大小</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">        rk[cur[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">            rk[cur[i].id] = (cur[i<span class="number">-1</span>]==cur[i] ? rk[cur[i<span class="number">-1</span>].id]:i);</span><br><span class="line">            <span class="comment">//設定rk，與前一個相同則設定跟前一個一樣</span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur[i] = &#123;rk[i],rk[<span class="built_in">min</span>(n,i+k)],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(cur),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)sa[i] = cur[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">LCP</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rk</span><span class="params">(n,<span class="number">0</span>)</span>,<span class="title">lcp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)rk[sa[i]] = i;      <span class="comment">//利用sa反函數得到rk</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)k--;</span><br><span class="line">        <span class="keyword">if</span>(rk[i] == n<span class="number">-1</span>)<span class="keyword">continue</span>;   <span class="comment">//rk[n-1]未定義</span></span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i]+<span class="number">1</span>];        <span class="comment">//下一名後綴從何開始</span></span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;</span><br><span class="line">        lcp[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;cin.<span class="built_in">ignore</span>();</span><br><span class="line">    string S;<span class="built_in">getline</span>(cin,S);</span><br><span class="line">    <span class="built_in">suffix_array</span>(S);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; lcp = <span class="built_in">LCP</span>(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)ans = <span class="built_in">max</span>(lcp[i],ans);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>字串演算法跟最短路徑、計算幾何比起來，數學推導成分就多了很多，有許多的遞迴概念，例如失敗函數以及z函數的概念，也有很多是要理解在不同條件下做什麼事，以及其他優化處理。最初的是字典樹Trie，就是一些資料結構的運用；接下來的KMP、Z Algorithm以及LPS就很吃觀念，追蹤整個程式的過程。最後是後綴數組，在這邊卡了超久，遲遲無法理解倍增的概念、以及LCP的作法。可能這就是頓悟吧，每天看了同篇解說很久之後，總有一天會突然頓悟，想到演算法的精髓！</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>字串演算法</category>
      </categories>
      <tags>
        <tag>字串</tag>
        <tag>演算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2020資訊之芽—最短路徑例題</title>
    <url>/2021/08/16/Shortest_Path_problem/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>可魚果運輸問題</li>
<li>百慕達三角洲</li>
<li>江神與他的小火車</li>
<li>貨物運送計劃</li>
<li>E.漢米頓的麻煩</li>
<li>旅遊規劃問題</li>
<li>Codeforces 543B: Destroying Roads<span id="more"></span>
</li>
</ul>
<h3 id="可魚果運輸問題"><a href="#可魚果運輸問題" class="headerlink" title="可魚果運輸問題"></a>可魚果運輸問題</h3><p><a href="https://neoj.sprout.tw/problem/391/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178079/">Dijkstra’s Algorithm</a><br><a href="https://neoj.sprout.tw/challenge/178078/">SPFA</a><br>這一題的來源是NPSC2013的題目，題目大意如下：</p>
<blockquote>
<p>有n個城市m個運輸方案，每個方案 $P_i$ 會從一個固定的起始城市 $A_i$ 運送東西到另一個固定的終點城市 $B_i$，每運輸一件物品，就必須付 $C_i$ 價錢。若用方案 $P_i$ 運輸了超過 $D_i$ 件物品，多出來的部份每件物品收 $C_i’$ 元。共要運輸 $f$ 物品。<br>求起點 $s$ 到終點 $e$ 的最短路徑。</p>
</blockquote>
<p>當運輸總量超過 $D_i$ 件物品，表示可以使用更小的邊權重去計算接下來的費用。這時候我們可以了解到一個性質，如果我把全部的物品全部集中在一條路徑運送，因為送的越多，相對的在費用上就可能產生優惠，比分散多條路徑的運送花費來的小。因為總共要運送 $f$ 件物品，因此會將邊的權重設定為當 $f$ 件物品都經過這一條邊時，所要花費的價格。</p>
<p>有了邊以及價格之後，便可開始進行最短路徑的演算法。因為題目範圍 $N≤100$ ，因此用Dijkstra’s 或是 SPFA 都可以做（Bellman-Ford就先不要XD）。</p>
<h4 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h4><p>這篇有<a href="http://www-m3.ma.tum.de/foswiki/pub/MN0506/WebHome/dijkstra.pdf">一篇論文</a>是Dijkstra在針對最短路徑寫的論文（也就是以他名字命名的演算法論文），這篇只有三頁耶！<br>以下是「演算法導論」這本書中演算法的虛擬碼：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">  1  INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">  2    S &lt;- Ø</span><br><span class="line">  3    Q &lt;- V[G]</span><br><span class="line">  4    while Q ≠ Ø</span><br><span class="line">  5        do u &lt;- EXTRACT-MIN(Q)</span><br><span class="line">  6            S &lt;- S ∪ &#123;u&#125;</span><br><span class="line">  7            for each vertex v ∈ Adj[u]</span><br><span class="line">  8                do RELAX(u,v,w)</span><br></pre></td></tr></table></figure><br>其中集合 $S$ 在程式碼中代表的是visit，而集合 $Q$ 因為要操作取出最小元素的動作，因此會用priority_queue實現，以heap來進行 $O(\log n)$ 的插入以及取出。</p>
<p>這裡面使用$visit$判斷是否在集合 $S$ 中，但我們可以發現，如果在priority_queue中有兩個點的存在，第一個點處理完被加入集合 $S$ 中之後，第二次再次被拿出來進行處理時就不會有任何相鄰的點再一次被處理，這是因為第一次與第二次更新所使用的 $dis[cur]$ 是一樣的。因此，當一個點已經在visit中（也就是在集合 $s$ 中），我們可以直接換下一個點去執行（不過如果忘了visit也是沒差啦）。</p>
<div class="note default">
            <p><strong>複雜度分析</strong></p><p>以下分析一下演算法時間複雜度，總共有兩個時間複雜度，取決於使用何種資料結構來實作。</p><p><strong>1. 時間複雜度 $O(V^2+E)$</strong><br>首先是每一個點執行 $V$ 次對每一個相鄰的點進行更新，每一輪執行 $O(V)$ 尋找目前距離 $dis$ 最小的點。總共有 $E$ 條邊需要更新，因此最後要把 $E$ 再加上去。這樣總複雜度就會 $V\times O(V)+O(E) = O(V^2+E)$。此實作方式一般在稠密的圖中會有比較好的表現。<br><br></p><p><strong>2. 時間複雜度 $O((V+E)\log V)$</strong><br>這一題在 $O(n)$ 爆搜尋找改用heap去優化，因此複雜度就會是一樣執行V 輪利用 $O(logV)$ 找到距離 $dis$ 最小的點，同時將更新後的點放進heap中，我們知道放入heap的複雜度也是 $O(\log n)$，因此複雜度就會變成 $O(V\log V)+O(E\log V) = O((V+E)\log V)$。此實作方式一般在稀疏的圖中會有比較好的表現，從 $V$ 與 $E$ 的大小估計可以大致發現。</p>
          </div>
<p>以下是程式法的實作，最需要注意的地方是pair的first跟second儲存的東西。在存圖時會使用（點,權重）搭配vector；而在priority_queue中，因為要對權重進行比較，因此會用（權重,點），需要特別注意別搞混了!</p>
<div class="note success">
            <p><strong>Priority_Queue實作細節</strong></p><p>預設的priority_queue會pop出目前heap中最大的元素（預設是less&lt;&gt;函數），如果要實作一個min heap 的話要使用greater&lt;&gt;函數，同時第二個傳進函數的參數要用一個vector！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;Type, vector&lt;Type&gt;, ComparisonType &gt; min_heap;</span><br><span class="line">priority_queue &lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;   </span><br></pre></td></tr></table></figure>
          </div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pii&gt; edge[N];                <span class="comment">//存圖</span></span><br><span class="line">    <span class="keyword">int</span> n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dis[N];<span class="built_in">fill</span>(dis,dis+N,<span class="number">1e16</span>);</span><br><span class="line">    <span class="keyword">bool</span> visit[N];                     <span class="comment">//城市數n、方案數m、s起、e終、f箱數</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;</span><br><span class="line">        <span class="comment">//一條由a連到b的邊，權重c，流量超過d，則改權重c</span></span><br><span class="line">        <span class="keyword">int</span> val = (f&gt;d?c*d+e*(f-d):c*f);</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Dijkstra</span></span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;    <span class="comment">//(距離,點)</span></span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visit[cur])<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first,weight = i.second;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dis[cur]+weight&lt;dis[next])&#123;</span><br><span class="line">                dis[next] = dis[cur]+weight;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[next],next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[e]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Shortest-Path-Faster-Algorithm-SPFA"><a href="#Shortest-Path-Faster-Algorithm-SPFA" class="headerlink" title="Shortest Path Faster Algorithm(SPFA)"></a>Shortest Path Faster Algorithm(SPFA)</h4><p>這是一個使用queue最佳化的Bellman-Ford演算法，基本的使用方式跟BFS幾乎相同，在Bellman-Ford對邊進行更有效率的鬆弛(relaxation)。<br>以下一樣是「演算法導論」中Bellman-Ford的虛擬碼：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BELLMAN-FORD(G,w,s)</span><br><span class="line">  1    INITIALIZE-SINGLE-SOURCE(G,s)</span><br><span class="line">  2    for i &lt;- 1 to |V[G]|-1</span><br><span class="line">  3        do for each edge (u,v)∈ E[G]</span><br><span class="line">  4            do RELAX(u,v,w)</span><br><span class="line">  5    for each edge (u,v)∈ E[G]</span><br><span class="line">  6        do if d[v] &gt; d[u]+w(u,v)</span><br><span class="line">  7            then return FALSE</span><br><span class="line">  8    return TRUE</span><br></pre></td></tr></table></figure><br>以下是SPFA的虛擬碼，如果節點有被實際鬆弛過，且節點不在queue中（同樣元素在queue中出現兩次沒有意義，因為只要確保有在queue中等會會被更新到就好，到它的最短距離不會被改變），便將此節點推入queue中。裡面存的是帶進行鬆弛的節點們，也就是被剛剛更新過的節點。我們可以利用$visit[ ]$來 $O(1)$ 判斷節點是否有在queue中！</p>
<p>有進行判斷是否在queue中的（比較省空間一點）：<br><img src="https://i.imgur.com/vdtJWR2.png" alt=""><br>沒有進行判斷的，有被更新過就塞進去：<br><img src="https://i.imgur.com/fsorAoE.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shortest-Path-Faster-Algorithm(G, s)</span><br><span class="line">  1    for each vertex v ≠ s in V(G)</span><br><span class="line">  2        d(v) := ∞</span><br><span class="line">  3    d(s) := 0</span><br><span class="line">  4    offer s into Q</span><br><span class="line">  5    while Q is not empty</span><br><span class="line">  6        u := poll Q</span><br><span class="line">  7        for each edge (u, v) in E(G)</span><br><span class="line">  8            if d(u) + w(u, v) &lt; d(v) then</span><br><span class="line">  9                d(v) := d(u) + w(u, v)</span><br><span class="line"> 10                if v is not in Q then</span><br><span class="line"> 11                    offer v into Q</span><br></pre></td></tr></table></figure>
<p>SPFA有一個問題，他可以被出題目的人設計測資去卡這種算法，使時間複雜度變成糟糕的$O(V^2)$，因此一般來說會實作Dijkstra而非SPFA！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pii&gt; edge[N];                <span class="comment">//存圖</span></span><br><span class="line">    <span class="keyword">int</span> n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dis[N];<span class="built_in">fill</span>(dis,dis+N,<span class="number">1e16</span>);</span><br><span class="line">    <span class="keyword">bool</span> visit[N];                     <span class="comment">//城市數n、方案數m、s起、e終、f箱數</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;</span><br><span class="line">        <span class="comment">//一條由a連到b的邊，權重c，流量超過d，則改權重c</span></span><br><span class="line">        <span class="keyword">int</span> val = (f&gt;d?c*d+e*(f-d):c*f);</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SPFA</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    visit[s] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        visit[cur] = <span class="number">0</span>;                <span class="comment">//pop出來將狀態改成不在queue中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first,weight = i.second;</span><br><span class="line">            <span class="keyword">if</span>(dis[next] &gt; dis[cur]+weight)&#123;</span><br><span class="line">                dis[next] = dis[cur]+weight;</span><br><span class="line">                <span class="keyword">if</span>(!visit[next])que.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[e]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="百慕達三角洲"><a href="#百慕達三角洲" class="headerlink" title="百慕達三角洲"></a>百慕達三角洲</h3><p><a href="https://neoj.sprout.tw/problem/393/">題目連結</a></p>
<blockquote>
<p>題目大意：<br>給定一張長n寬m的矩形圖，由”#”和”.”組成，給定起點$(x_1,y_1)$以及終點$(x_2,y_2)$，必須最小化經過”.”的次數，求最少需幾過幾次。</p>
</blockquote>
<p>當下看到這一個題目的想法，就是跟處理一般的圖論題目一樣，將邊用vector儲存起來，將經過”.”的權重設為很大的一個數字，這樣用Dijkstra做一次最短路徑就可以找出經過”.”最小化的次數了！</p>
<p>以下是MLE的<a href="https://neoj.sprout.tw/challenge/178136/">Submission</a><br><img src="https://i.imgur.com/9ZaisdZ.png" alt=""><br>吃了開心的MLE，如果當成一般的圖在處理，不管是在 $dis$ 開long long的處裡，或是開了一個vector陣列儲存邊，都非常的消耗空間。因此，我詢問了一下電神這一題的想法，他說我的想法用Dijkstra是正確的，不過在設定邊權的部分可以直接用0跟1代替，而且可以用queue去輔助實作BFS（要說它也可以是Dijkstra的另一種比較簡單的版本）。</p>
<p><img src="https://i.imgur.com/9JldAha.png" alt=""></p>
<p>這題也就是所謂<a href="https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/">0-1 BFS (Shortest Path in a Binary Weight Graph)</a>，或是<a href="https://codeforces.com/blog/entry/22276">這裡0-1 BFS</a>，想法可以說是Dijkstra跟BFS的綜合（其實它跟SPFA也很相似）。以下是實作步驟：</p>
<ol>
<li>建立雙向的佇列(deque)，等等要存放被relax過的點，初始放入起點</li>
<li>每一次從deque前方pop出一點，對那一點相鄰的所有點進行鬆弛</li>
<li>如果被鬆弛時的邊權重為0，將點push dequeue的前方</li>
<li>否則當鬆弛時的邊權重為1，將點push dequeue的後方</li>
<li>重複執行2-4步驟直到deque為空</li>
</ol>
<p>當我們一直利用deque最前端的元素進行鬆弛，因為我們將邊權為0的元素放入最前端，用距離最小的那些點進行鬆弛，每一個點最多會被鬆弛一次，因此總時間複雜度為$O(V+E)$，比起用Dijktra直接做$O((V+E)\log V)$快了許多（此演算法之所以正確是因為其中一邊的權重是0，不管0接到誰他的權重也都是0，有點像「從最小層逐漸擴展」的概念）！</p>
<div class="note success">
            <p>小問題（出處<a href="https://codeforces.com/blog/entry/22276">這裡</a>）</p><ol><li>Can we apply the same trick if our edge weights can only be 0 and x (x &gt;= 0) ?</li><li>Can we apply the same trick if our edge weights are x and x+1 (x &gt;= 0) ?</li><li>Can we apply the same trick if our edge weights are x and y (x,y &gt;= 0) ?</li></ol><p>解答YES,NO,NO</p>
          </div>
<p>這題之所以可行是因為有一邊的權重是0，當點皆以權重為0串再一起時，他會是最短的，使用最短去更新接下來的點，因此第一題是正確的！但第二題與第三題是錯誤的，考慮以下點與邊的情況：</p>
<p><img src="https://i.imgur.com/BYojGwm.jpg" alt=""></p>
<p>當我依照01BFS的方法不斷去用x更新其他的點，更新完之後會發現點1到點3的最短路徑應該是x+1，到時候又要再重新Relax一次，複雜度會爆炸喔（比SPFA可能還慘，因為當點三利用兩個x更新完之後，用它來做跟3所有相鄰的點，做完卻發現$(1,3)$有更短的距離，又必須重新全部更新一次！）總結來說，他只是用於只有兩種邊的情況，且其中一邊必須為0。</p>
<p><img src="https://i.imgur.com/wnXKbI8.png" alt=""></p>
<div class="note info">
            <p><strong>比較一下記憶體用量</strong><br>最主要還是時間複雜度的比較，不過既然空間已經爆了，時間也沒法比了QQ</p><p><strong>MLE</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N2 4000005</span></span><br><span class="line"><span class="keyword">int</span> n,m,q,predecessor[N2],dis[N2];</span><br><span class="line"><span class="keyword">bool</span> visit[N2],maze[N2];</span><br><span class="line">vector&lt;pii&gt;edge[N2];</span><br></pre></td></tr></table></figure><p><strong>AC</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2003</span></span><br><span class="line"><span class="keyword">int</span> n,m,dis[N][N];</span><br><span class="line"><span class="keyword">bool</span> visit[N][N],maze[N][N];</span><br></pre></td></tr></table></figure></p>
          </div>
<p>以下是使用deque實作01BFS的AC code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,dis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[N][N],maze[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&#x27;.&#x27;</span>)maze[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> maze[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;pii&gt;deq;</span><br><span class="line">    <span class="keyword">int</span> s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s1][s2] = <span class="number">0</span>;</span><br><span class="line">    deq.<span class="built_in">push_back</span>(&#123;s1,s2&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = deq.<span class="built_in">front</span>().first,y = deq.<span class="built_in">front</span>().second;</span><br><span class="line">        deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dis[nx][ny] &gt; dis[x][y]+maze[nx][ny])&#123;</span><br><span class="line">                dis[nx][ny] = dis[x][y]+maze[nx][ny];</span><br><span class="line">                <span class="keyword">if</span>(maze[nx][ny]==<span class="number">0</span>)deq.<span class="built_in">push_front</span>(&#123;nx,ny&#125;);</span><br><span class="line">                <span class="keyword">else</span> deq.<span class="built_in">push_back</span>(&#123;nx,ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[e1][e2]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="江神與他的小火車"><a href="#江神與他的小火車" class="headerlink" title="江神與他的小火車"></a>江神與他的小火車</h3><p><a href="https://neoj.sprout.tw/problem/431/">題目連結</a></p>
<blockquote>
<p>題目大意<br>已知有N個點以及M條邊，總共有Q筆詢問，每筆詢問有$\delta(a,b)$，表示新增一條由 $a$ 指向 $b$ 的邊（其權重為1），對每一筆詢問輸出從點 $1$ 到點 $N$ 的最短距離。</p>
</blockquote>
<p><img src="https://i.imgur.com/f96GUmd.jpg" alt=""></p>
<p>我們知道如果有用新加進來的邊 $\delta(a,b)$，則路徑可以被拆解成 $\delta(1,a)+\delta(a,b)+\delta(b,n)$。其中，我們可以用Dijkstra 一次尋找1到任何點的最短距離，那要如何處理路徑 $\delta(b,n)$ 呢？這就是<strong>單一目的最短距離問題</strong>，我們可以將所有的邊逆序，將終點做一次Dijkstra尋找最短路，這時候我們就可以用 $O(1)$ 的時間回答每一筆詢問，總時間複雜度：預處理$O((V+E)\log V)$，詢問 $O(Q)$。</p>
<div class="note info">
            <p><strong>測資小問題</strong><br>有一筆測資如下，藍線是給定的路徑與權重，紅色是新加入的邊，如果按照上面 $\delta(1,a)+\delta(a,b)+\delta(b,n)$ 我們可以計算出從起點到終點的最短距離為：$2+1+4 = 7$，很明顯兩點之間的最短距離是 $5$ ，但因為原本作法會經過一條$\delta (B,C)$ 的重邊，造成算出來的距離是比較大的！這時候我們只要對最短路徑長度取min即可，也就是說在這種情況加入這一條邊並不會影響最短路徑的長度！</p><blockquote><p>測資（1,2,3分別對應A,B,C）：<br>6 5 1<br>1 2 1<br>2 3 1<br>3 4 1<br>4 5 1<br>5 6 1<br>3 2</p></blockquote><p><img src="https://i.imgur.com/Uocw0hc.png" alt=""></p>
          </div>
<p>接下來是程式碼，之後如果遇到最短路徑的題目，一般來說會避免使用SPFA（除非有負邊），為了要避免最糟的時間複雜度，因此會使用Dijkstra來處理最短路徑問題！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;pii&gt; edge[<span class="number">2</span>][N];</span><br><span class="line"><span class="comment">//edge[0]-&gt;normal,edge[1]-&gt;opposite</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">bool</span> is_nor)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n+<span class="number">2</span>,<span class="number">1e16</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    </span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visit[cur])<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : edge[is_nor][cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first,weight = i.second;</span><br><span class="line">            <span class="keyword">if</span>(dis[next] &gt; dis[cur] + weight)&#123;</span><br><span class="line">                dis[next] = dis[cur] + weight;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[next],next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edge[<span class="number">0</span>][a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">        edge[<span class="number">1</span>][b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; normal,opposite;</span><br><span class="line">    normal = <span class="built_in">Dijkstra</span>(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    opposite = <span class="built_in">Dijkstra</span>(n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(normal[a]+opposite[b]+<span class="number">1</span>,normal[n])&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="貨物運送計劃"><a href="#貨物運送計劃" class="headerlink" title="貨物運送計劃"></a>貨物運送計劃</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1641">題目連結</a></p>
<blockquote>
<p>題目敘述<br>給定N個點M條邊，第i條邊有方邊率$C_i$，假設目前運送貨物重量p經過此邊，代表經過邊i會需要多增加 $p\times C_i$ 的重量。給定起點、終點，求到達終點時最少的貨物重量為多少。</p>
</blockquote>
<p>換種說法，題目要求的是每經過一條邊，就要乘上某一個數，要求到終點最小的重量。下圖是題目範例測資：<br><img src="https://i.imgur.com/BSNWgh8.png" alt=""></p>
<p>$\delta(1,2)\to\delta(2,3)$，所付出的代價是$(1\times (1+1))\times (2+1)=6$。如果是$\delta(1,3)$ 的話直接$1\times (4+1)=5$，可以觀察到，遇到邊就需要將原本的數字乘上$C_i+1$。</p>
<p>我們可以透過將邊權取 $\log$ 之後，就可以利用Dijkstra進行最短路徑的計算，因為取 $\log$ 後的加減運算等同於原本的乘法運算，只要最後把算出來的答案次方即可！</p>
<p>這一題的輸出要求科學記號（為了要避免浮點數誤差），以下程式碼來達成（要求小數點後兩位，同時次方部分要求整數3位）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2fe+%03lld\n&quot;</span>,<span class="built_in">pow</span>(<span class="number">10</span>,ans),x);</span><br></pre></td></tr></table></figure><br>程式碼的部分，透過$edge$存完所有的取完 $\log$ 之後的邊，進行Dijkstra，輸出最短路徑（以科學記號表示）即可！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">double</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;pid&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;<span class="keyword">double</span> c;<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lf&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,(<span class="keyword">double</span>)<span class="built_in">log10</span>(c+<span class="number">1</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis+n+<span class="number">2</span>,<span class="number">1e16</span>);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pdi,vector&lt;pdi&gt;,greater&lt;pdi&gt;&gt; pq;</span><br><span class="line">    dis[s] = <span class="number">0.0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visit[cur])<span class="keyword">continue</span>;</span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[cur])&#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first;</span><br><span class="line">            <span class="keyword">double</span> w = i.second;</span><br><span class="line">            <span class="keyword">if</span>(dis[next] &gt; dis[cur]+w)&#123;</span><br><span class="line">                dis[next] = dis[cur]+w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[next],next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = dis[t];</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">floor</span>(ans);</span><br><span class="line">    ans-=x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2fe+%03lld\n&quot;</span>,<span class="built_in">pow</span>(<span class="number">10</span>,ans),x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="E-漢米頓的麻煩"><a href="#E-漢米頓的麻煩" class="headerlink" title="E.漢米頓的麻煩"></a>E.漢米頓的麻煩</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1096">題目連結</a></p>
<p>他題目時不時提到漢米頓，是多愛漢米頓XDD（這一題跟漢米頓根本沒關係）</p>
<blockquote>
<p>題目大意<br>在一張n(n≤100)個點的圖中，尋找路徑長度最短的環</p>
</blockquote>
<p>那就用<strong>Floyd-Warshall</strong>找最小的環就好！</p>
<div class="note info">
            <p><strong>Floyd-Warshall</strong><br>這就是dp的作法，用 $O(N^3)$ 的時間進行轉移，就能得到全點對的最短路徑。這邊有一個重要的轉移順序，也就是中點-起點-終點進行轉移，如果把dp展開就會發現中點必須在最外層進行轉移：</p><blockquote><p>定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路徑，則轉移式變成：</p><script type="math/tex; mode=display">d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])</script></blockquote><p>每一個k+1都是由k轉移而來，仰賴k的點的配對，因此必須最先轉移中點k的部分！（不過順序顛倒也不會怎樣啦，上面「課程內容」的地方有寫到）</p>
          </div>
<p>同樣這一份code也可以判斷有沒有負環，只要ans小於0的話代表有負環（有的話距離是不能用的喔，因為Floyd-Warshall不能處理負環，但負邊是可以處理的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="number">0</span>)dp[i][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,dp[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == INT_MAX)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旅遊規劃問題"><a href="#旅遊規劃問題" class="headerlink" title="旅遊規劃問題"></a>旅遊規劃問題</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1028">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262198">Submission</a><br>這一題 $n≤13$ 大概就是位元dp來完成（狀態壓縮），定義 $dp[i][j]$ 為現在在點i上，拜訪過點集j的最短距離（j中不包含點i）。這裡使用到了同層轉移的技巧，也就是利用j中的點，對相同狀態下不在i中的點進行更新。</p>
<p>點集j中在狀態i下為起點，用Dijkstra對不在i中的其他點進行更新，最後的答案即為$dp[s][S-(1&lt;&lt;s)]$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">vector&lt;pii&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> dis[N],dp[N][<span class="number">1</span>&lt;&lt;N],pre[N][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="comment">//定義dp[i][j]為現在在點i，拜訪過點集合j（i不在點集j中）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m)&#123;                                 <span class="comment">//讀入m條邊</span></span><br><span class="line">        <span class="keyword">int</span> a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> S = <span class="number">0</span>,start = <span class="number">-1</span>;cin&gt;&gt;m;                <span class="comment">//S為待拜訪的所有點集合</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;cin&gt;&gt;temp;</span><br><span class="line">        S = S|(<span class="number">1</span>&lt;&lt;temp);</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">-1</span>)start = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)<span class="built_in">rep</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n))dp[i][j] = INF;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n)dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == (S &amp; i))&#123;                       <span class="comment">//在集合i中的點在S一定要有</span></span><br><span class="line">            priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">            <span class="built_in">fill</span>(dis,dis+n,INF);                <span class="comment">//將dis初始為無限大，做Dijkstra</span></span><br><span class="line">            <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;                   <span class="comment">//從有在i中的點向不在的點做Dijkstra</span></span><br><span class="line">                    dis[j] = dp[j][i^(<span class="number">1</span>&lt;&lt;j)];   <span class="comment">//目前在j，經過拜訪了點集i（不包含點j）</span></span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;dis[j],j&#125;);        <span class="comment">//利用在i中的點對其他點進行更新</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = pq.<span class="built_in">top</span>().second;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                visit[cur] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> k : edge[cur])&#123;</span><br><span class="line">                    <span class="keyword">int</span> v = k.first,w = k.second;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;v))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dis[v] &gt; dis[cur]+w)&#123;</span><br><span class="line">                        dis[v] = dis[cur] + w;</span><br><span class="line">                        pre[v][i] = cur;        <span class="comment">//紀錄點v在狀態i下由cur轉移</span></span><br><span class="line">                        pq.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dis[v] == dis[cur]+w &amp;&amp; pre[v][i] &gt; cur)&#123;</span><br><span class="line">                        pre[v][i] = cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;               <span class="comment">//對於不在點集i中的點進行更新</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))<span class="keyword">continue</span>;</span><br><span class="line">                dp[j][i] = dis[j];              <span class="comment">//同層狀態轉移，更新dp[j][i]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Minimum travel distance: &quot;</span>&lt;&lt;dp[start][S^(start)]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Travel route:&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = start;S = S^(<span class="number">1</span>&lt;&lt;start);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cur;</span><br><span class="line">        <span class="keyword">if</span>(!S)<span class="keyword">break</span>;</span><br><span class="line">        cur = pre[cur][S];</span><br><span class="line">        <span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;cur))S = (S^(<span class="number">1</span>&lt;&lt;cur));         <span class="comment">//經過的點不一定是指定的觀光點</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Codeforces-543B-Destroying-Roads"><a href="#Codeforces-543B-Destroying-Roads" class="headerlink" title="Codeforces 543B: Destroying Roads"></a>Codeforces 543B: Destroying Roads</h3><p><a href="https://codeforces.com/problemset/problem/543/B">題目連結</a><br><a href="https://codeforces.com/problemset/submission/543/125743532">Submission</a></p>
<blockquote>
<p>題目大意<br>給定N個點M條無向邊，每一邊權重都是1，以及兩筆資料，由三個數$(x,y,w)$ 構成，代表起點為x、終點為x、要在w距離內從起點走到終點。試問最多可以拔掉幾條邊同時滿足以上兩個資料所描述的特性？</p>
</blockquote>
<p>這一題蠻有趣的，首先他的邊權重都是1，因此我們可以直接用BFS尋找最短路徑，並且點第一次拜訪到時的就是該點的最短距離（BFS一層一層擴展）。</p>
<div class="note primary">
            <p><strong>第一個想法：錯誤想法</strong><br>我先將兩個起點與終點的最短路徑都找出來，把將過的邊都標上不能移除，將其他的邊全部拔掉。</p><p><strong>問題點：</strong><br>固然找到的是最短路徑，但不代表可以最大化拔除邊的數量。因為題目要求兩點只要符合最短距離 $w$ 即可，因此每一個配對其實不用符合是最短路徑的情況（如下圖）！目標是在題目要求的限度內最大化重複的邊，使能夠被拔除的邊最大化！</p><p><img src="https://i.imgur.com/QfbfF82.png" alt=""></p><p>上圖紅色線段是$\delta(1,7)$的最短路徑、褐色是線段$\delta(3,6)$的最短路徑、黑色線段是皆以最短路徑之下可以被拔除的邊。但是如果將路徑$\delta(3,6)$換成是$(3,2)\to(2,4)\to(4,5)\to(5,6)$，被拔除的邊可以增過為三條。</p>
          </div>
<p>這一題最重要的關鍵就是以$O(V^2)$枚舉所有點對（距離長度可以直接換算成邊的數量），可以先用$O(V(V+E)$的時間對每一個點用進行BFS，如此一來總複雜度即為$O(V^2+VE)$，所幸題目給定總共的邊數不會超過3000條，因此是可以在時間限制內完成枚舉。</p>
<div class="note primary">
            <p>枚舉路徑 $\delta(i,j)$ 為共同邊的時候，必須考慮起點與終點的方向，同時考慮從 $i\to j$ 以及從 $j\to i$ 兩個方向。以下圖為例，當枚舉都使用相同的起點以及終點，會讓下圖的 $(3,4)$ 被重複計算！</p><p><img src="https://i.imgur.com/tjq8oe7.png" alt=""></p>
          </div>
<p>以下是AC程式碼：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,n) for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid pair<span class="meta-string">&lt;int,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,s1,e1,w1,s2,e2,w2,dis[N][N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;e1&gt;&gt;w1&gt;&gt;s2&gt;&gt;e2&gt;&gt;w2;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">        que.<span class="built_in">push</span>(i);</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:edge[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit[j])<span class="keyword">continue</span>;</span><br><span class="line">                dis[i][j] = dis[i][cur]+<span class="number">1</span>;</span><br><span class="line">                visit[j] = <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[s1][e1]&gt;w1||dis[s2][e2]&gt;w2)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = dis[s1][e1]+dis[s2][e2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n^2)枚舉所有共同邊</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[s2][i]+dis[i][j]+dis[j][e2]&lt;=w2)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[s2][i]+dis[j][e2]);</span><br><span class="line">            <span class="keyword">if</span>(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[e2][i]+dis[i][j]+dis[j][s2]&lt;=w2)</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[e2][i]+dis[j][s2]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m-ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TIOJ-2180-勇者冒險-Adventure"><a href="#TIOJ-2180-勇者冒險-Adventure" class="headerlink" title="TIOJ 2180 勇者冒險 (Adventure)"></a>TIOJ 2180 勇者冒險 (Adventure)</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/2180">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262669">Submission</a></p>
<blockquote>
<p>題目敘述<br>給定一個地圖共 $R\times C$ 行，接著會有 $M$ 行每一行都有一個座標和等級，代表經過這個座標需要多少等級才能通過。問從特定起點到終點所需要的最低的等級為多少。</p>
</blockquote>
<p>這題蠻特別的，他用到了Dijkstra中每一次都找最小的去更新，同時因為要求的是路徑上最大的等級為何，因此也用到了類似BFS的手法去擴展每一個座標。</p>
<p>因為題目保證至少會有一條路徑通往起點與終點，同時我們每一次從queue拿出來的都是目前等級最低的點，因此如果碰到終點就可以確定這一條路線一定是需要等級最小的一條路徑！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,row,col,mp[N][N],dis[N][N];</span><br><span class="line"><span class="keyword">int</span> s1,s2,e1,e2;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Dijkstra</span></span><br><span class="line">    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;</span><br><span class="line">    dis[s1][s2] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,&#123;s1,s2&#125;&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> rr = pq.<span class="built_in">top</span>().y.x,cc = pq.<span class="built_in">top</span>().y.y;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx = rr+dx[i],ny = cc+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;=row||ny&gt;=col)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx == e1 &amp;&amp; ny == e2)&#123;</span><br><span class="line">                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp[nx][ny] == <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[nx][ny])<span class="keyword">continue</span>;</span><br><span class="line">            dis[nx][ny] = <span class="built_in">max</span>(dis[rr][cc],mp[nx][ny]);</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);</span><br><span class="line">            visit[nx][ny] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        mp[a][b] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小花費的航空之旅"><a href="#最小花費的航空之旅" class="headerlink" title="最小花費的航空之旅"></a>最小花費的航空之旅</h3><blockquote>
<p>題目敘述：<br>給定很多種連接城市間的聯票，要求從起始站搭乘，可以在中途任意站下車，但下車以後就不能再次上車。輸入的第一行為一個正整數 n (1 ≤ n ≤ 20)，即聯票的種類數。以下 n 行每航為一個聯票的資訊，其中第一個整數為聯票的價格，然後是聯票上城市的數目。</p>
<p>接下來為一個行程單的資訊，其中第一個正整數為行程單上的城市數目k（包括起始城市，2 ≤ k ≤ 10），以及這些城市的編號（按順序列出）。</p>
<p>輸出最小花費和對應的方案的其中一組解。</p>
</blockquote>
<p>這一題是APCS Class的其中一題，難度頗高，因為他要找最短的路徑，同時增加了可以在任意站下車的條件。首先我們要維護每一個聯票的資訊，它的價值、起點、編號以及經過的城市。接著，我們考慮所有從起點出發的聯票，將每一種聯票上的每一個經過的城市都加入queue中。</p>
<p>跟上一題一樣，當我們每一次都從cost最小的點下手，在轉移的過程中如果將所有的點都走訪一遍，則他的路徑必定是最短的，因為每一次的更新都是從花費最小的路徑去轉移。</p>
<div class="note primary">
            <p><strong>使用自定義比較函數放入Priority_queue中</strong></p><p>Priority_queue中的比較函數需要使用到struct或class包覆的比較函數，若要回傳cost的最小值，則必須以大於來寫（有點像預設是pop出最大值，使用的卻是less<int>的比較函數）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          </div>
<p>以下是AC Code：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrep(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pif pair<span class="meta-string">&lt;int,float&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,visit[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ticket</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,cost;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next_city;</span><br><span class="line">    <span class="comment">//陣列ticket[i]存以i為起點</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Ticket&gt; ticket[<span class="number">30</span>];          <span class="comment">//ticket[i] 起點為i的聯票</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cost,cur_pos,visit_pos;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; used_ticket;</span><br><span class="line">    <span class="comment">//cur_pos現在所在位置、visit_pos在行程單上位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//讓priority_queue可以pop出最小的cost的路徑</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,num<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k;cin&gt;&gt;k;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        ticket[s].<span class="built_in">push_back</span>(&#123;i,cost,temp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k)cin&gt;&gt;visit[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : ticket[visit[<span class="number">1</span>]])&#123;         <span class="comment">//行程第一個起點的聯票起點</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i.next_city)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p &lt; k &amp;&amp; j == visit[p+<span class="number">1</span>])p++;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;一開始聯票：&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.visit_pos == k)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Cost = &quot;</span>&lt;&lt;cur.cost&lt;&lt;<span class="string">&quot;, Tickets used: &quot;</span></span><br><span class="line">                &lt;&lt;cur.used_ticket[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cur.used_ticket.<span class="built_in">size</span>();i++)</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;cur.used_ticket[i];</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ticket[cur.cur_pos])&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(cur.used_ticket)</span></span>;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(i.id);                <span class="comment">//將現在使用的第i聯票推入</span></span><br><span class="line">            <span class="keyword">int</span> p = cur.visit_pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : i.next_city)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p &lt; k &amp;&amp; j == visit[p+<span class="number">1</span>])p++;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;cur.cost+i.cost,j,p,vec&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>最短路徑</category>
      </categories>
      <tags>
        <tag>2020資訊之芽</tag>
        <tag>2021暑期筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>計算幾何例題</title>
    <url>/2021/08/22/Geomertry_problem/</url>
    <content><![CDATA[<h2 id="題目目錄"><a href="#題目目錄" class="headerlink" title="題目目錄"></a>題目目錄</h2><ul>
<li>向量加法</li>
<li>等長線段對</li>
<li>向左轉向右轉</li>
<li>線段相交</li>
<li>最小凸多邊形</li>
<li>TIOJ 1178 Convex Hull</li>
<li>來吧，遊戲開始了</li>
<li>遊戲：最終回</li>
<li>TIOJ 1205 直角三角形<span id="more"></span></li>
<li>TIOJ 1105 H.PS3</li>
<li>ZJ b288: 夏季大三角</li>
<li>TIOJ 1500 Clean up on aisle 3</li>
<li>ZJ a871: Museum Area</li>
<li>TIOJ 1280 領土 (Territory)</li>
<li>TIOJ 1678 剪多邊形（molding）</li>
<li>ZJ d269: 11579 - Triangle Trouble</li>
</ul>
<h3 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h3><p><a href="https://neoj.sprout.tw/problem/398/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178462/">Submission</a></p>
<blockquote>
<p>題目敘述：<br>給你n個數字（0≤i&lt;1，小數點精度到末九位），想知道到底有多少組 $(i,j,k)$ 滿足 $v_i+v_j=v_k$，其中 $i,j,k$ 可以重複。</p>
</blockquote>
<p>這題其實跟計算幾何沒什麼關係，直接用unordered_map去做（有點像two sum，不過下面的code好像也不用開到multi），簡單！不過我在浮點數的地方吃了一些WA，最後算了直接改用字串處理這個惱人的東西XD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep2(i,l,r) for(int i=l;i&lt;r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps (1e-9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">rep2</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        string s;cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>,times = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            num += (s[i]-<span class="string">&#x27;0&#x27;</span>)*times;</span><br><span class="line">            times/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_multimap&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        mp.<span class="built_in">insert</span>(&#123;vec[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            ans += mp.<span class="built_in">count</span>(vec[i] + vec[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等長線段對"><a href="#等長線段對" class="headerlink" title="等長線段對"></a>等長線段對</h3><p><a href="https://neoj.sprout.tw/problem/399/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178471/">Submission</a></p>
<blockquote>
<p>題目敘述：<br>給定平面上很多個點，求出有幾對線段等長（輸入有重複的點）。</p>
</blockquote>
<p>既然n≤500，那就直接枚舉吧，沒啥特別難度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a,i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep2(i,a,b) for(int i=a;i&lt;b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(pii a,pii b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a.x-b.x,y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> x*x+y*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep2</span>(i,<span class="number">0</span>,n)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> dis = <span class="built_in">dist</span>(p[i],p[j]);</span><br><span class="line">            mp[dis]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = i.second;</span><br><span class="line">        ans+=((cnt*(cnt<span class="number">-1</span>))/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向左轉向右轉"><a href="#向左轉向右轉" class="headerlink" title="向左轉向右轉"></a>向左轉向右轉</h3><p><a href="https://neoj.sprout.tw/problem/400/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178524/">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你平面上n個點，依序走訪每一個點，試問走訪過程中共執行幾次的左轉、右轉以及迴轉。</p>
</blockquote>
<p>很特別，計算幾何讓電腦可以處理平常我們所看到的平面圖形，可以利用向量內積、外積等方式判斷方向。這一題最重要的就是<strong>方向函數</strong>。傳入3個點$(A,B,O)$，方向函數會會回傳$\stackrel\longrightarrow{OA}\times \stackrel\longrightarrow{OB}$ 的正負數值。</p>
<p>下圖為外積$\stackrel\longrightarrow{OA}\times \stackrel\longrightarrow{OB}$ 的結果，當 $\sin\theta$的結果為負，也就是下圖的情況，從B走到A就需要往左邊走；反之亦然。<br><img src="https://i.imgur.com/eDNRLhm.png" alt=""></p>
<p>至於如何判斷當兩個向量的方向呈現一直線時，也就是外積回傳的值為0時（$\sin\theta = 0$），應該是同向還是異向呢？這時候就需要搭配向量內積（這我想了很久），因為內積公式是$A\cdot B = |A||B|\cos\theta$，將兩個向量內積之後就可以很明確的判斷到底是朝原本的方向走，還是反方向的行走！</p>
<div class="note info">
            <p><strong>內積、外積公式</strong><br>有一點數學，不過蠻有趣的。可以利用$\sin$與$\cos$達到計算角度的目的，利用兩者不同的值域，互相搭配，就可以更輕鬆的進行判斷！注意到外積的正負就代表著A到B是順時針或是逆時鐘。</p><script type="math/tex; mode=display">A\cdot B = |A||B|\cos\theta = A_xB_x+A_yB_y\\A\times B = |A||B|\sin\theta = A_xB_y-A_yB_x</script><p><br></p><p><strong>方向函數</strong></p><p>當我們要判斷方向的時候，會利用正弦函數，逆時針正、順時針為負進行判斷！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意到此時在判斷是否為平行的時候（cross==0），使用到$fabs()$這個函數，目的是為了避免誤差而導致判斷錯誤，因此需要進行誤差的處理（其實不用也沒差啦，只是這樣嚴謹一點）</p>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pt&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    a.<span class="built_in">resize</span>(n+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>,left = <span class="number">0</span>,turn = <span class="number">0</span>;</span><br><span class="line">    pt pre = a[<span class="number">1</span>],from = a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ori = <span class="built_in">dir</span>(a[i],from,pre);</span><br><span class="line">        <span class="keyword">if</span>(ori == <span class="number">1</span>)right+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ori == <span class="number">-1</span>)left+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ori == <span class="number">0</span> &amp;&amp; ((a[i]-from)*(from-pre))&lt;<span class="number">0</span>)turn+=<span class="number">1</span>;</span><br><span class="line">        pre = from;from = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;left&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;right&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;turn&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="線段相交"><a href="#線段相交" class="headerlink" title="線段相交"></a>線段相交</h3><p><a href="https://neoj.sprout.tw/problem/401/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178537/">Submission</a><br>線段相交 = <del>線段香蕉</del>，自動選字永遠都是香蕉，有點煩XDD</p>
<p>如何判斷兩線段是否相交？首先需要一個函數可以判斷點是否在一個線段上，如此一來就可以判斷端點在另一條線段上的特殊情況。以下程式碼為判斷點$P_o$ 是否在 $\overline{P_aP_b}$ 上。利用向量外積可以判斷兩線段是否平行，而使用內積公式可以判斷$P_o$是否在線段中，而非線段的兩側！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;       <span class="comment">//o是否在ab線段上</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);  <span class="comment">//是否平行</span></span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);    <span class="comment">//是否在線段中</span></span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>)&amp;&amp;(dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>說明：由點$P_o$指向a和b的向量必須呈現180度角（也就是異向），才可確保在ab線段中（跟a,b重合也算是跟ab線段相交）。</p>
<p>接下來是主要的部分，首先先確認4個端點是否恰好在另外一條線段上，判斷完之後就是處理一般相交的情況。若線段 $\overline{P_1P_2}$ 與 $\overline{P_3P_4}$ 相交，則點 $P_1$ 與點 $P_2$ 會在線段$\overline{P_3P_4}$ 的異側。用方向函數表示：$dir(a,b,c)\times dir(a,b,d)<0$。確認完兩個線段之後即完成線段相交的判斷！
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(pt a, pt b, pt c, pt d)</span></span>&#123;      <span class="comment">//線段ab是否與cd相交</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c)||<span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點c、d是否洽在線段ab上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a)||<span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//點a、b是否洽在線段cd上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c)*<span class="built_in">dir</span>(a,b,d)==<span class="number">-1</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a)*<span class="built_in">dir</span>(c,d,b)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">//對於線段兩端點看另外兩端點必須方向相反</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由下圖可以得到上面的結論，當兩線段相交時，方向函數得到的值（用外積，也就是下圖 $\theta_1$ 以及 $\theta_2$）的方向），會呈現一正一負，從兩個相反的方向看同一條線段得出來的結論！<br><img src="https://i.imgur.com/b5pW6IS.png" alt=""></p>
<p>AC Code:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pt&gt; point;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir</span><span class="params">(pt a, pt b, pt o)</span> </span>&#123;                         <span class="comment">//方向函數</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(cross) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cross &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onseg</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;                       <span class="comment">//o是否在ab線段上</span></span><br><span class="line">    <span class="keyword">int</span> cross = (a - o) ^ (b - o);                  <span class="comment">//是否平行</span></span><br><span class="line">    <span class="keyword">int</span> dot = (a - o) * (b - o);                    <span class="comment">//是否在線段中</span></span><br><span class="line">    <span class="keyword">return</span> (cross == <span class="number">0</span>)&amp;&amp;(dot &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(pt a, pt b, pt c, pt d)</span></span>&#123;          <span class="comment">//線段ab是否與cd相交</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(a,b,c)||<span class="built_in">onseg</span>(a,b,d))<span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">//點c、d是否洽在線段ab上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">onseg</span>(c,d,a)||<span class="built_in">onseg</span>(c,d,b))<span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">//點a、b是否洽在線段cd上</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dir</span>(a,b,c)*<span class="built_in">dir</span>(a,b,d)==<span class="number">-1</span> &amp;&amp; <span class="built_in">dir</span>(c,d,a)*<span class="built_in">dir</span>(c,d,b)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                                <span class="comment">//對於線段兩端點看另外兩端點必須方向相反</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    point.<span class="built_in">assign</span>(<span class="number">4</span>,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)cin&gt;&gt;point[i].x&gt;&gt;point[i].y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Intersection</span>(point[<span class="number">0</span>],point[<span class="number">1</span>],point[<span class="number">2</span>],point[<span class="number">3</span>]))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TIOJ-1178-Convex-Hull"><a href="#TIOJ-1178-Convex-Hull" class="headerlink" title="TIOJ 1178 Convex Hull"></a>TIOJ 1178 Convex Hull</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1178">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262532">Submission</a></p>
<blockquote>
<p>題目敘述<br>給定n個二維平面的點，找出位在凸包上的所有點的個數</p>
</blockquote>
<p>最小凸多邊形 = 凸包，要找出能包住所有點的最小凸多邊形，簡稱凸包。聽說最好寫的凸包演算法是：Andrew’s Monotone Chain，翻成中文叫做Andrew’s 單調鍊？有一點單調+鍊的味道。下圖是我用照片合成起來的GIF，大致模擬出使用Andrew’s Monotone Chain 找凸包的方法。</p>
<p><img src="https://i.imgur.com/YUOC9xZ.gif" alt=""></p>
<div class="note default">
            <p><strong>Andrew’s Monotone Chain</strong><br>這個演算法的時間複雜度是 $O(n\log n)$，空間複雜度 $O(n)$，資料說它可以解決了凸包有重疊的點、共線的點、退化成線段和點的情況。它的名字叫做「單調鍊」，要維護一個有點像單調隊列的東西，對於在容器中第 $i$ 個位置的點都滿足 $\stackrel\longrightarrow{P<em>i P</em>{i+1}}\times \stackrel\longrightarrow{P<em>{i+1} P</em>{i+2}} &gt; 0$ ，如果有點做外積後的結果小於等於0，則它會被pop掉（這是依照上圖逆時針完成凸包的描述，如果方向相反則會變號）。<br><br></p><p>以下是此演算法的執行步驟：</p><ol><li>先把所有的點按照 $(x,y)$ 排序</li><li>將下凸包圍出來，有點像維護單調隊列，對所有新加入的點i計算點i-2、i-1與i之間的外積，如果不符合情況代表圍不到新加入的點，需要將舊的點pop出來</li><li>將原本已經排序好的點逆序</li><li>再把上凸包由x座標大到小圍出來，將上下合併就是凸包了（必須注意起終點被push的次數問題）！</li></ol>
          </div>
<p>一般會用一個vector儲存在凸包上面的點（不包含在邊上的點，只有位於轉折點的點），在頭尾的部分（x座標最大與最小）需要特別處理，讓每一個點最多近到vector一次。</p>
<div class="note success">
            <p><strong>實作細節</strong><br>以下是確認是否需要將vector中元素pop出來的關鍵，對向量$\stackrel\longrightarrow{OA}\times \stackrel\longrightarrow{OB}$ 做外積的結果，必須排除外積結果為0的情況，如果將0也納入，會造成一個點被push進去很多次，在數量和計算上出現問題。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;         <span class="comment">//這裡很關鍵，別吃WA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除此之外，上凸包在範圍限制上是需要注意的。假設x座標最大的點i，當在圍上凸包的過程中i是不可以被pop出去的，因此vector的大小必須大於下凸包的大小。</p><p>凸包使用第i-1跟第i個點的向量去看第i到第i+1個點的向量，決定一個點要不要被推入vector中。當我們逆序從x座標最大的點往前看時，要確保每一輪結束之後在i點後都必須要有至少一個點，設定hull.size() &gt; down_hull的原因是防止在下凸包的點被圍上凸包的過程更新到。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();    <span class="comment">//圍上凸包的程式碼片段</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">    <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull </span><br><span class="line">        &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">        hull.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
<p>以下是AC Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;                              <span class="comment">//這裡很關鍵，別吃WA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; hull;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;                       <span class="comment">//起點會經過兩次，剛好來算有向面積</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">convex_hull</span>();</span><br><span class="line">    cout&lt;&lt;hull.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小凸多邊形"><a href="#最小凸多邊形" class="headerlink" title="最小凸多邊形"></a>最小凸多邊形</h3><p><a href="https://neoj.sprout.tw/problem/402/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178589/">Submission</a></p>
<blockquote>
<p>題目敘述<br>找出二維平面上n個點的凸包所圍出來的面積為何？</p>
</blockquote>
<p>跟上一題類似，在找到全部在凸包上面的點後，就可以利用<strong>有向面積</strong>把凸包面積算出來，有一個公式可以計算多邊形面積，利用外積得到正負值，轉一圈後得到面積！對於多邊形的頂點 $P<em>0,P_1,…,P</em>{n-1},P_n=P_0$ 的面積如下：</p>
<script type="math/tex; mode=display">Area = \frac{1}{2}\sum_{i=0}^{n-1}\stackrel\longrightarrow{P_i}\times \stackrel\longrightarrow{P_{i+1}}</script><p>其中最後一個點會回到起點，形成一個封閉的迴路。</p>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; hull;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;                       <span class="comment">//起點會經過兩次，剛好來算有向面積</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        vector&lt;pt&gt; hull = <span class="built_in">convex_hull</span>();</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>,len = hull.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">1</span>)&lt;&lt;((ld)area/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="來吧，遊戲開始了。"><a href="#來吧，遊戲開始了。" class="headerlink" title="來吧，遊戲開始了。"></a>來吧，遊戲開始了。</h3><p><a href="https://neoj.sprout.tw/problem/790/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178691/">Submission</a><br><a href="https://www.geogebra.org/graphing/h4fxdquw">GGB模擬</a></p>
<blockquote>
<p>題目敘述<br>給你二維平面上n個點(n≤2400)，每一個點座標皆不相同，求出總共可以圍出多少個三角形？</p>
</blockquote>
<p>這是NEOJ上的加分題，好像是一個題組吧，反正總共有三題，這是第一題。如果 $O(n^3)$ 的枚舉，複雜度會爆炸（量級約$10^{10}$），根據電神的說法，這一題要用極角排序以及雙指標找到共線，接著就可以利用排列組合把因為共線而不能形成三角形的組合扣掉，就是答案了。</p>
<p><img src="https://i.imgur.com/t5TF96I.png" alt=""></p>
<p>這一題的核心概念是找共線，具體來說的作法是枚舉每一個點的同時，以它為原點對其他的點進行排序，如果遇到有相同的極角座標表示這些點共線，同時利用陣列cnt[x]統計共線點數為x的線段總共有幾條。</p>
<p>以下的GIF就是大致上程式執行的樣子。因為一條長度為x的線段會因為枚舉x次的關係，在最後扣掉的情況會重複x次因此需要除掉。</p>
<p><img src="https://i.imgur.com/MVfEx4i.gif" alt=""></p>
<div class="note primary">
            <p><strong>共線與三角形</strong></p><p>一般情況下（任三點不共線），總共可以形成 $C^n_3$ 個三角形，如果有一條m個點共線的情況下（其他點不共線），則可以形成的三角形數量就必須扣除共線限制的情況，變成 $C^n_3-C^m_3$ 個三角形。</p>
          </div>
<p>時間複雜度為：枚舉每一個點 $O(n)$，極角排序 $O(n\log n)$，總時間複雜度 $O(n^2\log n)$</p>
<div class="note default">
            <p><strong>實作小細節</strong></p><p><strong>1. 維護共線連續區間</strong></p><p>我們要想辦法讓有共線的點們所在位置是一個連續的位置。三個點共線可能為在對角線的象限中，也就是點差了180度，如此一來就沒辦法讓共線的點為在連續的區間。為了達到這個目的，我們將所有位於下半平面的點都移到上半平面（在上半平面找到有相同 $\tan\theta$ 值的位置），接著就能利用雙指針找極角座標排序後有相同極角的區間之最大值！</p><p><strong>2. 特例判斷</strong></p><p>如果有一點y座標為0但x座標為負，要將其移到x軸正向的地方，不能把這種情況涵蓋為一般情況，否則原本在x軸正向的點會被移到x軸負向，沒有達到預期的效果。</p>
          </div>
<p>以下是AC Code：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f1 = a &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> f2 = b &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)<span class="keyword">return</span> f1 &lt; f2;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆時針將點進行極角排序，從270度開始逆時針</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用cnt[i]統計區間長度為i的線段數量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(pt id)</span></span>&#123;</span><br><span class="line">    vector&lt;pt&gt; pp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                         <span class="comment">//以id為原點</span></span><br><span class="line">        pt cur = i-id;</span><br><span class="line">        <span class="keyword">if</span>(cur == pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.y &lt; <span class="number">0</span>)&#123;cur.x = -cur.x;cur.y = -cur.y;&#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.x &lt; <span class="number">0</span> &amp;&amp; cur.y==<span class="number">0</span>)&#123;cur.x = -cur.x;&#125;</span><br><span class="line">        pp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(pp),cmp);                      <span class="comment">//將id當作原點進行排序</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,len = pp.<span class="built_in">size</span>();      <span class="comment">//雙指針找共線區間</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt; n<span class="number">-1</span>)&#123;                        <span class="comment">//最大化區間</span></span><br><span class="line">        <span class="keyword">while</span>(p2+<span class="number">1</span> &lt; len &amp;&amp; (pp[p1]^pp[p2+<span class="number">1</span>]) == <span class="number">0</span>)p2++;</span><br><span class="line">        cnt[p2-p1+<span class="number">2</span>]+=<span class="number">1</span>;</span><br><span class="line">        p1 = p2+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    cnt.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)<span class="built_in">solve</span>(p[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = (n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>))/<span class="number">6</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">3</span>,n)ans-=(cnt[i]*(i<span class="number">-1</span>)*(i<span class="number">-2</span>))/<span class="number">6</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="遊戲：最終回"><a href="#遊戲：最終回" class="headerlink" title="遊戲：最終回"></a>遊戲：最終回</h3><p><a href="https://neoj.sprout.tw/problem/792/">題目連結</a><br><a href="https://neoj.sprout.tw/challenge/178786/">Submission</a></p>
<blockquote>
<p>題目敘述<br>共有n個二維平面上的格子點，這些點會形成簡單多邊形。試求或在簡單多邊形內部的格線總長（包括垂直與水平格線）。</p>
</blockquote>
<p>這邊有一個不嚴謹的推導方式，不過他是正確的。令多邊形內部格線長度為S，多邊形的邊落在的格線長度為T，多邊形面積T，則有以下關係式：</p>
<script type="math/tex; mode=display">S = 2A-\frac{T}{2}</script><p>詳細的公式推導可以可以參閱下圖，平行四邊形（斜線部分）內部<strong>垂直</strong>的格線長度為： 大矩形 $(x_1+x_2)(y_1+y_2)$ 扣掉左右上下共四個三角形兩兩拼成一個矩形 $x_1y_1$ 以及 $x_2y_2$，還有左上右下兩個正方形 $2x_2y_1$，整理之後會發現其實跟面積是一樣的。對於垂直部分也是類似的情況。</p>
<p><img src="https://i.imgur.com/wemDPMp.jpg" alt=""></p>
<p>好像隱約發現到面積與格線長度有十分密切的關係，算出面積，把在格線上的邊進行特判扣掉，就可以得到格線長度。</p>
<p>這一題我想了很久，一直看不出來關係式到底長怎樣，直到大神提點才發現原來有這樣的關係，我反應好遲鈍:cry:</p>
<p><img src="https://i.imgur.com/Fy1wSky.png" alt=""></p>
<p>以下是AC Code：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,edge,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        area += (p[i]^p[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(p[i].y == p[i+<span class="number">1</span>].y)edge += <span class="built_in">abs</span>(p[i].x-p[i+<span class="number">1</span>].x);</span><br><span class="line">        <span class="keyword">if</span>(p[i].x == p[i+<span class="number">1</span>].x)edge += <span class="built_in">abs</span>(p[i].y-p[i+<span class="number">1</span>].y);</span><br><span class="line">    &#125;</span><br><span class="line">    area = <span class="built_in">abs</span>(area);</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        p.<span class="built_in">assign</span>(n+<span class="number">1</span>,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        edge = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        ans = <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;ans-((ld)edge/<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TIOJ-1205-直角三角形"><a href="#TIOJ-1205-直角三角形" class="headerlink" title="TIOJ 1205 直角三角形"></a>TIOJ 1205 直角三角形</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1205">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262842">Submission</a></p>
<blockquote>
<p>題目敘述<br>給你N（N≤1500）個座標平面上的點，請問總共可形成多少個直角三角形呢？</p>
</blockquote>
<p>從極角排序後的第一個點開始逆時針進行雙指針的枚舉。這邊使用到一個很特別的手法，對於共線的情況我們先透過預處理的方式將共線的點合併起來，並用cnt[x]陣列紀錄第x個點是由幾個點所合併起來的，如此一來，在進行計算的時候就不會有共線要分別處理的問題（不需擔心是不是可以跟之前的點形成直角三角形，因為相同斜率的點已經被合併剩下一個），直接將數量相乘就可以知道直角三角形的數量！</p>
<p>時間複雜度：枚舉所有點 $O(n)\times$ 進行極角排序$O(n\log n)$ 以及雙指標$O(n)$，總時間複雜度為 $O(n^2\log n)$。</p>
<div class="note info">
            <p><strong>實作小細節</strong></p><p>雙指針進行枚舉的過程中，很有可能會指標指向的索引值會超出範圍。解決的方法有兩種：</p><ol><li>超出了即代表繞了一圈，只需要對索引值取餘數即可。</li><li>除了取餘數的方法之外，其實也可以直接在點集後面將所有點再推入一次，讓角度從360延伸成720度，就不會有超出範圍的問題！</li></ol>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f1 = a &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> f2 = b &lt; pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)<span class="keyword">return</span> f1 &lt; f2;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆時針將點進行極角排序，從270度開始逆時針</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n)枚舉每個點當直角情況</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(pt id)</span></span>&#123;</span><br><span class="line">    pp.<span class="built_in">clear</span>();cnt.<span class="built_in">clear</span>();temp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        pt cur = i - id;</span><br><span class="line">        <span class="keyword">if</span>(cur == pt&#123;<span class="number">0</span>,<span class="number">0</span>&#125;)<span class="keyword">continue</span>;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(temp),cmp);            <span class="comment">//以id為原點進行極角排序</span></span><br><span class="line">    pp.<span class="built_in">push_back</span>(temp[<span class="number">0</span>]);          <span class="comment">//pp每一角度只存至多一個點</span></span><br><span class="line">    cnt.<span class="built_in">push_back</span>(<span class="number">1</span>);               <span class="comment">//考慮每個點共線情況</span></span><br><span class="line">    <span class="keyword">int</span> len = temp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> cross = temp[i]^temp[i<span class="number">-1</span>],dot = temp[i]*temp[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(cross == <span class="number">0</span> &amp;&amp; dot &gt;= <span class="number">0</span>)cnt[cnt.<span class="built_in">size</span>()<span class="number">-1</span>] += <span class="number">1</span>;   <span class="comment">//共線數量+=1</span></span><br><span class="line">        <span class="keyword">else</span> &#123;pp.<span class="built_in">push_back</span>(temp[i]);cnt.<span class="built_in">push_back</span>(<span class="number">1</span>);&#125;      <span class="comment">//非共線設定數量為1</span></span><br><span class="line">    &#125;</span><br><span class="line">    len = pp.<span class="built_in">size</span>();            <span class="comment">//考慮橫跨一周的情況</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)&#123;             <span class="comment">//雙指針i,p1可能會超過一圈</span></span><br><span class="line">        pp.<span class="built_in">push_back</span>(pp[i]);    <span class="comment">//將點再繞一圈</span></span><br><span class="line">        cnt.<span class="built_in">push_back</span>(cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; i+len &amp;&amp; (pp[i]^pp[p1]) &gt;= <span class="number">0</span> &amp;&amp; (pp[i]*pp[p1]) &gt; <span class="number">0</span>)p1 += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//夾銳角的情況要p1+=1</span></span><br><span class="line">        <span class="keyword">if</span>((pp[i]^pp[p1]) &gt; <span class="number">0</span> &amp;&amp; (pp[i]*pp[p1]) == <span class="number">0</span>)ans += cnt[i]*cnt[p1];</span><br><span class="line">        <span class="comment">//正向的直角三角形，若共線則兩者數量相乘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            ans += <span class="built_in">solve</span>(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1105-H-PS3"><a href="#TIOJ-1105-H-PS3" class="headerlink" title="TIOJ 1105 H.PS3"></a>TIOJ 1105 H.PS3</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1105">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262930">Submission $O(n^2)$</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262947">Submission $O(n\log n)$</a></p>
<blockquote>
<p>題目敘述<br>給你平面上N個點（N≤3000），請求出最遠點對的索引值（小的在前、大的在後）</p>
</blockquote>
<p>我做了一份<a href="/hVplrqxCRdGiMkn2lwXGAA">最近點對：不同複雜度之解決方式</a>的筆記，共有四種方法可以解決那個問題，這一題要求的是最遠點對，作法與最近點對其實差蠻遠的。由上幾題知道凸包的求法，因為凸包是可以圍住所有點的多邊形，因此最遠點對也應該在凸包上，而且所在的位置會為在凸包的兩側上（如果不落在凸包上，一定可以把點向兩側延伸到凸包上，且移動過後的點對距離一定比原始的點對距離大）。</p>
<p>找完凸包之後，可以用旋轉卡尺的方式尋找最遠點對。想像兩條平行線中間夾著凸包，逆時鐘旋轉繞行凸包一圈，過程不斷更新最遠點對的距離。在實作上兩條平行線可以被想像成由 $P<em>i$ 指向 $P</em>{i+1}$ 的向量，透過外積三角形面積公式決定卡尺該如何移動。</p>
<script type="math/tex; mode=display">AREA = |\overrightarrow{AB}\times \overrightarrow{AC}|</script><p>以下圖為例，我們要找 $\overline{HM}$ 為底可以形成的最大三角形面積的頂點，因為在同底的情況下面積就代表點與邊的垂直距離，最大的垂直距離意味著這條底邊可以垂直延伸的最遠距離。因為凸包必定是凸多邊形，因此三角形的面積會呈現單峰函數，因此只需要從下一個三角形面積的大小，決定雙指針中比較快的指標的移動情況。</p>
<p><img src="https://i.imgur.com/SXv0gfN.png" alt=""></p>
<p>如果仔細來看，以下圖為例，當前較快的指標指向的位置是 $D$ 點，考慮一條與與 $\overline{HM}$ 平行的直線，若下一個點 $J$ 在平行線段的另外一側，則將指標移往 $J$ 點。可能會有一個疑問，如果比較下圖的線段長度，會發現到 $\overline{DH}$ 的長度比經過 $J$ 點的兩條線段都還要長，那為何還要更新至 $J$ 點？舉這個例子不太好，不過可以想像當旋轉卡尺轉到以 $\overline{FH}$ 為底的時候，會將最遠點對的距離更新成 $\overline{HD}$ 的長度。如果今天 $H$ 的左側又多加了一個新點 $P$，則最遠點對會變成 $\overline{PD}$ 的距離。</p>
<p>簡單來說，最遠點對一定會發生對角的凸包點上面，即使現在以 $\overline{HM}$ 為底最遠點並非 $J$ 而是 $D$ ，但在旋轉卡尺旋轉到 $\overline{FH}$ 時就能將距離更新成 $\overline{HD}$ 的距離。</p>
<p><img src="https://i.imgur.com/6Jeg2U8.png" alt=""></p>
<div class="note success">
            <p><strong>實作小細節</strong></p><p>這一題有點麻煩，因為他要輸出的是最遠點對的索引值，而不是最遠點對之間的距離。在尋找凸包的過程中，會對所有點進行排序，因此原有的索引值順序會被打亂，需要在一開始輸入的時後就好好維護每一個座標的索引值。</p>
          </div>
<p>以下是AC Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,ind;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x*x + y*y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,hull;</span><br><span class="line">pt pt_ans;</span><br><span class="line"><span class="keyword">int</span> n,h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a, pt b, pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa ^ bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa = <span class="built_in">abs</span>((a - c)^(b - c));</span><br><span class="line">    <span class="keyword">int</span> bb = <span class="built_in">abs</span>((a - d)^(b - d));</span><br><span class="line">    <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)<span class="keyword">return</span> a.ind &lt; b.ind;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">stable_sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)<span class="keyword">if</span>(p[i] == p[i+<span class="number">1</span>])p[i+<span class="number">1</span>].ind = p[i].ind;</span><br><span class="line">    hull.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    h = hull.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; sz &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,d = h,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">check2</span>(hull[i],hull[(i+<span class="number">1</span>)%sz],hull[d],hull[(d+<span class="number">1</span>)%sz]))</span><br><span class="line">            d = (d+<span class="number">1</span>)%sz;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; (hull[i]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            ans = (hull[i]-hull[d]).<span class="built_in">dis</span>();</span><br><span class="line">            <span class="keyword">int</span> a = hull[i].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans == (hull[i]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = hull[i].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            <span class="keyword">if</span>(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; (hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            ans = (hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>();</span><br><span class="line">            <span class="keyword">int</span> a = hull[(i+<span class="number">1</span>)%sz].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans == (hull[(i+<span class="number">1</span>)%sz]-hull[d]).<span class="built_in">dis</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = hull[(i+<span class="number">1</span>)%sz].ind,b = hull[d].ind;<span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">            <span class="keyword">if</span>(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        pt_ans = (pt)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">            p[i].ind = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">convex_hull</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;pt_ans.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pt_ans.y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">9 1</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">9 9</span></span><br><span class="line"><span class="comment">5 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="ZJ-b288-夏季大三角"><a href="#ZJ-b288-夏季大三角" class="headerlink" title="ZJ b288: 夏季大三角"></a>ZJ b288: 夏季大三角</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=b288">題目連結</a><br><a href="https://zerojudge.tw/ShowThread?postid=26741&amp;reply=0">解題報告</a></p>
<blockquote>
<p>題目敘述<br>請輸出在N個二維平面的座標，挑選3顆出來成組成三角形的最大面積</p>
</blockquote>
<p>比較一下兩個複雜度的作法，第一個是使用 $O(n^3)$ 枚舉所有的點並計算面積，所需要的時間是0.4sec，而且需要特別注意不能使用到海龍公式計算面積，否則有很大的機會會超時。</p>
<p><img src="https://i.imgur.com/oN26CR4.png" alt=""></p>
<p>以下作法是先進行 $O(n\log n)$ 找尋凸包，因為面積最大的三角形必定三個點都在凸包上，因此用 $n^2$ 的時間進行枚舉，旋轉卡尺（類似最遠點對的作法）找面積最大的第三個點，就能在總時間複雜度 $O(n^2)$ 完成！（會再更少，因為只要枚舉凸包上的點）</p>
<p><img src="https://i.imgur.com/SUwVRWv.png" alt=""></p>
<p>以下是AC Code：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    ld x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-b.x)&lt;=eps &amp;&amp; <span class="built_in">abs</span>(y-b.y)&lt;=eps)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    ld <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    ld <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pt&gt; p,hull;</span><br><span class="line"><span class="keyword">int</span> n,t,h;</span><br><span class="line">ld ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cross = (a - o)^(b - o);</span><br><span class="line">    <span class="keyword">return</span> cross &gt;= <span class="number">0</span>;                              <span class="comment">//這裡很關鍵，別吃WA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(pt a,pt b,pt c,pt d)</span></span>&#123;</span><br><span class="line">    ld aa = (a - c)^(b - c);</span><br><span class="line">    ld bb = (a - d)^(b - d);</span><br><span class="line">    <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">area</span><span class="params">(pt a,pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a^b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convex_hull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hull.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);       <span class="comment">//首先對x進行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;                   <span class="comment">//依序走訪，如果遇到外積&lt;0則不在凸包上</span></span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);             <span class="comment">//在凸包hull的每一點都符合外積小於0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> down_hull = hull.<span class="built_in">size</span>();</span><br><span class="line">    h = down_hull<span class="number">-1</span>;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();                   <span class="comment">//x最大的點會在凸包上，不用做兩次先pop一次</span></span><br><span class="line">    <span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());        <span class="comment">//將所有點逆序之後做一次上面的凸包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; down_hull &amp;&amp; <span class="built_in">check</span>(i,hull[hull.<span class="built_in">size</span>()<span class="number">-1</span>],hull[hull.<span class="built_in">size</span>()<span class="number">-2</span>]))&#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,i+<span class="number">1</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">            d = (j+<span class="number">1</span>)%sz;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">check2</span>(hull[i],hull[(j)%sz],hull[d],hull[(d+<span class="number">1</span>)%sz]))</span><br><span class="line">                d = (d+<span class="number">1</span>)%sz;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">area</span>((hull[d]-hull[i]),(hull[d]-hull[j])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">assign</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    <span class="built_in">convex_hull</span>();</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TIOJ-1500-Clean-up-on-aisle-3"><a href="#TIOJ-1500-Clean-up-on-aisle-3" class="headerlink" title="TIOJ 1500 Clean up on aisle 3"></a>TIOJ 1500 Clean up on aisle 3</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1500">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262966">Submission</a></p>
<blockquote>
<p>題目敘述<br>平面上n個點找最近點對的距離</p>
</blockquote>
<p>最近點對真的有超多種作法的，枚舉、掃描線、分治、隨機都可以做！這邊有<a href="/hVplrqxCRdGiMkn2lwXGAA">一篇筆記</a>比較各種時間複雜度的最近點對作法，這邊不多做贅述！</p>
<p>以下程式碼是掃描線演算法，最差情況下的時間複雜度是 $O(n^2)$，因為需要排序，所以下限為 $\Omega(n\log n)$！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 5e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">dis</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    ld x = a.x-b.x, y = a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        <span class="built_in">sort</span>(p,p+n);</span><br><span class="line">        ld d = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,i+<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j].x &gt; p[i].x + d)<span class="keyword">break</span>;</span><br><span class="line">                d = <span class="built_in">min</span>(d, <span class="built_in">dis</span>(p[i],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1280-領土-Territory"><a href="#TIOJ-1280-領土-Territory" class="headerlink" title="TIOJ 1280 領土 (Territory)"></a>TIOJ 1280 領土 (Territory)</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1280">題目連結</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262848">Submission</a></p>
<blockquote>
<p>題目敘述<br>一個國家有 n 個安全哨，每一個都有座標 $(x,y)$ ，代表在座標軸上的位置。輸出該國安全哨所能圍出的最大領土。</p>
</blockquote>
<p>n個點所能圍成的最大面積，其實等價於凸包的面積。與前幾題的<strong>最小凸多邊形</strong>是一模一樣的題目！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa^bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    vector&lt;pt&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = h.<span class="built_in">size</span>();</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;sz &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-2</span>)&#123;</span><br><span class="line">        area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;((area%<span class="number">2</span>)?(area/<span class="number">2</span>)+<span class="number">1</span>:(area/<span class="number">2</span>))&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-a871-Museum-Area"><a href="#ZJ-a871-Museum-Area" class="headerlink" title="ZJ a871: Museum Area"></a>ZJ a871: Museum Area</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=a871">題目連結</a></p>
<blockquote>
<p>題目敘述<br>n個點圍成的多邊形，求面積</p>
</blockquote>
<p>水題，直接套行列式公式即可算出答案！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pdd p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">check</span><span class="params">(pdd a, pdd b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y - a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        ld area = <span class="number">0.0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)area += <span class="built_in">check</span>(p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">        ld ans = (ld)area/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans = -ans;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIOJ-1678-剪多邊形（molding）"><a href="#TIOJ-1678-剪多邊形（molding）" class="headerlink" title="TIOJ 1678 剪多邊形（molding）"></a>TIOJ 1678 剪多邊形（molding）</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1678">題目連結TIOJ</a><br><a href="https://tioj.ck.tp.edu.tw/submissions/262849">TIOJ Submission</a><br><a href="https://zerojudge.tw/ShowProblem?problemid=d546">題目連結ZJ</a></p>
<blockquote>
<p>題目敘述<br>間單來說是求出多邊形面積以及凸包面積的差，詳細可以點上面題目連結。</p>
</blockquote>
<p>題目說多邊形需要才剪下的面積，我們就算凸包面積以及多邊形面積，兩者的差去除上題目給的色塊面積即是答案！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == b.x)<span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (pt b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x-b.x == <span class="number">0</span> &amp;&amp; y-b.y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pt <span class="keyword">operator</span>+(pt b) &#123;<span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;;&#125; <span class="comment">//向量相加</span></span><br><span class="line">    pt <span class="keyword">operator</span>-(pt b) &#123;<span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;;&#125; <span class="comment">//向量相減</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>^(pt b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125; <span class="comment">//向量外積cross</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*(pt b) &#123;<span class="keyword">return</span> x * b.x + y * b.y;&#125; <span class="comment">//向量內積dot</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;pt&gt; p,temp,pp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  cnt;</span><br><span class="line"><span class="keyword">int</span> n,a,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pt a, pt b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x)<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pt a,pt b,pt o)</span></span>&#123;</span><br><span class="line">    pt aa = a - o;</span><br><span class="line">    pt bb = b - o;</span><br><span class="line">    <span class="keyword">return</span> (aa^bb) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pt&gt; <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(p),cmp);</span><br><span class="line">    vector&lt;pt&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(pt i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = h.<span class="built_in">size</span>();</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;sz &amp;&amp; <span class="built_in">check</span>(i,h[h.<span class="built_in">size</span>()<span class="number">-1</span>],h[h.<span class="built_in">size</span>()<span class="number">-2</span>]))</span><br><span class="line">            h.<span class="built_in">pop_back</span>();</span><br><span class="line">        h.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Polygon</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;pt&gt; <span class="title">temp</span><span class="params">(p)</span></span>;</span><br><span class="line">    temp.<span class="built_in">push_back</span>(temp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)area += (temp[i]^temp[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(area);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">    p.<span class="built_in">resize</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">    ld small = (ld)<span class="built_in">Polygon</span>()/<span class="number">2</span>;</span><br><span class="line">    vector&lt;pt&gt; hull = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>,sz = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,sz<span class="number">-2</span>)area += (hull[i]^hull[i+<span class="number">1</span>]);</span><br><span class="line">    ld big = (ld)area/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">ceil</span>((big-small)/a);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZJ-d269-11579-Triangle-Trouble"><a href="#ZJ-d269-11579-Triangle-Trouble" class="headerlink" title="ZJ d269: 11579 - Triangle Trouble"></a>ZJ d269: 11579 - Triangle Trouble</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d269">題目連結</a></p>
<blockquote>
<p>題目敘述<br>有一個三角形工廠有一個很大的問題。給你一些邊的邊長，想辦法找出用這些邊長圍出最大的三角形。</p>
</blockquote>
<p>根據海龍公式，三角形面積：</p>
<script type="math/tex; mode=display">\triangle ABC = \sqrt{s\cdot(s-a)\cdot(s-b)\cdot(s-c)}</script><p>可以利用貪婪法，將所有邊長由大到小進行排序，每一次拿最大的三個邊長進行枚舉，即可算出最大的三角形面積。不難理解，當換上一個比較大的邊，算出來的s也會比較大，跟邊相減的值也會比較大，總面積自然較大（好啦，這是非常不嚴謹的證明XD）</p>
<p>在想題過程中，我有思考到，如果周長一樣的情況下，到底何種面積的三角形面積會比較大？答案是正三角形！</p>
<div class="note default">
            <p><strong>三角形周長固定下面積的比較</strong><br>根據海龍公式：</p><script type="math/tex; mode=display">s = \frac{1}{2}(a+b+c)</script><p>想要比較在周長固定下三角形的面積，可以用算幾不等式比較，因為 $s$ 是定值，所以可以列出以下式子：</p><script type="math/tex; mode=display">\frac{(s-a)+(s-b)+(s-c)}{3} ≥ \sqrt[3]{(s-a)(s-b)(s-c)}</script><p>等好成立時，$a=b=c$。因為$s = \frac{a+b+c}{2}$，因此：</p><script type="math/tex; mode=display">(\frac{a}{2})^2 ≥ (s-a)(s-b)(s-c)</script><p>得到海龍公式</p><script type="math/tex; mode=display">\triangle ABC = \sqrt{s\cdot(s-a)\cdot(s-b)\cdot(s-c)} ≤ \sqrt{\frac{3a}{2}\cdot\frac{a^3}{8}}=\frac{\sqrt{3}}{4}a^2</script>
          </div>
<p>以下是使用貪婪法的AC Code：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Orz ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">vector&lt;ld&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function">ld <span class="title">area</span><span class="params">(ld a ,ld b, ld c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b + c)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ld p = (a+b+c)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> p*(p-a)*(p-b)*(p-c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Orz;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        p.<span class="built_in">assign</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)cin&gt;&gt;p[i];</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(p),greater&lt;&gt;());</span><br><span class="line">        ld ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-3</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">area</span>(p[i],p[i+<span class="number">1</span>],p[i+<span class="number">2</span>]));</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">sqrt</span>(ans)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>計算幾何，顧名思義就是在電腦完成幾何的運算，要怎麼把平面的東西轉化成電腦看得懂的東西就是計算幾何在做的事情。常常我們覺得很容易判斷的事情，例如判斷線段是否相交，我們可以利用肉眼直輕易判斷出來，因為我們有強大的空間感幫助我們進行判斷，但換作是電腦就必須用一些數學的技巧，對於不同的情況做各自的判斷，才能讓電腦正確回答兩條線段的相交情形。</p>
<p>除此之外，在寫題過程中，使用到ggb進行輔助，讓我可以對程式的執行過程有更是覺化的概念，也幫助我在解題時能更理解解題的策略！上面一題三角形個數的判斷，就使用了ggb判定將點搬移的所有情況。利用它我抓到了當點的y座標為零時並沒進行好特殊情況的判斷，這也是一個視覺化之後的好處！</p>
<p>有一題沒有做的是模擬退火的題目實作，要求圓與三角形的交集面積，感覺超級複雜，以後有時間來慢慢實作！</p>
]]></content>
      <categories>
        <category>C++進階主題</category>
        <category>計算幾何</category>
      </categories>
      <tags>
        <tag>計算幾何</tag>
        <tag>暑期筆記</tag>
      </tags>
  </entry>
</search>
